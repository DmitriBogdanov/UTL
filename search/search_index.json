{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":""},{"location":"index.html#utl","title":"UTL","text":"<p>UTL is a collection of small self-contained libraries with a major aim towards usage simplicity. It was mostly created during my work in gamedev and mathematical research for the purpose of fast prototyping.</p> <p>For the ease of integration, all libraries are distributed as individual headers, which can be found here.</p> <p>The entire collection can also be downloaded as an amalgamated single-header.</p> <p>CMake <code>FetchContent()</code> support is also provided.</p>"},{"location":"index.html#design-goals","title":"Design goals","text":"<p>Implementation of this library sets following design goals:</p> <ul> <li>Easy integration. Adding libraries to the project should be as simple as including their corresponding headers.</li> <li>Concise syntax. Library usage should require minimal boilerplate on user side.</li> <li>Platform agnostic. Implementation should be based around the C++ standard. Platform-specific features might be provided as optional addons.</li> <li>Non-intrusive. Every library should reside in its own namespace, use its own macro prefix and not introduce any invasive identifiers.</li> </ul> <p>Quality goals include:</p> <ul> <li>Modern C++ style. Usage of modern C++ idioms is heavily preferred.</li> <li>Usage examples. Documentation should include  practical usage examples for all major methods.</li> <li>Test &amp; benchmark coverage. All modules should have appropriate unit test coverage, performance-focused implementations should be benchmarked against alternative approaches.</li> <li>Easy to build. All headers, tests, benchmarks and examples should build under the strictest warning levels and with minimal tooling.</li> </ul>"},{"location":"index.html#modules-documentation","title":"Modules &amp; documentation","text":"Module Short description utl::assertion Assert macro with more diagnostic info utl::bit Bit-twiddling, enum bitflags utl::enum_reflect Enum reflection utl::integral Saturated math, safe integer casts, literals, rounding and etc. utl::json JSON parsing, serializing &amp; reflection utl::log Logging library utl::math Additional math functions utl::mvl Generalized matrix &amp; vector containers utl::parallel Thread pool, async tasks, parallel for, parallel reductions and etc. utl::predef Detection of architectures, compilers, platforms and etc. utl::profiler Call graph &amp; thread profiling utl::progressbar Progress bars for CLI apps utl::random PRNGs &amp; random number generation utl::shell Shell commands and temporary files utl::sleep Precise sleep implementations utl::stre Efficient implementations of common string utils utl::strong_type Strong typedefs &amp; RAII wrappers utl::struct_reflect Struct reflection utl::table Export ASCII, Markdown, LaTeX, Mathematica and CSV tables utl::time Floating-point time, timers, stopwatches, datetime"},{"location":"index.html#see-also","title":"See also","text":"<ul> <li>How to include only specific modules when using amalgamated header</li> <li>Fetching the library with CMake <code>FetchContent()</code></li> <li>Names reserved for implementation</li> <li>Building tests &amp; benchmarks</li> <li>Building documentation</li> <li>Semantic versioning</li> <li>Reproducing figures</li> </ul>"},{"location":"index.html#requirements","title":"Requirements","text":"<ul> <li>Requires C++17 support</li> <li>Some headers require a compliant preprocessor flag (<code>/Zc:preprocessor</code>) when using MSVC, such headers specify it in the docs</li> </ul>"},{"location":"index.html#developer-toolchain","title":"Developer toolchain","text":"<p>While the library itself consists of isolated headers with no embedded dependencies, it was built and tested using a number of third-party tools and libraries, some of which are embedded in the repo.</p> Tool Version Used for clang-format v.14.0.0 Automatic code formatting clangd v.15.0.7 Language server functionality CMake v.3.2.11 Build system, CTest testing facilities GCC v.11.4.0 ASan and UBSan test instrumentation cppcheck v.2.7 Static analysis GitHub Actions latest Multi-platform CI testing MkDocs latest Building the website Matplotlib latest Data visualization Library Version License Used for Embedded in repo doctest v.2.4.11 MIT Unit testing \u2714 nanobench v.4.3.11 MIT Benchmarking \u2714 nlohmann json v.3.11.3 MIT Benchmark comparison \u2714 PicoJSON v.1.3.0 BSD-2 Benchmark comparison \u2714 RapidJSON v.1.1.0 MIT, BSD, JSON Benchmark comparison \u2714 JSONTestSuite commit 1ef36fa MIT JSON Validation test suite \u2714 BS::thread_pool v.5.0.0 MIT Benchmark comparison \u2714 progschj/ThreadPool commit 9a42ec1 zlib Benchmark comparison \u2714"},{"location":"index.html#roadmap","title":"Roadmap","text":"<ul> <li>Create packages for <code>Conan</code> and <code>vcpkg</code></li> <li>Possibly provide PCH targets for internal and external use</li> <li>Set up better test coverage statistics</li> <li><code>utl::mvl</code> v1.0.0 release, involves a large scale refactor and several bug fixes</li> <li><code>utl::random</code> v3.0.0 release, includes CBPRNGs and fixed-entropy seeding sequence</li> </ul>"},{"location":"index.html#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE.md for details.</p>"},{"location":"dev_commit_style.html","title":"Commit style","text":"<p>This file contains standard commit style for this project.</p>"},{"location":"dev_commit_style.html#commit-types","title":"Commit types","text":"Type Description <code>feat</code> New features <code>test</code> New unit tests <code>bench</code> New benchmarks <code>fix</code> Bugfixes <code>refactor</code> Code refactors <code>build</code> Build script changes <code>docs</code> Documentation changes <code>chore</code> Typo fixes, file renames and etc"},{"location":"dev_commit_style.html#commit-message-format","title":"Commit message format","text":""},{"location":"dev_commit_style.html#format","title":"Format","text":"<pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;summary&gt;.\n// repeat for all changes according to commit types\n// &lt;scope&gt; can be omitted for changes not related to a particular module\n</code></pre>"},{"location":"dev_commit_style.html#example","title":"Example","text":"<pre><code>feat(mvl): Mostly implemented sparse and dense blocking operations.\n\nchore(): Typo fixes in comments &amp; documentation.\n\ndocs(mvl): Fixes some incorrect definitions and wonky SVG rendering.\n\ndocs(): Improved table with used tools &amp; libraries.\n</code></pre>"},{"location":"dev_file_templates.html","title":"File templates","text":"<p>This file contains templates to ensure a standardized style of source files, documentation and etc.</p>"},{"location":"dev_file_templates.html#module-template","title":"Module template","text":"<pre><code>// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DmitriBogdanov/UTL ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\n// Module:        utl::xxxxxxxxxxxx\n// Documentation: https://github.com/DmitriBogdanov/UTL/blob/master/docs/module_xxxxxxxxxxxx.md\n// Source repo:   https://github.com/DmitriBogdanov/UTL\n//\n// This project is licensed under the MIT License\n//\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n#if !defined(UTL_PICK_MODULES) || defined(UTL_MODULE_XXXXXXXXXXXX)\n\n#ifndef utl_xxxxxxxxxxxx_headerguard\n#define utl_xxxxxxxxxxxx_headerguard\n\n#define UTL_XXXXXXXXXXXX_VERSION_MAJOR 1\n#define UTL_XXXXXXXXXXXX_VERSION_MINOR 0\n#define UTL_XXXXXXXXXXXX_VERSION_PATCH 0\n\n// _______________________ INCLUDES _______________________\n\n// NOTE: STD INCLUDES\n\n// ____________________ DEVELOPER DOCS ____________________\n\n// NOTE: DOCS\n\n// ____________________ IMPLEMENTATION ____________________\n\nnamespace utl::xxxxxxxxxxxx::impl {\n\n// NOTE: IMPL\n\n} // namespace utl::xxxxxxxxxxxx\n\n// ______________________ PUBLIC API ______________________\n\nnamespace utl::xxxxxxxxxxxx {\n\n// NOTE: API\n\n} // namespace utl::xxxxxxxxxxxx\n\n#endif\n#endif // module utl::xxxxxxxxxxxx\n</code></pre> <p>Replace <code>XXXXXXXXXXXX</code> with module name.</p>"},{"location":"dev_file_templates.html#test-template","title":"Test template","text":"<pre><code>#include \"tests/common.hpp\"\n\n#include \"include/UTL/XXXXXXXXXXXX.hpp\"\n\n// _______________________ INCLUDES _______________________\n\n// None\n\n// ____________________ IMPLEMENTATION ____________________\n\nTEST_CASE(\"TEST_NAME\") {\n    // TODO:\n}\n</code></pre> <p>Replace <code>XXXXXXXXXXXX</code> with module name.</p> <p>Dependencies on other modules:</p> <p>Not allowed.</p> <p>Test cases and naming:</p> <p>File can contain multiple test cases with names <code>&lt;case&gt; / &lt;subcase&gt;</code> or one case with name <code>&lt;case&gt;</code>. Here <code>&lt;case&gt;</code> is a a copy of filename, but capitalized and separated with spaces rather than <code>_</code> for better readability.</p> <p>Reason for not using <code>SUBCASE()</code>:</p> <p>1. Less indentation</p> <p>2. There is not <code>SUBCASE_TEMPLATE()</code> to replace <code>TEST_CASE_TEMPLATE()</code>, which is frequently needed to test templates</p> <p>Difference between case and subcase:</p> <p>Subcases should be used when there are multiple test cases relying on the same boilerplate and separating them into different files would cause code duplication. They can also be used for test cases that are too small &amp; granular to warrant a separate file.</p>"},{"location":"dev_file_templates.html#benchmark-template","title":"Benchmark template","text":"<pre><code>#include \"benchmarks/common.hpp\"\n\n#include \"include/UTL/xxxxxxxxxxxx.hpp\"\n\n// _______________________ INCLUDES _______________________\n\n// UTL dependencies\n// None\n\n// Libraries to benchmarks against\n// None\n\n// Standard headers\n// None\n\n// ____________________ IMPLEMENTATION ____________________\n\n// =================\n// --- Benchmark ---\n// =================\n\nvoid benchmark_xxx() {\n    // TODO:\n}\n\n// ========================\n// --- Benchmark runner ---\n// ========================\n\nint main() {\n    benchmark_xxx();\n}\n</code></pre> <p>Replace <code>XXXXXXXXXXXX</code> with module name.</p> <p>Dependencies on other modules:</p> <p>Discouraged, but allowed.</p>"},{"location":"dev_file_templates.html#example-template","title":"Example template","text":"<pre><code>#include \"include/UTL/XXXXXXXXXXXX.hpp\"\n\nint main() {\n    // TODO:\n}\n</code></pre> <p>Replace <code>XXXXXXXXXXXX</code> with module name.</p> <p>Dependencies on other modules:</p> <p>Allowed if it helps an example, generally should be avoided.</p> <p>Godbolt links:</p> <p>Online examples should copy the local ones, but with a different include format:</p> <pre><code>#include &lt;https://raw.githubusercontent.com/DmitriBogdanov/UTL/master/include/UTL/XXXXXXXXXXXX.hpp&gt;\n</code></pre> <p>Docs might contain an even shorter form without <code>main()</code>.</p> <p>Links should be shortened due to some Markdown editor struggling with full links, shortened Godbolt links never expire.</p> <p>Compiler should be: <code>x86-64 gcc (trunk)</code></p> <p>Flags should be: <code>-std=c++17</code></p>"},{"location":"dev_file_templates.html#in-code-headers","title":"In-code headers","text":""},{"location":"dev_file_templates.html#header-1","title":"Header 1","text":"<pre><code>// ================\n// --- Header 1 ---\n// ================\n</code></pre>"},{"location":"dev_file_templates.html#header-2","title":"Header 2","text":"<pre><code>// --- Header 2 ---\n// ----------------\n</code></pre>"},{"location":"dev_file_templates.html#header-3","title":"Header 3","text":"<pre><code>// - Header 3 -\n</code></pre>"},{"location":"dev_roadmap.html","title":"Project roadmap","text":"<p>This file contains a rough roadmap of planned features.</p>"},{"location":"dev_roadmap.html#future-c20-migration","title":"Future C++20 migration","text":""},{"location":"dev_roadmap.html#requirements","title":"Requirements","text":"<p>C++20 should have a statistical majority of users. As of now that title belongs to C++17.</p>"},{"location":"dev_roadmap.html#minimal-task-list","title":"Minimal task list","text":"<p>Before migration following tasks are to be finished: - Finish all modules below version <code>1.0.0</code> (mvl remaining) - Standardize benchmarks (using standard <code>benchmarks/common.hpp</code>) (done \u2714) - Standardize tests (using standard <code>tests/common.hpp</code>) (done \u2714) - Write unit tests for all reasonably testable modules (mvl remaining) - Add all documentation examples to the build process (done \u2714) - Switch building to CMake presets (done \u2714) - Add CI workflows for all major platforms (done \u2714) - Ensure full documentation coverage (done \u2714)</p> <p>Once this is done, the current branch can be archived as <code>cpp17</code> branch, while <code>master</code> moves on to C++20.</p>"},{"location":"dev_roadmap.html#migration-refactors","title":"Migration refactors","text":"Refactor Expected scope Motivation Completion Replace SFINAE with concepts <code>mvl</code> everything, <code>math</code> constraints, <code>log</code> stringification, <code>integral</code>, <code>random</code>, almost everything really Better clarity, improved compile times, better error messages \u2718 Do a pass on possible <code>constexpr</code> expansion for all the functions that got <code>constexpr</code> support ? More <code>constexpr</code>, better testing and UB guarantees \u2718 Replace some stream-based formatting with <code>std::format</code> <code>log</code>, possibly others Better performance \u2718 Replace <code>std::thread</code> with <code>std::jthread</code> <code>parallel</code>, <code>log</code> Stop token support, automatic joining \u2718 See if some uses of <code>std::conditional_variable</code> waiting can be replaced with <code>std::atomic</code> wait <code>parallel</code> Possible performance enhancement \u2718 Replace class operators <code>&lt;, &gt;, ==, !=</code> with a spaceship operator <code>&lt;=&gt;</code> ? More generic \u2718 Add <code>[[likely]]</code> and <code>[[unlikely]]</code> attributes where appropriate <code>json</code> exceptions, <code>mvl</code> bound checking Possible performance enhancement \u2718 Use <code>__VA_OPT__</code> to remove the need for trailing comma support by the compiler ? Less reliance of compiler specifics \u2718 Replace some occurrences of <code>const std::vector&lt;&gt;</code> with <code>std::span&lt;&gt;</code> ? Cleaner &amp; faster API \u2718 Replace map/set <code>.count()</code> with <code>.contains()</code> <code>json</code> Better clarity \u2718 Add <code>constinit</code> to static variables that can be initialized from <code>constexpr</code> values ? Possible performance enhancement \u2718 Replace macros that use <code>__FILE__</code>, <code>__LINE__</code>, <code>__func</code> with templates using <code>std::source_location</code> <code>log</code> Less macro usage \u2718 Replace some casts with explicit <code>std::bit_cast&lt;&gt;()</code> <code>random</code>, <code>integral</code> Better clarity, possibly performance enhancement in some cases \u2718 Use <code>std::endian</code> for additional compilation summary <code>predef</code> More features \u2718 Switch from <code>C</code> way of getting dates to <code>&lt;chrono&gt;</code> calendar additions <code>log</code>, <code>time</code> Better performance, cleared and more powerful system \u2718 Remove <code>stre::start_with()</code> and <code>stre::ends_with()</code> as they are now a part of <code>std</code> <code>stre</code> ! Might be be worth leaving to prevent API breakage \u2718 Remove/rename some constants on <code>utl::math</code> as they are now a part of <code>std</code> <code>math</code> ! Might be be worth leaving to prevent API breakage \u2718 Remove heterogeneous integer comparison and <code>in_range()</code> from <code>utl::integral</code> as it is now a part of <code>std</code> <code>integral</code> ! Might be be worth leaving to prevent API breakage \u2718 Remove <code>to_underlying()</code> as it is now a part of <code>std</code> <code>enum_reflect()</code> ! Might be be worth leaving to prevent API breakage \u2718 Replace <code>rotl()</code> and <code>popcount()</code> with <code>std</code> functions <code>random</code> Possible performance enhancement, needs benchmarking \u2718"},{"location":"dev_roadmap.html#useful-links","title":"Useful links","text":"<ul> <li>Listing of features added in each standard from C++11 to C++20</li> <li>Cppreference for new language features</li> </ul>"},{"location":"dev_testing_toolchain.html","title":"Testing toolchain","text":"<p>This file contains a high-level description of the toolchain and testing methodology.</p>"},{"location":"dev_testing_toolchain.html#gcc-llvm-toolchain","title":"GCC &amp; LLVM toolchain","text":""},{"location":"dev_testing_toolchain.html#motivation","title":"Motivation","text":"<p>We need a robust set of toolchain options to detect correctness and security issues.</p> <p>GCC and LLVM toolchains are highly compatible and give us a good set of pedantic flags, sanitizers and coverage options.</p>"},{"location":"dev_testing_toolchain.html#compiler-flags","title":"Compiler flags","text":"Flags Motivation <code>-O0</code> No optimization makes compilation a bit faster <code>-g3</code> Leaves as much debug info as possible <code>-Wall -Wextra -Wpedantic -Werror</code> More warnings, treat warnings as errors <code>-fsanitize=undefined,address,leak</code> Enable sanitizers <code>-fno-sanitize-recover=all</code> Sanitizers should stop execution when  triggered  (which fails the test), default behavior is to continue <code>--coverage</code> Adds instrumentation for coverage analysis, for GCC works as an alias for <code>-fprofile-arcs -ftest-coverage</code> when compiling and <code>-lgcov</code> when linking"},{"location":"dev_testing_toolchain.html#linker-flags","title":"Linker flags","text":"Flag Motivation <code>-fsanitize=undefined,address,leak</code> Sanitizers require linking against corresponding instrumentation libs <code>--coverage</code> Coverage analysis requires linking against corresponding instrumentation lib"},{"location":"dev_testing_toolchain.html#useful-links","title":"Useful links","text":"<ul> <li>GCC debugging options</li> <li>GCC instrumentation options</li> <li>Clang diagnostic flags</li> <li>Clang ASan</li> <li>Clang UBSan</li> </ul>"},{"location":"dev_testing_toolchain.html#other-useful-flags","title":"Other useful flags","text":"Flag Usage <code>-fno-omit-frame-pointer</code> Doesn't matter with <code>-O0</code>, prohibits optimization than makes stack traces harder to analyze"},{"location":"dev_testing_toolchain.html#cmake-presets","title":"CMake presets","text":""},{"location":"dev_testing_toolchain.html#motivation_1","title":"Motivation","text":"<p>We need a clean way to build and test project for multiple platforms, compilers and configurations.</p> <p>CMake presets were added as an intended solution for this exact problem.</p>"},{"location":"dev_testing_toolchain.html#problems","title":"Problems","text":"<p>While on first glance presets seem like a perfect solution for configuration management, they have several flaws complicating their usage in practice:</p> <ul> <li>Combinatorial explosion of configurations due to the lack of <code>--preset</code> merging (see issue)</li> <li>Strong association between build / test presets and configure presets, which has no real reason to exist</li> <li>Inability comment <code>CMakePresets.json</code> makes it difficult to keep track of different build quirks</li> </ul>"},{"location":"dev_testing_toolchain.html#summary","title":"Summary","text":"<p>Despite all the issues, presets are still one of the few more-or-less sane ways of handling cross-platform building.</p> <p>All platform-specific logic can be neatly enough isolated into <code>CMakePresets.json</code>.</p>"},{"location":"dev_testing_toolchain.html#useful-links_1","title":"Useful links","text":"<ul> <li>CMake presets documentation</li> <li><code>cmake-init</code> as an example of robust preset management</li> </ul>"},{"location":"dev_testing_toolchain.html#github-actions","title":"Github actions","text":""},{"location":"dev_testing_toolchain.html#motivation_2","title":"Motivation","text":"<ol> <li>We need a good way of running builds and tests on multiple platforms</li> <li>We need to ensure  testing suite compliance without relying on the person to manually run it</li> </ol> <p>GitHub Actions were made for this exact purpose, we can leverage them to run continuous integration tests.</p>"},{"location":"dev_testing_toolchain.html#useful-links_2","title":"Useful links","text":"<ul> <li>Writing GitHub workflows</li> <li>About continuous integration</li> <li>About GitHub-hosted runners</li> </ul>"},{"location":"guide_building_docs.html","title":"Building documentation","text":"<p>&lt;- back to README.md</p> <p>This repo uses MkDocs with Material theme to build the website version of documentation.</p> <p>Documentation can be build locally through a rather simple process described below.</p> <p>Important</p> <p>Building documentation website is entirely optional, all docs are made to work locally as regular markdown files connected through relative links. Building it as a website does, however, provide a nicer experience.</p>"},{"location":"guide_building_docs.html#installing-dependencies","title":"Installing dependencies","text":"<p><code>python3</code> can be downloaded from the official website or using a package manager:</p> <pre><code>sudo apt update &amp;&amp;\nsudo apt install python3\n</code></pre> <p>To install necessary dependencies run:</p> <pre><code>pip install mkdocs-material &amp;&amp;\npip install mkdocs-material[imaging] &amp;&amp;\npip install markdown-callouts &amp;&amp;\npip install mkdocs-awesome-nav\n</code></pre> <p>Note</p> <p>When building for public deployment, social preview plugin also requires Cairo Graphics libraries. These libraries come preinstalled on Github Actions (Ubuntu), otherwise they can be manually downloaded with <code>apt</code>.</p>"},{"location":"guide_building_docs.html#building-the-docs","title":"Building the docs","text":"<p>To build documentation locally navigate to the project directory and run:</p> <pre><code>mkdocs serve\n</code></pre> <p>The link to open local documentation in the browser will appear in the terminal after the build.</p>"},{"location":"guide_building_project.html","title":"Building tests &amp; examples","text":"<p>&lt;- back to README.md</p> <p>This project uses CMake build system with presets as a main way of managing platform-dependent configuration.</p> <p>All benchmarks, tests and examples are split into granular targets following a similar directory structure, these targets are built as a part of the CI pipeline specified in GitHub workflows.</p> <p>For tests we use a built-in CMake test runner CTest.</p>"},{"location":"guide_building_project.html#building-with-cmake","title":"Building with CMake","text":"<p>Clone the repo:</p> <pre><code>git clone https://github.com/DmitriBogdanov/UTL.git &amp;&amp;\ncd \"UTL/\"\n</code></pre> <p>Configure CMake:</p> <pre><code>cmake --preset gcc\n</code></pre> <p>Build the project:</p> <pre><code>bash \"bash/create_single_header.sh\" &amp;&amp;\ncmake --build --preset gcc\n</code></pre> <p>Run tests:</p> <pre><code>ctest --preset gcc\n</code></pre> <p>Run benchmark:</p> <pre><code>./build/benchmarks/&lt;benchmark_name&gt;\n</code></pre>"},{"location":"guide_building_project.html#building-with-a-script","title":"Building with a script","text":"<p>To reduce the tedium of entering verbose commands during development, this repo provides <code>actions.sh</code> script, containing shortcuts for all the actions above set up for <code>gcc</code> preset.</p> <p>For example, we can clear previous build (if present), configure, build and run tests with a single command:</p> <pre><code>bash actions.sh clear config build test\n</code></pre>"},{"location":"guide_building_project.html#configuring-build","title":"Configuring build","text":"<p>Compiler, flags and CTest arguments are specified in <code>CMakePresets.json</code>.</p> <p>The canonical way of configuring local environment is <code>CMakeUserPresets.json</code>, use existing presets as a reference.</p> <p>Alternatively, it is possible to override specific variables from an existing preset, for example, to specify <code>g++13</code> instead of regular <code>g++</code> use following configuration:</p> <pre><code>cmake --preset gcc -D CMAKE_CXX_COMPILER=\"g++13\"\n</code></pre>"},{"location":"guide_building_project.html#notes-on-the-toolchain","title":"Notes on the toolchain","text":"<p>All developer targets are compiled with <code>-Wall -Wextra -Wpedantic -Werror</code> (or their MSVC equivalents). Tests also use sanitizers provided by the GCC / LLVM toolchain.</p> <p>CI pipeline is set up to test all 3 major compilers (<code>MSVC</code>, <code>GCC</code>, <code>clang</code>) with various standard libs (<code>STL</code>, <code>libstdc++</code>, <code>libc++</code>) on different operating systems (<code>Windows</code>, <code>Ubuntu</code>, <code>MacOS</code>, <code>FreeBSD</code>). All documented examples also double as tests to ensure their validity.</p> <p>For testing we use doctest framework wrapped in <code>tests/common.hpp</code>.</p> <p>For benchmarks we use nanobench framework wrapped in <code>benchmarks/common.hpp</code></p>"},{"location":"guide_fetching_library.html","title":"Fetching the library with CMake <code>FetchContent()</code>","text":"<p>&lt;- back to README.md</p> <p>While header-only libraries can be trivially included without any use of the build system, some users might prefer to manage their dependencies in a unified manner through CMake. For this purpose UTL provides two <code>INTERFACE</code> targets:</p> <pre><code>UTL::include\nUTL::single_include\n</code></pre> <p>corresponding to <code>include/</code> and <code>single_include/</code> directories.</p>"},{"location":"guide_fetching_library.html#fetchcontent-example","title":"<code>FetchContent()</code> example","text":"<p>CMake <code>FetchContent()</code> can be used to automatically download and expose UTL as a library:</p> <pre><code># Fetch library from GitHub\ninclude(FetchContent)\n\nFetchContent_Declare(\n    UTL\n    GIT_REPOSITORY https://github.com/DmitriBogdanov/UTL.git\n    GIT_TAG        v8.3.3\n)\n\nFetchContent_MakeAvailable(UTL)\n</code></pre> <p>Note: While <code>GIT_TAG</code> argument can be omitted to download the latest commit automatically, it is not recommended due to possible breaking changes in the newer versions of the library.</p>"},{"location":"guide_fetching_library.html#cpm-example","title":"<code>CPM</code> example","text":"<p>The same thing can be done using CPM for dependency management:</p> <pre><code># Fetch library from GitHub\ninclude(cmake/CPM.cmake)\n\nCPMAddPackage(\"gh:DmitriBogdanov/UTL#v8.3.3\")\n</code></pre> <p>Note: Use commit SHA instead of the tag to download specific commits.</p>"},{"location":"guide_fetching_library.html#linking-the-library","title":"Linking the library","text":"<p>Fetched library can now be linked to a target:</p> <pre><code># Link library to the executable\nadd_executable(main_target main.cpp)\n\ntarget_link_libraries(main_target UTL::include)\n</code></pre> <p>Which allows us to use it in <code>main.cpp</code>:</p> <pre><code>#include \"UTL/json.hpp\"\n\nint main() {\n    // &lt;code using utl::json&gt;\n}\n</code></pre>"},{"location":"guide_fetching_library.html#questions-and-answers","title":"Questions and answers","text":"<p>Q: Does this library set any CMake options or variables?</p> <p>A: The library operates exclusively on targets, no global variables are ever set.</p> <p>Q: What if I'm using an older commit that doesn't correspond to the current documentation?</p> <p>A: <code>FetchContent()</code> downloads this repo into <code>build/_deps/utl-src</code> together with corresponding documentation, which can be used offline since UTL docs are mostly written in standard markdown with relative links. Some things like badges might link to a repo, but most relevant content stays available.</p>"},{"location":"guide_license.html","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2023 Dmitri Bogdanov</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"guide_reproducing_figures.html","title":"Reproducing figures from documentation","text":"<p>&lt;- back to README.md</p> <p>All plots showcased in this repo are made to be easily reproducible.</p> <p>To achieve this we use a combination of C++ targets and Python scripts residing in the <code>auxiliary/</code> directory.</p> <p>Auxiliary targets are built together with tests, examples &amp; benchmarks in a similar fashion. These targets can be invoked to generate numerical data, which is then visualized with matplotlib.</p>"},{"location":"guide_reproducing_figures.html#generating-a-figure","title":"Generating a figure","text":"<p>Build the project according to the guide.</p> <p>To generate figures for <code>&lt;target_name&gt;</code> run the corresponding executable:</p> <pre><code>./build/auxiliary/auxiliary-&lt;target_name&gt;-generate\n</code></pre> <p>and then plot the result:</p> <pre><code>python3 auxiliary/&lt;target_name&gt;/plot.py \n</code></pre> <p>Generated data &amp; corresponding figures will reside in <code>temp/&lt;target_name&gt;/</code>.</p> <p>Important</p> <p>Last step requires additional dependencies that aren't necessary for the build, see below.</p>"},{"location":"guide_reproducing_figures.html#installing-python-dependencies","title":"Installing Python dependencies","text":"<p><code>python3</code> can be downloaded from the official website or using a package manager:</p> <pre><code>sudo apt update &amp;&amp;\nsudo apt install python3\n</code></pre> <p>To install necessary dependencies run:</p> <pre><code>pip install matplotlib &amp;&amp;\npip install mplcyberpunk\n</code></pre>"},{"location":"guide_reserved_names.html","title":"Names reserved by implementation","text":"<p>&lt;- back to README.md</p> <p>Due to the header-only nature of the library, all internal identifiers can be accessed from outside.</p> <p>Identifiers that are not a part of the public interface are considered implementation identifiers. All such identifiers follow a standardized naming convention that aims to reduce the probability of accidental name collisions.</p>"},{"location":"guide_reserved_names.html#reserved-local-identifiers","title":"Reserved Local Identifiers","text":"<p>All identifiers residing inside the <code>impl</code> namespace of a module:</p> <pre><code>utl::&lt;module_name&gt;::impl::&lt;identifier&gt;\n</code></pre>"},{"location":"guide_reserved_names.html#reserved-global-identifiers","title":"Reserved Global Identifiers","text":"<p>Macros prefixed with <code>utl_</code>:</p> <pre><code>utl_&lt;module_name&gt;_&lt;identifier&gt;\n</code></pre>"},{"location":"guide_selecting_modules.html","title":"Including only specific modules while using amalgamated header","text":"<p>&lt;- back to README.md</p> <p>While using individual headers is generally more robust, the amalgamated <code>UTL.hpp</code> still allows selection of individual libraries to include (for example, to reduce compile times when only some of the modules are needed).</p> <p>This is achievable by declaring <code>#define UTL_PICK_MODULES</code> and <code>#define &lt;module_identifier&gt;</code> for all necessary modules before including the library header, see examples.</p>"},{"location":"guide_selecting_modules.html#module-identifiers","title":"Module Identifiers","text":"Name Identifier <code>utl::bit</code> <code>UTL_MODULE_BIT</code> <code>utl::enum_reflect</code> <code>UTL_MODULE_ENUM_REFLECT</code> <code>utl::integral</code> <code>UTL_MODULE_INTEGRAL</code> <code>utl::json</code> <code>UTL_MODULE_JSON</code> <code>utl::log</code> <code>UTL_MODULE_LOG</code> <code>utl::math</code> <code>UTL_MODULE_MATH</code> <code>utl::mvl</code> <code>UTL_MODULE_MVL</code> <code>utl::parallel</code> <code>UTL_MODULE_PARALLEL</code> <code>utl::predef</code> <code>UTL_MODULE_PREDEF</code> <code>utl::profiler</code> <code>UTL_MODULE_PROFILER</code> <code>utl::progressbar</code> <code>UTL_MODULE_PROGRESSBAR</code> <code>utl::random</code> <code>UTL_MODULE_RANDOM</code> <code>utl::shell</code> <code>UTL_MODULE_SHELL</code> <code>utl::sleep</code> <code>UTL_MODULE_SLEEP</code> <code>utl::stre</code> <code>UTL_MODULE_STRE</code> <code>utl::struct_reflect</code> <code>UTL_MODULE_STRUCT_REFLECT</code> <code>utl::table</code> <code>UTL_MODULE_TABLE</code> <code>utl::time</code> <code>UTL_MODULE_TIME</code>"},{"location":"guide_selecting_modules.html#examples","title":"Examples","text":""},{"location":"guide_selecting_modules.html#selecting-specific-modules","title":"Selecting specific modules","text":"<p>[ Run this code ] <pre><code>// Indicate that you want to select specific modules\n#define UTL_PICK_MODULES\n\n// List modules that should be compiled\n#define UTL_MODULE_MATH\n#define UTL_MODULE_PROGRESSBAR\n\n#include \"UTL.hpp\"\n\n\nint main() {\n    // &lt; your code here &gt;\n}\n</code></pre></p>"},{"location":"guide_selecting_modules.html#selecting-modules-in-different-locations","title":"Selecting modules in different locations","text":"<p>[ Run this code ] <pre><code>// Pick some modules in one header\n#define UTL_PICK_MODULES\n#define UTL_MODULE_JSON\n#include \"UTL.hpp\"\n\n// ...\n\n// Pick some more modules in another header\n#define UTL_PICK_MODULES\n#define UTL_MODULE_RANDOM\n#define UTL_MODULE_LOG\n#include \"UTL.hpp\"\n\n// ...\n\n// Translation unit that includes both headers in any order will\n// have access to utl::json, utl::random and utl::log\n\n\n// This allows one to pull only necessary modules in each header.\n// Essentially, as long as UTL_PICK_MODULES is defined, \"UTL.hpp\"\n// acts as a collection of individual module headers concatenated\n// into a single file and enabled with #define UTL_MODULE_{NAME}\n//\n// Alternatively, just grab individual modules directly from the repo.\n\n\nint main() {\n    // &lt; your code here &gt;\n}\n</code></pre></p>"},{"location":"guide_versioning.html","title":"Semantic versioning","text":"<p>&lt;- back to README.md</p> <p>All UTL libraries follow semantic versioning, which is defined by 3 numbers MAJOR.MINOR.PATCH:</p> <ol> <li>MAJOR \u2014 version that makes incompatible API changes</li> <li>MINOR \u2014 version that adds functionality in a backwards compatible manner</li> <li>PATCH \u2014 version that contains backwards compatible chores &amp; bug fixes</li> </ol> <p>The version is defined at the top of each header with the following format:</p> <pre><code>#define UTL_&lt;module_name&gt;_VERSION_MAJOR &lt;major_integer&gt;\n#define UTL_&lt;module_name&gt;_VERSION_MINOR &lt;minor_integer&gt;\n#define UTL_&lt;module_name&gt;_VERSION_PATCH &lt;patch_integer&gt;\n</code></pre>"},{"location":"module_assertion.html","title":"utl::assertion","text":""},{"location":"module_assertion.html#utlassertion","title":"utl::assertion","text":"<p>&lt;- to README.md</p> <p>&lt;- to implementation.hpp</p> <p>utl::assertion header provides an (almost) drop-in replacement for the standard <code>assert()</code> with nicer semantics and more diagnostic info.</p> <p>Main features:</p> <ul> <li>Decomposes expressions and prints their values</li> <li>Has an optional message argument</li> <li>Customizable assert handler</li> <li>Nicely colored output</li> <li>An option to enable assertions in <code>Release</code></li> </ul> <p>Quick showcase:</p> <pre><code>const int rows = 10;\nconst int cols = 12;\n\nASSERT(rows == cols, \"Linear system requires a square matrix.\");\n</code></pre> <p></p>"},{"location":"module_assertion.html#definitions","title":"Definitions","text":"<pre><code>// Assertion macro\n#define UTL_ASSERTION(condition, ...)\n\n// Options (declared by the user)\n#define UTL_ASSERTION_ENABLE_SHORTCUT\n#define UTL_ASSERTION_ENABLE_IN_RELEASE\n#define UTL_ASSERTION_ENABLE_FULL_PATHS\n\n// Handler customization\nstruct FailureInfo {\n    std::string_view file;\n    std::size_t      line;\n    std::string_view func;\n\n    std::string_view expression;\n    std::string_view evaluated;\n    std::string_view context;\n\n    std::string to_string(bool color = false) const;\n};\n\nvoid set_handler(std::function&lt;void(const FailureInfo&amp;)&gt; handler);\n</code></pre>"},{"location":"module_assertion.html#methods","title":"Methods","text":""},{"location":"module_assertion.html#assertion-macro","title":"Assertion macro","text":"<pre><code>#define UTL_ASSERTION(condition, ...)\n</code></pre> <p>A macro semantically similar to <code>assert()</code>.</p> <p>In <code>Debug</code> mode (which means <code>NDEBUG</code> is not defined) checks whether <code>condition</code> is <code>true</code> and invokes assert handler in the case of failure.</p> <p>In <code>Release</code> mode (which means <code>NDEBUG</code> is defined) compiles to nothing.</p> <p>Differences relative to the standard <code>assert()</code>:</p> <ul> <li>This macro can be customized using options</li> <li>This macro also accepts message as an optional second parameter</li> <li>This macro also performs expression decomposition to print more diagnostic info</li> <li>Assert handler invoked by the failure is customizable (which is usually used to log failures, print stack traces and change failure behavior)</li> </ul> <p>Limitations:</p> <ul> <li>Only simple expressions without parenthesis can be decomposed (such as <code>a - b</code>, <code>a + b &lt; c</code> and etc.)</li> <li>Decomposed values should be printable using <code>std::ostream</code></li> </ul>"},{"location":"module_assertion.html#options","title":"Options","text":"<pre><code>#define UTL_ASSERTION_ENABLE_SHORTCUT // declared by the user\n</code></pre> <p>When defined before including the header, this macro enables shortcut <code>ASSERT()</code> for <code>UTL_ASSERTION()</code>.</p> <pre><code>#define UTL_ASSERTION_ENABLE_IN_RELEASE // declared by the user\n</code></pre> <p>When defined before including the header, this macro enables assertion checking in <code>Release</code> mode.</p> <pre><code>#define UTL_ASSERTION_ENABLE_FULL_PATHS // declared by the user\n</code></pre> <p>When defined before including the header, this macro enables full filepath display in failed assertions. By default only filename is displayed.</p> <p>Note: Full filepath can be rather verbose when using build systems such as CMake due to their tendency to pass absolute paths to the compiler.</p>"},{"location":"module_assertion.html#handler-customization","title":"Handler customization","text":"<pre><code>struct FailureInfo {\n    std::string_view file;\n    std::size_t      line;\n    std::string_view func;\n    \n    std::string_view expression;\n    std::string_view evaluated;\n    std::string_view context;\n    \n    std::string to_string(bool color = false) const;\n};\n</code></pre> <p>A struct that contains all of the information about a failed assertion:</p> Field Content <code>file</code> / <code>line</code> / <code>func</code> File / line / function from which the assertion failure was triggered <code>expression</code>/ <code>evaluated</code> Asserted condition before / after being evaluated <code>context</code> Optional message <p>It can be stringified with <code>to_string()</code> method, which uses ANSI color codes to improve readability when <code>color</code> is set to <code>true</code>.</p> <p>Note: If <code>context</code> was no provided, it defaults to <code>&lt;no context provided&gt;</code>.</p> <pre><code>void set_handler(std::function&lt;void(const FailureInfo&amp;)&gt; handler);\n</code></pre> <p>Note 1: Assertion failure <code>handler</code> is invoked in a thread-safe manner.</p> <p>Note 2: Default handler prints the colored failure info to <code>std::cerr</code> and calls <code>std::abort</code>.</p>"},{"location":"module_assertion.html#examples","title":"Examples","text":"<p>Important</p> <p>All of the examples below will use</p> <p><pre><code>#define UTL_ASSERTION_ENABLE_SHORTCUT\n#define UTL_ASSERTION_ENABLE_IN_RELEASE\n</code></pre> to reduce verbosity and wrap the code in <pre><code>std::signal(SIGABRT, [](int){ std::quick_exit(EXIT_SUCCESS); });\n// ...\nreturn EXIT_FAILURE;\n</code></pre> to allow running examples as tests which fail should the assertion not trigger.</p>"},{"location":"module_assertion.html#unary-assertion","title":"Unary assertion","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>std::unique_ptr&lt;int&gt; component;\n\nASSERT(component.get(), \"Cannot invoke handling for an empty component.\");\n</code></pre> <p>Output:</p> <p></p>"},{"location":"module_assertion.html#binary-assertion","title":"Binary assertion","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>const int rows = 10;\nconst int cols = 12;\n\nASSERT(rows == cols, \"Linear system requires a square matrix.\");\n</code></pre> <p>Output:</p> <p></p>"},{"location":"module_assertion.html#default-message","title":"Default message","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>// Second argument is optional, this can be used like a regular assert\nASSERT(2 + 4 == 17);\n</code></pre> <p></p>"},{"location":"module_assertion.html#logging-on-failure","title":"Logging on failure","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>utl::assertion::set_handler([](const utl::assertion::FailureInfo&amp; info) {\n    // Forward assertion message to some logging facility with colors disabled\n    std::ofstream(\"failure.txt\") &lt;&lt; info.to_string();\n\n    // Print &amp; abort like usually\n    std::cerr &lt;&lt; info.to_string(true);\n    std::abort();\n});\n\nASSERT(3 + 4 &lt; 6);\n</code></pre> <p>Output:</p> <p></p> <p><code>failure.txt</code>:</p> <pre><code>Assertion failed at logging_on_failure.cpp:24: int main()\n    Where condition:\n        3 + 4 &lt; 6\n    Evaluated to:\n        7 &lt; 6\n    Context:\n        &lt;no context provided&gt;\n</code></pre>"},{"location":"module_bit.html","title":"utl::bit","text":""},{"location":"module_bit.html#utlbit","title":"utl::bit","text":"<p>&lt;- to README.md</p> <p>&lt;- to implementation.hpp</p> <p>utl::bit module provides clean implementations for some of the common bit operations. Main highlights are:</p> <ul> <li>Individual bit manipulation</li> <li>Group bit operations</li> <li>Works with arbitrary sized integers</li> <li>Proper handling of signed types</li> <li>Type-safe enum bitflags</li> </ul> <p>Note</p> <p>Significant part of this module gets added into the standard library with C++20 <code>&lt;bits&gt;</code>, all such functions provide similar API to allow for a seamless transition. The only difference is that <code>std</code> requires inputs to be unsigned, while <code>bit</code> works on both signed &amp; unsigned.</p>"},{"location":"module_bit.html#definitions","title":"Definitions","text":"<pre><code>// Individual bit operations\ntemplate &lt;class T&gt; constexpr bool   get(T value, std::size_t bit) noexcept;\ntemplate &lt;class T&gt; constexpr T      set(T value, std::size_t bit) noexcept;\ntemplate &lt;class T&gt; constexpr T    clear(T value, std::size_t bit) noexcept;\ntemplate &lt;class T&gt; constexpr T     flip(T value, std::size_t bit) noexcept;\n\n// Group bit operations\ntemplate &lt;class T&gt; constexpr T lshift(T value, std::size_t shift) noexcept;\ntemplate &lt;class T&gt; constexpr T rshift(T value, std::size_t shift) noexcept;\ntemplate &lt;class T&gt; constexpr T   rotl(T value, std::size_t shift) noexcept;\ntemplate &lt;class T&gt; constexpr T   rotr(T value, std::size_t shift) noexcept;\n\n// Utils\nconstexpr std::size_t byte_size = CHAR_BIT;\n\ntemplate &lt;class T&gt; constexpr std::size_t size_of;\n\ntemplate &lt;class T&gt; constexpr std::size_t    width(T value) noexcept;\ntemplate &lt;class T&gt; constexpr std::size_t popcount(T value) noexcept;\n\n// Enum Bitflags\ntemplate&lt;class E&gt;\nstruct Flags {\n    constexpr Flags(                      E       flag) noexcept;\n    constexpr Flags(std::initializer_list&lt;E&gt; flag_list) noexcept;\n\n    constexpr operator bool() const noexcept;\n    constexpr        E  get() const noexcept;\n\n    constexpr bool contains(E      flag) const noexcept;\n    constexpr bool contains(Flags other) const noexcept;\n\n    constexpr Flags&amp;    add(E      flag) noexcept;\n    constexpr Flags&amp;    add(Flags other) noexcept;\n    constexpr Flags&amp; remove(E      flag) noexcept;\n    constexpr Flags&amp; remove(Flags other) noexcept;\n\n    // + bit-wise   operators\n    // + comparison operators\n};\n</code></pre>"},{"location":"module_bit.html#methods","title":"Methods","text":""},{"location":"module_bit.html#individual-bit-operations","title":"Individual bit operations","text":"<pre><code>template &lt;class T&gt; constexpr bool get(T value, std::size_t bit) noexcept;\n</code></pre> <p>Returns the state of the <code>bit</code> in an integer <code>value</code>.</p> <p>Note: This and all consequent functions assume <code>bit &lt; sizeof(T) * CHAR_BIT</code>, otherwise behavior is undefined. This precondition is checked in <code>DEBUG</code>.</p> <pre><code>template &lt;class T&gt; constexpr T   set(T value, std::size_t bit) noexcept;\ntemplate &lt;class T&gt; constexpr T clear(T value, std::size_t bit) noexcept;\ntemplate &lt;class T&gt; constexpr T  flip(T value, std::size_t bit) noexcept;\n</code></pre> <p>Sets / clears / flips the <code>bit</code> in an integer <code>value</code> and returns the result.</p>"},{"location":"module_bit.html#group-bit-operations","title":"Group bit operations","text":"<pre><code>template &lt;class T&gt; constexpr T lshift(T value, std::size_t shift) noexcept;\ntemplate &lt;class T&gt; constexpr T rshift(T value, std::size_t shift) noexcept;\n</code></pre> <p>Shifts bits in an integer <code>value</code> left / right by a given <code>shift</code>, shifted from bits are zero-filled.</p> <p>Functionally identical to operators <code>&lt;&lt;</code> and <code>&gt;&gt;</code>, but with a proper handling for negative signed integers. In the standard shifting negative numbers is considered UB, in practice every single compiler implements signed bit-shift as <code>(signed)((unsigned)value &lt;&lt; shift)</code> while implicitly assuming <code>value &gt; 0</code> since negatives are UB. This implicit assumption can lead to incorrectly generated code since branches with <code>value &lt; 0</code> will be eliminated as \"dead code\" simply through the virtue of being near a <code>value &lt;&lt; shift</code> statement. These functions perform the cast explicitly leading to the exact same performance &amp; behavior but safer.</p> <p>Note: This and all consequent functions assume <code>shift &lt; sizeof(T) * CHAR_BIT</code>, otherwise behavior is undefined. This precondition is checked in <code>DEBUG</code>.</p> <pre><code>template &lt;class T&gt; constexpr T rotl(T value, std::size_t shift) noexcept;\ntemplate &lt;class T&gt; constexpr T rotr(T value, std::size_t shift) noexcept;\n</code></pre> <p>Shifts bits in an integer <code>value</code> left / right by a given <code>shift</code>, shifted from bits wrap around.</p> <p>This operation usually compiles down to a single instruction and is often used in computational code.</p>"},{"location":"module_bit.html#utils","title":"Utils","text":"<pre><code>constexpr std::size_t byte_size = CHAR_BIT;\n</code></pre> <p>Convenience constant, exists purely to reduce the usage of macros. Evaluates to <code>8</code> on most sane platforms.</p> <pre><code>template &lt;class T&gt; constexpr std::size_t size_of;\n</code></pre> <p>Convenience constant. Evaluates to the size of <code>T</code> in bits, which equals <code>sizeof(T) * byte_size</code>.</p> <pre><code>template &lt;class T&gt; constexpr std::size_t width(T value) noexcept;\n</code></pre> <p>Returns the number of significant bits in an integer.</p> <p>Note: Unsigned integers have <code>1 + floor(log2(value))</code> significant bits.</p> <pre><code>template &lt;class T&gt; constexpr std::size_t popcount(T value) noexcept;\n</code></pre> <p>Returns the number of set bits in an integer.</p>"},{"location":"module_bit.html#enum-bitflags","title":"Enum bitflags","text":"<pre><code>constexpr Flags::Flags(                       E      flag) noexcept;\nconstexpr Flags::Flags(std::initializer_list&lt;E&gt; flag_list) noexcept;\n</code></pre> <p>Constructs bitflag object from one or several enum values.</p> <pre><code>constexpr operator bool() const noexcept;\n</code></pre> <p>Converts to <code>false</code> if underlying bitflag value is <code>0</code>, otherwise <code>true</code>.</p> <pre><code>constexpr E get() const noexcept;\n</code></pre> <p>Returns the underlying <code>enum class</code> value.</p> <pre><code>constexpr bool Flags::contains(E      flag) const noexcept;\nconstexpr bool Flags::contains(Flags other) const noexcept;\n</code></pre> <p>Returns whether bitflag object contains a specific flag(s).</p> <pre><code>constexpr Flags&amp;    add(E      flag) noexcept;\nconstexpr Flags&amp;    add(Flags other) noexcept;\nconstexpr Flags&amp; remove(E      flag) noexcept;\nconstexpr Flags&amp; remove(Flags other) noexcept;\n</code></pre> <p>Adds / removes flag(s) from a bitflag object.</p> <p>Several adds / removes can be chained in a single statement.</p> <pre><code>constexpr Flags operator~() const noexcept;\n\nconstexpr Flags operator|(Flags other) const noexcept;\nconstexpr Flags operator&amp;(Flags other) const noexcept;\n\nconstexpr Flags&amp; operator|=(Flags other) noexcept;\nconstexpr Flags&amp; operator&amp;=(Flags other) noexcept;\n</code></pre> <p>Bitwise operators used for classic bitflag semantics.</p> <pre><code>constexpr bool operator==(Flags other) noexcept;\nconstexpr bool operator!=(Flags other) noexcept;\nconstexpr bool operator&lt;=(Flags other) noexcept;\nconstexpr bool operator&gt;=(Flags other) noexcept;\nconstexpr bool operator&lt; (Flags other) noexcept;\nconstexpr bool operator&gt; (Flags other) noexcept;\n</code></pre> <p>Comparison operators, effectively same as comparing the underlying value.</p>"},{"location":"module_bit.html#examples","title":"Examples","text":""},{"location":"module_bit.html#working-with-individual-bits","title":"Working with individual bits","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\nconstexpr std::uint8_t x = 19; // 19 ~ 00010011\n// human-readable notation is big-endian, which means bits are indexed right-to-left\n\n// Read bits\nstatic_assert(bit::get(x, 0) == 1);\nstatic_assert(bit::get(x, 1) == 1);\nstatic_assert(bit::get(x, 2) == 0);\nstatic_assert(bit::get(x, 3) == 0);\nstatic_assert(bit::get(x, 4) == 1);\nstatic_assert(bit::get(x, 5) == 0);\nstatic_assert(bit::get(x, 6) == 0);\nstatic_assert(bit::get(x, 7) == 0);\n\n// Modify bits\nstatic_assert(bit::set(  x, 2) == 23); // 23 ~ 00010111\nstatic_assert(bit::clear(x, 0) == 18); // 18 ~ 00010010\nstatic_assert(bit::flip( x, 1) == 17); // 17 ~ 00010001\n</code></pre>"},{"location":"module_bit.html#general-usage","title":"General usage","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\nconstexpr std::uint8_t x = 19; // 19 ~ 00010011\n\n// Group bit operations\nstatic_assert(bit::rotl(  x, 6) == 196); // 196 ~ 11000100\nstatic_assert(bit::rotr(  x, 1) == 137); // 137 ~ 10001001\nstatic_assert(bit::lshift(x, 6) == 192); // 192 ~ 11000000\nstatic_assert(bit::rshift(x, 1) ==   9); //   9 ~ 00001001\n\n// Utils\nstatic_assert(bit::width(x) == 5); // 00010011 has 5 significant bits\n\nstatic_assert(bit::size_of&lt;std::uint16_t&gt; == 16);\nstatic_assert(bit::size_of&lt;std::uint32_t&gt; == 32);\nstatic_assert(bit::size_of&lt;std::uint64_t&gt; == 64);\n</code></pre>"},{"location":"module_bit.html#using-enum-bitflags","title":"Using enum bitflags","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\n// Bitflag-suitable enum class\nenum class IOMode { IN = 1 &lt;&lt; 0, OUT = 1 &lt;&lt; 1, APP = 1 &lt;&lt; 2 };\n\n// Function taking enum flags\nvoid open_file(bit::Flags&lt;IOMode&gt; flags) {\n    if (flags.contains(IOMode::IN) ) std::cout &lt;&lt; \"  &gt; File opened for reading   \\n\";\n    if (flags.contains(IOMode::OUT)) std::cout &lt;&lt; \"  &gt; File opened for writing   \\n\";\n    if (flags.contains(IOMode::APP)) std::cout &lt;&lt; \"  &gt; File opened for appending \\n\";\n}\n\n// ...\n\nstd::cout &lt;&lt; \"Opening file with OUT:       \\n\";\nopen_file(IOMode::OUT);\n\nstd::cout &lt;&lt; \"Opening file with OUT | APP: \\n\";\nopen_file(bit::Flags{IOMode::OUT, IOMode::APP});\n</code></pre> <p>Output: <pre><code>Opening file with OUT:\n  &gt; File opened for writing\nOpening file with OUT | APP:\n  &gt; File opened for writing\n  &gt; File opened for appending\n</code></pre></p>"},{"location":"module_bit.html#additional-bitflag-examples","title":"Additional bitflag examples","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\n// Bitflag-suitable enum class\nenum class IOMode { IN = 1 &lt;&lt; 0, OUT = 1 &lt;&lt; 1, APP = 1 &lt;&lt; 2 };\n\n// Simple yet flexible API, same thing can be accomplished\n// both with classic bit-wise semantics and with built-in methods.\n// Underneath it's just a strongly typed integer so there is no performance impact\nconstexpr auto flags_1 = bit::Flags{IOMode::OUT, IOMode::APP};\nconstexpr auto flags_2 = bit::Flags(IOMode::OUT) | bit::Flags(IOMode::APP);\nconstexpr auto flags_3 = bit::Flags(IOMode::OUT) | IOMode::APP;\nconstexpr auto flags_4 = bit::Flags(IOMode::OUT).add(IOMode::APP);\nconstexpr auto flags_5 = bit::Flags&lt;IOMode&gt;{}.add(IOMode::OUT).add(IOMode::APP);\n\nstatic_assert(flags_1 == flags_2 &amp;&amp; flags_2 == flags_3 &amp;&amp; flags_3 == flags_4 &amp;&amp; flags_4 == flags_5);\n</code></pre>"},{"location":"module_enum_reflect.html","title":"utl::enum_reflect","text":""},{"location":"module_enum_reflect.html#utlenum_reflect","title":"utl::enum_reflect","text":"<p>&lt;- to README.md</p> <p>&lt;- to implementation.hpp</p> <p>utl::enum_reflect is a lean <code>enum</code> reflection library based around the map-macro.</p> <p>Important</p> <p>When compiling with MSVC use <code>/Zc:preprocessor</code> to enable standard-compliant preprocessor. Default MSVC preprocessor is notoriously non-compliant due to legacy reasons and might not handle macro expansion properly.</p>"},{"location":"module_enum_reflect.html#definitions","title":"Definitions","text":"<pre><code>// Macros\n#define UTL_ENUM_REFLECT(enum_name, ...)\n\n// Reflection\ntemplate &lt;class E&gt; constexpr std::string_view type_name;\ntemplate &lt;class E&gt; constexpr std::size_t      size;\n\ntemplate &lt;class E&gt; constexpr std::array&lt;std::string_view, size&lt;E&gt;&gt;               names;\ntemplate &lt;class E&gt; constexpr std::array&lt;E, size&lt;E&gt;&gt;                              values;\ntemplate &lt;class E&gt; constexpr std::array&lt;std::pair&lt;std::string_view, E&gt;, size&lt;E&gt;&gt; entries;\n\ntemplate &lt;class E&gt; constexpr bool      is_valid(E value) noexcept;\ntemplate &lt;class E&gt; constexpr auto to_underlying(E value) noexcept;\n\ntemplate &lt;class E&gt; constexpr std::string_view   to_string(E value);\ntemplate &lt;class E&gt; constexpr E                from_string(std::string_view str);\n</code></pre>"},{"location":"module_enum_reflect.html#methods","title":"Methods","text":""},{"location":"module_enum_reflect.html#macros","title":"Macros","text":"<pre><code>#define UTL_ENUM_REFLECT(enum_name, ...)\n</code></pre> <p>Registers reflection for the <code>enum</code> / <code>enum class</code> type <code>enum_name</code> with elements <code>...</code>.</p>"},{"location":"module_enum_reflect.html#reflection","title":"Reflection","text":"<pre><code>template &lt;class E&gt; constexpr std::string_view type_name;\n</code></pre> <p>Evaluates to stringified name of <code>E</code> enum.</p> <pre><code>template &lt;class E&gt; constexpr std::size_t size;\n</code></pre> <p>Evaluates to a number of elements in <code>E</code> enum.</p> <pre><code>template &lt;class E&gt; constexpr std::array&lt;std::string_view, size&lt;E&gt;&gt; names;\n</code></pre> <p>Evaluates to an array of stringified element names corresponding to <code>E</code> enum.</p> <pre><code>template &lt;class E&gt; constexpr std::array&lt;E, size&lt;E&gt;&gt; values;\n</code></pre> <p>Evaluates to an array of elements corresponding to <code>E</code> enum.</p> <pre><code>template &lt;class E&gt; constexpr std::array&lt;std::pair&lt;std::string_view, E&gt;, size&lt;E&gt;&gt; entries;\n</code></pre> <p>Evaluates to an array of name-value pairs corresponding to <code>E</code> enum.</p> <pre><code>template &lt;class E&gt; constexpr bool is_valid(E value) noexcept;\n</code></pre> <p>Returns whether enum-typed <code>value</code> is a valid element of <code>E</code> enum. See examples.</p> <pre><code>template &lt;class E&gt; constexpr auto to_underlying(E value) noexcept;\n</code></pre> <p>Equivalent to <code>static_cast&lt;std::underlying_type_t&lt;E&gt;&gt;(value)</code>. In C++23 can be replaced with <code>std::to_underlying()</code>.</p> <p>Note: This particular function is included for convenience and does not require <code>E</code> to be reflected.</p> <pre><code>template &lt;class E&gt; constexpr std::string_view to_string(E value);\n</code></pre> <p>Returns string corresponding to a <code>value</code> from <code>E</code> enum.</p> <p>Throws <code>std::out_of_range</code> if <code>value</code> is not a part of enum.</p> <pre><code>template &lt;class E&gt; constexpr E from_string(std::string_view str);\n</code></pre> <p>Returns value from <code>E</code> enum corresponding to a string <code>str</code>.</p> <p>Throws <code>std::out_of_range</code> if <code>str</code> does not correspond to any element of the enum.</p>"},{"location":"module_enum_reflect.html#examples","title":"Examples","text":""},{"location":"module_enum_reflect.html#reflecting-an-enum","title":"Reflecting an enum","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>// Register enum &amp; reflection\nenum class Side { LEFT = -1, RIGHT = 1, NONE = 0 };\n\nUTL_ENUM_REFLECT(Side, LEFT, RIGHT, NONE);\n\n// Test reflection\nusing namespace utl;\nusing namespace std::string_view_literals;\n\nstatic_assert( enum_reflect::type_name&lt;Side&gt; == \"Side\" );\n\nstatic_assert( enum_reflect::size&lt;Side&gt; == 3 );\n\nstatic_assert( enum_reflect::names&lt;Side&gt;[0] == \"LEFT\"  );\nstatic_assert( enum_reflect::names&lt;Side&gt;[1] == \"RIGHT\" );\nstatic_assert( enum_reflect::names&lt;Side&gt;[2] == \"NONE\"  );\n\nstatic_assert( enum_reflect::values&lt;Side&gt;[0] == Side::LEFT  );\nstatic_assert( enum_reflect::values&lt;Side&gt;[1] == Side::RIGHT );\nstatic_assert( enum_reflect::values&lt;Side&gt;[2] == Side::NONE  );\n\nstatic_assert( enum_reflect::entries&lt;Side&gt;[0]  == std::pair{  \"LEFT\"sv, Side::LEFT  } );\nstatic_assert( enum_reflect::entries&lt;Side&gt;[1]  == std::pair{ \"RIGHT\"sv, Side::RIGHT } );\nstatic_assert( enum_reflect::entries&lt;Side&gt;[2]  == std::pair{  \"NONE\"sv, Side::NONE  } );\n\nstatic_assert( enum_reflect::is_valid(Side{-1}) == true  );\nstatic_assert( enum_reflect::is_valid(Side{ 1}) == true  );\nstatic_assert( enum_reflect::is_valid(Side{ 0}) == true  );\nstatic_assert( enum_reflect::is_valid(Side{ 2}) == false );\n\nstatic_assert( enum_reflect::to_underlying(Side::LEFT ) == -1 );\nstatic_assert( enum_reflect::to_underlying(Side::RIGHT) ==  1 );\nstatic_assert( enum_reflect::to_underlying(Side::NONE ) ==  0 );\n\nstatic_assert( enum_reflect::to_string(Side::LEFT ) == \"LEFT\"  );\nstatic_assert( enum_reflect::to_string(Side::RIGHT) == \"RIGHT\" );\nstatic_assert( enum_reflect::to_string(Side::NONE ) == \"NONE\"  );\n\nstatic_assert( enum_reflect::from_string&lt;Side&gt;(\"LEFT\" ) == Side::LEFT  );\nstatic_assert( enum_reflect::from_string&lt;Side&gt;(\"RIGHT\") == Side::RIGHT );\nstatic_assert( enum_reflect::from_string&lt;Side&gt;(\"NONE\" ) == Side::NONE  );\n</code></pre>"},{"location":"module_integral.html","title":"utl::integral","text":""},{"location":"module_integral.html#utlintegral","title":"utl::integral","text":"<p>&lt;- to README.md</p> <p>&lt;- to implementation.hpp</p> <p>utl::integral module implements various utilities for dealing with integer types. Main features are:</p> <ul> <li>Integer division with different rounding modes</li> <li>Overflow/underflow detection</li> <li>Saturated math</li> <li>Heterogeneous (mathematically correct) integer comparison</li> <li>\"Safe\" integer casts</li> <li>Fixed-size &amp; <code>std::size_t</code> literals</li> </ul> <p>Such functionality is often useful in <code>constexpr</code> context when dealing with optimizations such as compile-time creation of bit-masks, bit-buffers, computation of different alignments, coefficients and etc. Also convenience.</p> <p>Note</p> <p>Significant part of this module gets added into the standard library with C++20 <code>&lt;bits&gt;</code> and <code>&lt;utility&gt;</code>, saturated math ships with C++26 <code>&lt;numeric&gt;</code>. All such functions provide the same API as their <code>std::</code> variants to allow seamless future transition.</p>"},{"location":"module_integral.html#definitions","title":"Definitions","text":"<pre><code>// Rounding integer division\ntemplate &lt;class T&gt; constexpr T div_floor(T dividend, T divisor) noexcept;\ntemplate &lt;class T&gt; constexpr T div_ceil (T dividend, T divisor) noexcept;\ntemplate &lt;class T&gt; constexpr T div_down (T dividend, T divisor) noexcept;\ntemplate &lt;class T&gt; constexpr T div_up   (T dividend, T divisor) noexcept;\n\n// Saturated math\ntemplate &lt;class T&gt; constexpr bool add_overflows(T lhs, T rhs) noexcept;\ntemplate &lt;class T&gt; constexpr bool sub_overflows(T lhs, T rhs) noexcept;\ntemplate &lt;class T&gt; constexpr bool mul_overflows(T lhs, T rhs) noexcept;\ntemplate &lt;class T&gt; constexpr bool div_overflows(T lhs, T rhs) noexcept;\n\ntemplate &lt;class T&gt; constexpr T add_sat(T lhs, T rhs) noexcept;\ntemplate &lt;class T&gt; constexpr T sub_sat(T lhs, T rhs) noexcept;\ntemplate &lt;class T&gt; constexpr T mul_sat(T lhs, T rhs) noexcept;\ntemplate &lt;class T&gt; constexpr T div_sat(T lhs, T rhs) noexcept;\n\n// Heterogeneous integer comparison\ntemplate &lt;class T1, class T2&gt; constexpr bool cmp_equal        (T1 lhs, T2 rhs) noexcept;\ntemplate &lt;class T1, class T2&gt; constexpr bool cmp_not_equal    (T1 lhs, T2 rhs) noexcept;\ntemplate &lt;class T1, class T2&gt; constexpr bool cmp_less         (T1 lhs, T2 rhs) noexcept;\ntemplate &lt;class T1, class T2&gt; constexpr bool cmp_greater      (T1 lhs, T2 rhs) noexcept;\ntemplate &lt;class T1, class T2&gt; constexpr bool cmp_less_equal   (T1 lhs, T2 rhs) noexcept;\ntemplate &lt;class T1, class T2&gt; constexpr bool cmp_greater_equal(T1 lhs, T2 rhs) noexcept;\n\ntemplate &lt;class To, class From&gt; constexpr bool in_range(From value) noexcept;\n\n// Casts\ntemplate &lt;class To, class From&gt; constexpr To narrow_cast  (From value);\ntemplate &lt;class To, class From&gt; constexpr To saturate_cast(From value) noexcept;\n\ntemplate &lt;class T&gt; constexpr auto to_signed  (T value);\ntemplate &lt;class T&gt; constexpr auto to_unsigned(T value);\n\n// Integer literals\nnamespace literals {\n    constexpr std::int8_t    operator\"\"_i8  (unsigned long long v) noexcept;\n    constexpr std::uint8_t   operator\"\"_u8  (unsigned long long v) noexcept;\n    constexpr std::int16_t   operator\"\"_i16 (unsigned long long v) noexcept;\n    constexpr std::uint16_t  operator\"\"_u16 (unsigned long long v) noexcept;\n    constexpr std::int32_t   operator\"\"_i32 (unsigned long long v) noexcept;\n    constexpr std::uint32_t  operator\"\"_u32 (unsigned long long v) noexcept;\n    constexpr std::int64_t   operator\"\"_i64 (unsigned long long v) noexcept;\n    constexpr std::uint64_t  operator\"\"_u64 (unsigned long long v) noexcept;\n    constexpr std::size_t    operator\"\"_sz  (unsigned long long v) noexcept;\n    constexpr std::ptrdiff_t operator\"\"_ptrd(unsigned long long v) noexcept;\n}\n</code></pre>"},{"location":"module_integral.html#methods","title":"Methods","text":""},{"location":"module_integral.html#rounding-integer-division","title":"Rounding integer division","text":"<pre><code>template &lt;class T&gt; constexpr T div_floor(T dividend, T divisor) noexcept;\ntemplate &lt;class T&gt; constexpr T div_ceil (T dividend, T divisor) noexcept;\ntemplate &lt;class T&gt; constexpr T div_down (T dividend, T divisor) noexcept;\ntemplate &lt;class T&gt; constexpr T div_up   (T dividend, T divisor) noexcept;\n</code></pre> <p>Returns the result of integer division with a given rounding mode.</p> Function Rounding mode <code>div_floor()</code> Towards larger value <code>div_ceil()</code> Towards smaller value <code>div_down()</code> Towards <code>0</code> <code>div_up()</code> Away from <code>0</code> <p>Note: There is a lot of partial or even blatantly erroneous implementations for this published online, the task is surprisingly tricky. Here signed values are properly handled and overflow behaves as it should.</p>"},{"location":"module_integral.html#saturated-math","title":"Saturated math","text":"<pre><code>template &lt;class T&gt; constexpr bool add_overflows(T lhs, T rhs) noexcept;\ntemplate &lt;class T&gt; constexpr bool sub_overflows(T lhs, T rhs) noexcept;\ntemplate &lt;class T&gt; constexpr bool mul_overflows(T lhs, T rhs) noexcept;\ntemplate &lt;class T&gt; constexpr bool div_overflows(T lhs, T rhs) noexcept;\n</code></pre> <p>Returns whether operator  <code>+</code>/<code>-</code>/<code>*</code>/<code>/</code> would overflow/underflow when applied to <code>lhs</code>, <code>rhs</code>.</p> <pre><code>template &lt;class T&gt; constexpr T add_sat(T lhs, T rhs) noexcept;\ntemplate &lt;class T&gt; constexpr T sub_sat(T lhs, T rhs) noexcept;\ntemplate &lt;class T&gt; constexpr T mul_sat(T lhs, T rhs) noexcept;\ntemplate &lt;class T&gt; constexpr T div_sat(T lhs, T rhs) noexcept;\n</code></pre> <p>Returns the result of <code>+</code>/<code>-</code>/<code>*</code>/<code>/</code> computed in saturated arithmetic, which means instead of overflowing operations get clamped to a min/max value.</p> <p>Note: This gets standardized in C++26 as a part of <code>&lt;numeric&gt;</code> header.</p>"},{"location":"module_integral.html#heterogeneous-integer-comparison","title":"Heterogeneous integer comparison","text":"<pre><code>template &lt;class T1, class T2&gt; constexpr bool cmp_equal        (T1 lhs, T2 rhs) noexcept;\ntemplate &lt;class T1, class T2&gt; constexpr bool cmp_not_equal    (T1 lhs, T2 rhs) noexcept;\ntemplate &lt;class T1, class T2&gt; constexpr bool cmp_less         (T1 lhs, T2 rhs) noexcept;\ntemplate &lt;class T1, class T2&gt; constexpr bool cmp_greater      (T1 lhs, T2 rhs) noexcept;\ntemplate &lt;class T1, class T2&gt; constexpr bool cmp_less_equal   (T1 lhs, T2 rhs) noexcept;\ntemplate &lt;class T1, class T2&gt; constexpr bool cmp_greater_equal(T1 lhs, T2 rhs) noexcept;\n</code></pre> <p>Functions that compare the values of two integers <code>lhs</code> and <code>rhs</code>. Unlike regular comparison operators, comparison is always mathematically correct for arbitrary types of <code>lhs</code> and <code>rhs</code>.</p> <p>For example, <code>-1 &gt; 0u</code> is <code>true</code> due to non-value-preserving integer conversion, while <code>cmp_greater(-1, 0u)</code> is <code>false</code> (as it should be mathematically).</p> <p>Note: This gets standardized in C++26 as intcmp.</p> <pre><code>template &lt;class To, class From&gt; constexpr bool in_range(From value) noexcept;\n</code></pre> <p>Returns whether <code>value</code> is in <code>[std::numeric_limits&lt;To&gt;::min(), std::numeric_limits&lt;To&gt;::max()]</code> range using heterogeneous comparison.</p>"},{"location":"module_integral.html#casts","title":"Casts","text":"<pre><code>template &lt;class To, class From&gt; constexpr To narrow_cast(From value);\n</code></pre> <p>Integer-to-integer cast that throws <code>std::domain_error</code> if conversion would overflow/underflow the result.</p> <pre><code>template &lt;class To, class From&gt; constexpr To saturate_cast(From value) noexcept;\n</code></pre> <p>Integer-to-integer cast that uses saturated math. If <code>value</code> lies outside of <code>[std::numeric_limits&lt;To&gt;::min(), std::numeric_limits&lt;To&gt;::max()]</code> range, it gets clamped to the appropriate side of that range.</p> <pre><code>template &lt;class T&gt; constexpr auto to_signed  (T value);\ntemplate &lt;class T&gt; constexpr auto to_unsigned(T value);\n</code></pre> <p>Cast integer to a corresponding signed/unsigned type using <code>narrow_cast()</code>.</p>"},{"location":"module_integral.html#integer-literals","title":"Integer literals","text":"<pre><code>namespace literals {\n    constexpr std::int8_t    operator\"\"_i8  (unsigned long long v) noexcept;\n    constexpr std::uint8_t   operator\"\"_u8  (unsigned long long v) noexcept;\n    constexpr std::int16_t   operator\"\"_i16 (unsigned long long v) noexcept;\n    constexpr std::uint16_t  operator\"\"_u16 (unsigned long long v) noexcept;\n    constexpr std::int32_t   operator\"\"_i32 (unsigned long long v) noexcept;\n    constexpr std::uint32_t  operator\"\"_u32 (unsigned long long v) noexcept;\n    constexpr std::int64_t   operator\"\"_i64 (unsigned long long v) noexcept;\n    constexpr std::uint64_t  operator\"\"_u64 (unsigned long long v) noexcept;\n    constexpr std::size_t    operator\"\"_sz  (unsigned long long v) noexcept;\n    constexpr std::ptrdiff_t operator\"\"_ptrd(unsigned long long v) noexcept;\n}\n</code></pre> <p>Literal suffixes for several integer types not included in <code>std</code>.</p> <p>Note 1: Literals always evaluate to a valid value, if <code>v</code> doesn't convert to a valid value internal cast throws <code>std::domain_error</code> at <code>constexpr</code>, making it a compilation error.</p> <p>Note 2: Literal for <code>std::size_t</code> gets standardized in C++23 as a <code>zu</code> suffix. </p>"},{"location":"module_integral.html#examples","title":"Examples","text":""},{"location":"module_integral.html#integer-division","title":"Integer division","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\nstatic_assert( integral::div_floor( 7, 5) == 1 ); // round to smaller\nstatic_assert( integral::div_ceil ( 7, 5) == 2 ); // round to larger\nstatic_assert( integral::div_down ( 7, 5) == 1 ); // round to 0\nstatic_assert( integral::div_up   ( 7, 5) == 2 ); // round away from 0\n\nstatic_assert( integral::div_floor(-7, 5) == -2 ); // round to smaller\nstatic_assert( integral::div_ceil (-7, 5) == -1 ); // round to larger\nstatic_assert( integral::div_down (-7, 5) == -1 ); // round to 0\nstatic_assert( integral::div_up   (-7, 5) == -2 ); // round away from 0\n</code></pre>"},{"location":"module_integral.html#saturated-math_1","title":"Saturated math","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\nusing namespace integral::literals;\n\n// Helper functions to avoid ugly casting\ntemplate &lt;class T&gt; constexpr T add(T lhs, T rhs) noexcept { return lhs + rhs; }\ntemplate &lt;class T&gt; constexpr T sub(T lhs, T rhs) noexcept { return lhs - rhs; }\n\n// std::uint8_t has range [0, 255]\nstatic_assert(               add&lt;std::uint8_t&gt;(255, 15) ==  14 ); // overflow\nstatic_assert( integral::add_sat&lt;std::uint8_t&gt;(255, 15) == 255 ); // result gets clamped to max\n\n// std::int8_t has range [-128, 127]\nstatic_assert(               sub&lt;std::int8_t&gt;(-128, 14) ==  114 ); // underflow\n// if we used 'int' instead of 'std::int8_t' this could even be UB due to underflow during signed\n// arithmetic operation, for smaller types it's underflow during cast which is defined to wrap\nstatic_assert( integral::sub_sat&lt;std::int8_t&gt;(-128, 14) == -128 ); // result gets clamped to min\n\n// Saturated cast\nstatic_assert( integral::saturate_cast&lt;std::uint8_t&gt;(  17) ==  17 ); // regular cast\nstatic_assert( integral::saturate_cast&lt;std::uint8_t&gt;(1753) == 255 ); // value clamped to max\nstatic_assert( integral::saturate_cast&lt;std::uint8_t&gt;(-143) ==   0 ); // value clamped to min\n</code></pre>"},{"location":"module_integral.html#heterogeneous-comparison","title":"Heterogeneous comparison","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\n// static_assert( std::size_t(15) &lt; int(-7) == true );\n// evaluates to 'true' due to implicit conversion, mathematically incorrect result,\n// sensible compilers will issue a warning\n\nstatic_assert( integral::cmp_less(std::size_t(15), int(-7)) == false );\n// evaluates to 'false', mathematically correct result\n</code></pre>"},{"location":"module_integral.html#narrow-cast","title":"Narrow cast","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>try {\n    using namespace utl;\n\n    // Narrow cast\n    [[maybe_unused]] char c1 =           static_cast&lt;char&gt;(  34); // this is fine, returns 34\n    [[maybe_unused]] char c2 = integral::narrow_cast&lt;char&gt;(  34); // this is fine, returns 34\n    [[maybe_unused]] char c3 =           static_cast&lt;char&gt;(1753); // silently overflows, returns -39\n    [[maybe_unused]] char c4 = integral::narrow_cast&lt;char&gt;(1753); // throws 'std::domain_error'\n\n} catch (std::domain_error &amp;e) { \n    std::cerr &lt;&lt; \"ERROR: Caught exception:\\n\\n\" &lt;&lt; e.what();\n}\n</code></pre> <p>Output:</p> <pre><code>ERROR: Caught exception:\n\nnarrow_cast() overflows the result.\n</code></pre>"},{"location":"module_integral.html#sign-conversion","title":"Sign conversion","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>try {\n    constexpr int N = -14;\n\n    // for (std::size_t i = 0; i &lt; N; ++i) std::cout &lt;&lt; i;\n    // compiler warns about signed/unsigned comparison, doesn't compile with -Werror\n\n    // for (std::size_t i = 0; i &lt; static_cast&lt;std::size_t&gt;(N); ++i) std::cout &lt;&lt; i;\n    // casts 'N' to '18446744073709551602' since we forgot to check for negative 'N'\n\n    for (std::size_t i = 0; i &lt; utl::integral::to_unsigned(N); ++i) std::cout &lt;&lt; i;\n    // this is good, comparison is unsigned/unsigned and incorrect 'N' will cause an exception\n\n} catch (std::domain_error &amp;e) {\n    std::cerr &lt;&lt; \"ERROR: Caught exception:\\n\\n\" &lt;&lt; e.what();\n}\n</code></pre> <p>Output:</p> <pre><code>ERROR: Caught exception:\n\nnarrow_cast() overflows the result.\n</code></pre>"},{"location":"module_integral.html#integral-literals","title":"Integral literals","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl::integral::literals;\n\n// constexpr auto x = 129_i8;\n// won't compile, std::int8_t has range [-128, 127]\n\nconstexpr auto x = 124_i8;\n// this is fine, 'x' has type 'std::int8_t'\n\n// constexpr auto x = -17_i8;\n// be wary of this, C++ has no concept of signed literals and treats it as an unary minus\n// applied to 'std::int8_t', which triggers integer promotion and returns an 'int'\n\nstatic_assert(sizeof(x) == 1);\n</code></pre>"},{"location":"module_json.html","title":"utl::json","text":""},{"location":"module_json.html#utljson","title":"utl::json","text":"<p>&lt;- to README.md</p> <p>&lt;- to implementation.hpp</p> <p>utl::json module aims to provide an intuitive JSON manipulation API similar to nlohmann_json while being a bit more lightweight and providing better performance. Key features are:</p> <ul> <li>Simple integration (single header, less than <code>1k</code> lines of code)</li> <li>Intuitive API</li> <li>Decent performance</li> <li>Nice error messages</li> <li>Recursive class reflection</li> <li>Doesn't introduce any invasive macros or operators</li> <li>Objects support transparent comparators (which means <code>std::string_view</code>, <code>const char*</code> and etc. can be used for lookup)</li> <li>All JSON types map to standard library containers (<code>std::map</code>, <code>std::vector</code>, etc.), no need to learn custom APIs</li> <li>Assignment &amp; reflection support custom container types</li> </ul> <p>Note</p> <p>Despite rather competitive performance, considerably faster parsing can be achieved with custom formatters, SIMD and unordered key optimizations (see simdjson, Glaze, RapidJSON  and yyjson), this, however often comes at the expense of user convenience (like with RapidJSON) or features (simdjson is parser-only, yyjson is <code>C</code> and doesn't include reflection, Glaze has it all, but requires C++23).</p>"},{"location":"module_json.html#feature-support","title":"Feature Support","text":"Feature Implementation Notes Parsing \u2714 Serialization \u2714 JSON Formatting \u2714 JSON Validation \u2714 Almost complete\u00b9 validation with proper error messages through exceptions Unicode Support \u2714 Supports UTF-8 Control Character Escape Sequences \u2714 Unicode Escape Sequences \u2714 Full support including UTF-16 surrogate pairs Trait-based Type Conversions \u2714 Structure Reflection \u2714 Recursive reflection including nested types and containers\u00b2 Compile-time JSON Schema \u2718 Outside the project scope, can be emulated with reflection Lazy Node Loading \u2718 Outside the project scope"},{"location":"module_json.html#definitions","title":"Definitions","text":"<pre><code>// JSON Node\nenum class Format { PRETTY, MINIMIZED };\n\nclass Node {\n    // - Member Types -\n    using object_type = std::map&lt;std::string, Node, std::less&lt;&gt;&gt;;\n    using array_type  = std::vector&lt;Node&gt;;\n    using string_type = std::string;\n    using number_type = double;\n    using bool_type   = bool;\n    using null_type   = class{};\n\n    // - Getters -\n    template &lt;class T&gt;       T&amp; get();\n    template &lt;class T&gt; const T&amp; get() const;\n\n    object_type&amp; get_object();\n    array_type &amp; get_array();\n    string_type&amp; get_string();\n    number_type&amp; get_number();\n    bool_type  &amp; get_bool();\n    null_type  &amp; get_null();\n\n    const object_type&amp; get_object() const;\n    const array_type &amp; get_array()  const;\n    const string_type&amp; get_string() const;\n    const number_type&amp; get_number() const;\n    const bool_type  &amp; get_bool()   const;\n    const null_type  &amp; get_null()   const;\n\n    template &lt;class T&gt; bool is() const;\n\n    bool is_object() const;\n    bool is_array()  const;\n    bool is_string() const;\n    bool is_number() const;\n    bool is_bool()   const;\n    bool is_null()   const;\n\n    template &lt;class T&gt;       T* get_if();\n    template &lt;class T&gt; const T* get_if() const;\n\n    // - Object methods -\n    Node      &amp; operator[](std::string_view key);\n    const Node&amp; operator[](std::string_view key) const;\n    Node      &amp;         at(std::string_view key);\n    const Node&amp;         at(std::string_view key) const;\n\n    bool              contains(std::string_view key) const;\n    template&lt;class T&gt; value_or(std::string_view key, const T &amp;else_value);\n\n    // - Array methods -\n    Node      &amp; operator[](std::size_t pos);\n    const Node&amp; operator[](std::size_t pos) const;\n    Node      &amp;         at(std::size_t pos);\n    const Node&amp;         at(std::size_t pos) const;\n\n    void push_back(const Node&amp;  node);\n    void push_back(      Node&amp;&amp; node);\n\n    // - Assignment -\n    Node&amp; operator=(const Node&amp;) = default;\n    Node&amp; operator=(Node&amp;&amp;)      = default;\n\n    template &lt;class T&gt; Node&amp; operator=(const T&amp; value); // type-trait based conversion\n\n    // - Constructors -\n    Node()            = default;\n    Node(const Node&amp;) = default;\n    Node(Node&amp;&amp;)      = default;\n\n    template &lt;class T&gt; Node(const T&amp; value); // type-trait based conversion\n\n    // Serializing\n    std::string          to_string(                           Format format = Format::PRETTY) const;\n    void                 to_file(const std::string&amp; filepath, Format format = Format::PRETTY) const;\n    template &lt;class T&gt; T to_struct()                                                          const;\n};\n\n// Typedefs\nusing Object = Node::object_type;\nusing Array  = Node::array_type;\nusing String = Node::string_type;\nusing Number = Node::number_type;\nusing Bool   = Node::bool_type;\nusing Null   = Node::null_type;\n\n// Parsing\nNode                    from_string(const std::string&amp; chars   , unsigned int recursion_limit = 100);\nNode                    from_file  (const std::string&amp; filepath, unsigned int recursion_limit = 100);\ntemplate &lt;class T&gt; Node from_struct(const           T&amp; value   );\n\nNode literals::operator\"\"_utl_json(const char* c_str, std::size_t c_str_size);\n\n// Reflection\n#define UTL_JSON_REFLECT(struct_name, ...)\n\ntemplate &lt;class T&gt; constexpr bool is_reflected_struct;\n</code></pre>"},{"location":"module_json.html#methods","title":"Methods","text":""},{"location":"module_json.html#node-class","title":"<code>Node</code> Class","text":""},{"location":"module_json.html#member-types","title":"Member types","text":"<pre><code>using object_type = std::map&lt;std::string, Node, std::less&lt;&gt;&gt;;\nusing array_type  = std::vector&lt;Node&gt;;\nusing string_type = std::string;\nusing number_type = double;\nusing bool_type   = bool;\nusing null_type   = class{};\n</code></pre> <p>Definitions of the types, corresponding to all possible JSON values according to ECMA-404 specification: objects, arrays, strings, numbers, booleans and null.</p>"},{"location":"module_json.html#getters","title":"Getters","text":"<pre><code>template &lt;class T&gt;       T&amp; get();\ntemplate &lt;class T&gt; const T&amp; get() const;\n</code></pre> <p>If JSON node holds the value of a type <code>T</code>, returns a reference to the value, otherwise, throws std::bad_variant_access.</p> <p>Note: Similar to std::get.</p> <pre><code>object_type&amp; get_object();\narray_type &amp; get_array();\nstring_type&amp; get_string();\nnumber_type&amp; get_number();\nbool_type  &amp; get_bool();\nnull_type  &amp; get_null();\n\nconst object_type&amp; get_object() const;\nconst array_type &amp; get_array()  const;\nconst string_type&amp; get_string() const;\nconst number_type&amp; get_number() const;\nconst bool_type  &amp; get_bool()   const;\nconst null_type  &amp; get_null()   const;\n</code></pre> <p>Shortcut versions of <code>T&amp; get&lt;T&gt;()</code> for all possible value types.</p> <pre><code>template &lt;class T&gt; bool is() const;\n</code></pre> <p>Returns whether JSON node contains a value of a type <code>T</code>.</p> <p>Note: Similar to std::holds_alternative.</p> <pre><code>bool is_object() const;\nbool is_array()  const;\nbool is_string() const;\nbool is_number() const;\nbool is_bool()   const;\nbool is_null()   const;\n</code></pre> <p>Shortcut versions of <code>T&amp; is&lt;T&gt;()</code> for all possible value types.</p> <pre><code>template &lt;class T&gt;       T* get_if();\ntemplate &lt;class T&gt; const T* get_if() const;\n</code></pre> <p>Returns a <code>T*</code> pointer to the value stored at the JSON node, if stored value has a different type than <code>T</code>, returns nullptr.</p> <p>Note: Similar to std::get_if.</p>"},{"location":"module_json.html#object-methods","title":"Object methods","text":"<p>Important</p> <p>Object methods can only be called for nodes that contain an object, incorrect node type will cause methods below to throw an exception.</p> <pre><code>Node      &amp; operator[](std::string_view key);\nconst Node&amp; operator[](std::string_view key) const;\n</code></pre> <p>Returns a reference to the node corresponding to a given <code>key</code> in the JSON object, performs an insertion if such key does not already exist.</p> <p>Note: If current node is <code>null_type</code> overload (1) will convert it to <code>object_type</code> and perform an insertion. This allows for a more natural syntax.</p> <pre><code>Node      &amp; at(std::string_view key);\nconst Node&amp; at(std::string_view key) const;\n</code></pre> <p>Returns a reference to the node corresponding to a given <code>key</code> in the JSON object, throws an exception if such key does not exist. </p> <pre><code>bool contains(std::string_view key) const;\n</code></pre> <p>Returns whether JSON object node contains an entry with given <code>key</code>.</p> <pre><code>template&lt;class T&gt; value_or(std::string_view key, const T &amp;else_value);\n</code></pre> <p>Returns value stored at given <code>key</code> in the JSON object, if no such key can be found returns <code>else_value</code>.</p> <p>Note: Logically equivalent to <code>object.contains(key) ? object.at(key).get&lt;T&gt;() : else_value</code>, but faster.</p>"},{"location":"module_json.html#array-methods","title":"Array methods","text":"<p>Important</p> <p>Array methods can only be called for nodes that contain an array, incorrect node type will cause methods below to throw an exception.</p> <pre><code>Node      &amp; operator[](std::size_t pos);\nconst Node&amp; operator[](std::size_t pos) const;\n</code></pre> <p>Returns a reference to the node at given <code>pos</code>. </p> <pre><code>Node      &amp;         at(std::size_t pos);\nconst Node&amp;         at(std::size_t pos) const;\n</code></pre> <p>Returns a reference to the node at given <code>pos</code>, throws an exception if index is out of bounds.</p> <pre><code>void push_back(const Node&amp;  node);\nvoid push_back(      Node&amp;&amp; node);\n</code></pre> <p>Inserts a new node at the end of JSON array.</p> <p>Note: If current node is <code>null_type</code> the method will convert it to <code>array_type</code> and perform an insertion. This allows for a more natural syntax.</p>"},{"location":"module_json.html#assignment-constructors","title":"Assignment &amp; Constructors","text":"<pre><code>template &lt;class T&gt; Node&amp; operator=(const T&amp; value);\ntemplate &lt;class T&gt; Node(const T&amp; value);\n</code></pre> <p>Converting assignment &amp; constructors. Tries to convert <code>T</code> to one of the possible JSON types based on <code>T</code> traits, conversions and provided methods. If no such conversion is possible, SFINAE rejects the overload.</p>"},{"location":"module_json.html#serializing","title":"Serializing","text":"<pre><code>std::string to_string(Format format = Format::PRETTY) const;\n</code></pre> <p>Serializes JSON node to a string using a given <code>format</code>.</p> <pre><code>void to_file(const std::string&amp; filepath, Format format = Format::PRETTY) const;\n</code></pre> <p>Serializes JSON node to the file at <code>filepath</code> using a given <code>format</code>.</p> <p>Note: Missing directories from <code>filepath</code> will be created automatically.</p> <pre><code>template &lt;class T&gt; T to_struct() const;\n</code></pre> <p>Serializes JSON node to the structure / class object of type <code>T</code>.</p> <p>Type <code>T</code> must be reflected with <code>UTL_JSON_REFLECT()</code> macro, otherwise compilation fails with a proper assertion.</p>"},{"location":"module_json.html#parsing","title":"Parsing","text":"<pre><code>Node from_string(const std::string&amp; buffer, unsigned int recursion_limit = 100);\n</code></pre> <p>Parses JSON from a given string <code>buffer</code>.</p> <p>Note: JSON parsers need recursion depth limit to prevent malicious inputs (such as 100'000+ nested object opening braces) from causing stack overflows, instead we get a controllable <code>std::runtime_error</code>.</p> <pre><code>Node from_file(const std::string&amp; filepath, unsigned int recursion_limit = 100);\n</code></pre> <p>Parses JSON from the file at <code>filepath</code>.</p> <pre><code>template &lt;class T&gt; Node from_struct(const T&amp; value);\n</code></pre> <p>Parses JSON from structure / class object <code>value</code>.</p> <p>Type <code>T</code> must be reflected with <code>UTL_JSON_REFLECT()</code> macro, otherwise compilation fails with a proper assertion.</p> <pre><code>Node literals::operator\"\"_utl_json(const char* c_str, std::size_t c_str_size);\n</code></pre> <p><code>json::Node</code> custom literals.</p>"},{"location":"module_json.html#typedefs","title":"Typedefs","text":"<pre><code>using Object = Node::object_type;\nusing Array  = Node::array_type;\nusing String = Node::string_type;\nusing Number = Node::number_type;\nusing Bool   = Node::bool_type;\nusing Null   = Node::null_type;\n</code></pre> <p>Shorter typedefs for all existing JSON value types.</p>"},{"location":"module_json.html#reflection","title":"Reflection","text":"<pre><code>#define UTL_JSON_REFLECT(struct_name, ...)\n</code></pre> <p>Reflects structure / class <code>struct_name</code> with member variables <code>...</code>.</p> <p>Declaring this macro defines methods <code>Node::to_struct&lt;struct_name&gt;()</code> and <code>from_struct(const struct_name&amp;)</code> for parsing and serialization.</p> <p>Note 1: Reflection supports nested classes, each class should be reflected with a macro and <code>to_struct()</code> / <code>from_struct()</code> will call each other recursively whenever appropriate. Containers of reflected classes are also supported with any level of nesting. See examples.</p> <p>Note 2: Reflection does not impose any strict limitations on member variable types, it uses the same set of type traits as other methods to deduce appropriate conversions. It is expected however, that array-like member variables should support <code>.resize()</code> (std::vector and std::list satisfy that) or provide an API similar to std::array. For object-like types it is expected that new elements can be inserted with <code>operator[]</code> (std::map and std::unordered_map satisfy that).</p> <pre><code>template &lt;class T&gt; constexpr bool is_reflected_struct;\n</code></pre> <p>Evaluates to <code>true</code> if <code>T</code> was reflected with <code>UTL_JSON_REFLECT()</code>, <code>false</code> otherwise.</p>"},{"location":"module_json.html#examples","title":"Examples","text":""},{"location":"module_json.html#parseserialize-json","title":"Parse/serialize JSON","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\n// Serialize JSON\njson::Node config;\n\nconfig[\"auxiliary_info\"]       = true;\nconfig[\"date\"]                 = \"2024.04.02\";\nconfig[\"options\"][\"grid_size\"] = 120;\nconfig[\"options\"][\"phi_order\"] = 5;\nconfig[\"scaling_functions\"]    = { \"identity\", \"log10\" };\nconfig[\"time_steps\"]           = 500;\nconfig[\"time_period\"]          = 1.24709e+2;\n\nconfig.to_file(\"config.json\");\n\n// Parse JSON\nconfig = json::from_file(\"config.json\");\n\nstd::cout &lt;&lt; config.to_string();\n</code></pre> <p>Output: <pre><code>{\n    \"auxiliary_info\": true,\n    \"date\": \"2024.04.02\",\n    \"options\": {\n        \"grid_size\": 120,\n        \"phi_order\": 5\n    },\n    \"scaling_functions\": [\n        \"identity\",\n        \"log10\"\n    ],\n    \"time_period\": 124.709,\n    \"time_steps\": 500\n}\n</code></pre></p>"},{"location":"module_json.html#setters-type-conversions","title":"Setters &amp; type conversions","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\njson::Node json;\n\n// Ways to assign a JSON object\njson[\"object\"][\"key_1\"] = 1;\njson[\"object\"][\"key_2\"] = 2;\njson[\"object\"]          =                                     { { \"key_1\", 1 }, { \"key_2\", 2 } };\njson[\"object\"]          =                         json::Object{ { \"key_1\", 1 }, { \"key_2\", 2 } };\njson[\"object\"]          =           std::map&lt;std::string, int&gt;{ { \"key_1\", 1 }, { \"key_2\", 2 } };\njson[\"object\"]          = std::unordered_map&lt;std::string, int&gt;{ { \"key_1\", 1 }, { \"key_2\", 2 } };\n\n// Ways to assign a JSON array\njson[\"array\"] =            { 1, 2, 3 };\njson[\"array\"] = json::Array{ 1, 2, 3 };\njson[\"array\"] = std::vector{ 1, 2, 3 };\njson[\"array\"] =   std::list{ 1, 2, 3 };\njson[\"array\"] =    std::set{ 1, 2, 3 };\n\njson[\"matrix\"] = { { 1, 2 }, { 3, 4 } }; // matrices &amp; tensors are fine too\njson[\"tensor\"] = { { { 1, 2 }, { 3, 4 } }, { { 4, 5 }, { 6, 7 } } };\n\n// Ways to assign a JSON string\njson[\"string\"] =                  \"lorem ipsum\" ;\njson[\"string\"] =     json::String(\"lorem ipsum\");\njson[\"string\"] =      std::string(\"lorem ipsum\");\njson[\"string\"] = std::string_view(\"lorem ipsum\");\n\n// ...and so on and so forth with other types, same thing with custom containers.\n// All classes can convert as long as they provide std-like API.\n</code></pre>"},{"location":"module_json.html#getters_1","title":"Getters","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\nusing namespace json::literals;\n\n// Create JSON from literal\nauto json = R\"(\n    {\n        \"string\": \"lorem_ipsum\",\n        \"array\": [ 1, 2, 3 ],\n        \"object\": {\n            \"key_1\": 3.14,\n            \"key_2\": 6.28\n        }\n    }\n)\"_utl_json;\n\n// Check that node exists\nassert( json.contains(\"string\") );\n\n// Check the type of a JSON node\nassert( json[\"string\"].is_string() );\n\n// Get typed value from a JSON node\nconst auto str = json.at(\"string\").get_string(); // '.at(key)' and '[key]' are both valid\n\n// Iterate over a JSON object node\nfor (const auto &amp;[key, value] : json.at(\"object\").get_object())\n    assert( key.front() == 'k' &amp;&amp; value.get_number() &gt; 0 );\n\n// Iterate over a JSON array node\nfor (const auto &amp;element : json.at(\"array\").get_array())\n    assert( element.get_number() &gt; 0 );\n</code></pre>"},{"location":"module_json.html#formatting","title":"Formatting","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\njson::Node json;\n\njson[\"string\"]           = \"lorem ipsum\";\njson[\"array\"]            = { 1, 2, 3 }; \njson[\"object\"][\"key_1\"]  = 3.14; \njson[\"object\"][\"key_2\"]  = 6.28;\n\n// Prettified/Minimized JSON\nstd::cout\n    &lt;&lt; \"--- Prettified JSON ---\"\n    &lt;&lt; \"\\n\\n\"\n    &lt;&lt; json.to_string()\n    &lt;&lt; \"\\n\\n\"\n    &lt;&lt; \"--- Minimized JSON ---\"\n    &lt;&lt; \"\\n\\n\"\n    &lt;&lt; json.to_string(json::Format::MINIMIZED);\n</code></pre> <p>Output: <pre><code>--- Prettified JSON ---\n\n{\n    \"array\": [\n        1,\n        2,\n        3\n    ],\n    \"object\": {\n        \"key_1\": 3.14,\n        \"key_2\": 6.28\n    },\n    \"string\": \"lorem ipsum\"\n}\n\n--- Minimized JSON ---\n\n{\"array\":[1,2,3],\"object\":{\"key_1\":3.14,\"key_2\":6.28},\"string\":\"lorem ipsum\"}\n</code></pre></p>"},{"location":"module_json.html#error-handling","title":"Error handling","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\nconst auto invalid_json = R\"(\n    {\n        \"key_1\": \"value_1\",\n        \"key_2\":  value_2\",\n        \"key_3\": \"value_3\"\n    }\n)\";\n\ntry {\n    [[maybe_unused]] auto res = json::from_string(invalid_json);\n}\ncatch (std::runtime_error &amp;e) {\n    std::cerr &lt;&lt; \"ERROR: Caught exception:\\n\\n\" &lt;&lt; e.what();\n}\n</code></pre> <p>Output: <pre><code>ERROR: Caught exception:\n\nJSON node selector encountered unexpected marker symbol {v} at pos 48 (should be one of {0123456789{[\"tfn}).\nLine 4:         \"key_2\":  value_2\",\n        ------------------^-------- [!]\n</code></pre></p>"},{"location":"module_json.html#structure-reflection","title":"Structure reflection","text":"<p>Important</p> <p>When compiling with MSVC use <code>/Zc:preprocessor</code> to enable standard-compliant preprocessor. Default MSVC preprocessor is notoriously non-compliant due to legacy reasons and might not handle macro expansion properly.</p> <p>[ Run this code ] [ Open source file ]</p> <pre><code>struct Config {\n    bool        auxiliary_info = true;\n    std::string date           = \"2024.04.02\";\n\n    struct Options {\n        int grid_size = 120;\n        int phi_order = 5;\n    } options;\n\n    std::vector&lt;std::string&gt; scaling_functions = {\"identity\", \"log10\"};\n    std::size_t              time_steps        = 500;\n    double                   time_period       = 1.24709e+2;\n};\n\nUTL_JSON_REFLECT(Config, auxiliary_info, date, options, scaling_functions, time_steps, time_period);\nUTL_JSON_REFLECT(Config::Options, grid_size, phi_order);\n\n// ...\n\nusing namespace utl;\n\n// Parse JSON from struct\nauto       config = Config{};\njson::Node json   = json::from_struct(config);\n\n// Test the result\nstd::cout &lt;&lt; \"--- Struct to JSON ---\\n\" &lt;&lt; json.to_string();\n\n// Serialize JSON to struct\nauto serialized_config = json.to_struct&lt;Config&gt;();\n\n// Test the result\nassert( config.auxiliary_info    == serialized_config.auxiliary_info    );\nassert( config.date              == serialized_config.date              );\nassert( config.options.grid_size == serialized_config.options.grid_size );\n// ...and so on\n</code></pre> <p>Output: <pre><code>--- Struct to JSON ---\n{\n    \"auxiliary_info\": true,\n    \"date\": \"2024.04.02\",\n    \"options\": {\n        \"grid_size\": 120,\n        \"phi_order\": 5\n    },\n    \"scaling_functions\": [\n        \"identity\",\n        \"log10\"\n    ],\n    \"time_period\": 124.709,\n    \"time_steps\": 500\n}\n</code></pre></p>"},{"location":"module_json.html#complex-structure-reflection","title":"Complex structure reflection","text":"<p>Note</p> <p>There are no particular limitations on what kinds of nested structures can be reflected, as long as there is a logically sound path to converting one thing to another <code>utl::json</code> will figure out a way.</p> <p>[ Run this code ] [ Open source file ]</p> <pre><code>// Set up some complex nested structs\nstruct Point {\n    double x, y, z;\n};\n\nstruct Task {\n    std::string input_path;\n    std::string output_path;\n    double      time_limit;\n};\n\nstruct TaskList {\n    std::map&lt;std::string, Task&gt; map_of_tasks;\n    // this is fine\n\n    std::vector&lt;std::vector&lt;Point&gt;&gt; matrix_of_points;\n    // this is also fine\n\n    // std::vector&lt;std::vector&lt;std::vector&lt;std::map&lt;std::string, Point&gt;&gt;&gt;&gt; tensor_of_maps_of_points;\n    // ... this would also be fine\n\n    // std::array&lt;std::unordered_map&lt;std::string, Task&gt;, 4&gt; array_of_maps_of_tasks;\n    // ... and so will be this\n};\n\nUTL_JSON_REFLECT(Point, x, y, z);\nUTL_JSON_REFLECT(Task, input_path, output_path, time_limit);\nUTL_JSON_REFLECT(TaskList, map_of_tasks, matrix_of_points);\n\n// ...\n\nusing namespace utl;\n\nconst TaskList task_list = {\n    // Map of tasks\n    {\n        { \"task_1\", { \"input_1.dat\", \"output_1.dat\", 170. } },\n        { \"task_2\", { \"input_2.dat\", \"output_2.dat\", 185. } }\n    },\n    // Matrix of 3D points\n    {\n        { { 0, 0, 0}, { 1, 0, 0 } },\n        { { 0, 1, 0}, { 0, 0, 1 } }\n    }\n};\n\n// Parse JSON from struct,\n// this also doubles as a way of stringifying structs for debugging\nstd::cout &lt;&lt; json::from_struct(task_list).to_string();\n</code></pre> <p>Output: <pre><code>{\n    \"map_of_tasks\": {\n        \"task_1\": {\n            \"input_path\": \"input_1.dat\",\n            \"output_path\": \"output_1.dat\",\n            \"time_limit\": 170\n        },\n        \"task_2\": {\n            \"input_path\": \"input_2.dat\",\n            \"output_path\": \"output_2.dat\",\n            \"time_limit\": 185\n        }\n    },\n    \"matrix_of_points\": [\n        [\n            {\n                \"x\": 0,\n                \"y\": 0,\n                \"z\": 0\n            },\n            {\n                \"x\": 1,\n                \"y\": 0,\n                \"z\": 0\n            }\n        ],\n        [\n            {\n                \"x\": 0,\n                \"y\": 1,\n                \"z\": 0\n            },\n            {\n                \"x\": 0,\n                \"y\": 0,\n                \"z\": 1\n            }\n        ]\n    ]\n}\n</code></pre></p>"},{"location":"module_json.html#tests","title":"Tests","text":"<p><code>utl::json</code> parsing was tested using the standard RFC-8259 compliance testing suite with following metrics:</p> Metric Compliance Note Parser accepts valid RFC-8259 JSON 100% Full conformance Parser rejects invalid RFC-8259 JSON 93.6% Missing conformance of 6.4% is due to parser imposing less restrictions on the floating point format, it will accepts values such as <code>2.</code>, <code>01</code>, <code>2.e+3</code> and etc., which go beyond the default JSON specification. <p>Parsing and serialization also satisfies C++ <code>&lt;charconv&gt;</code> float round-trip guarantees (which means floats serialized by <code>utl::json</code> will be recovered to the exact same value when parsed again by the library).</p>"},{"location":"module_json.html#benchmarks","title":"Benchmarks","text":"<p>Benchmarks for parsing and serializing of minimized JSON data corresponding to various entries in the test suite. </p> <pre><code>====== BENCHMARKING ON DATA: `strings.json` ======\n\n| relative |               ms/op |                op/s |    err% |     total | Parsing minimized JSON\n|---------:|--------------------:|--------------------:|--------:|----------:|:-----------------------\n|   100.0% |               16.03 |               62.40 |    4.6% |      0.81 | `utl::json`\n|    25.3% |               63.43 |               15.76 |    0.4% |      3.11 | `nlohmann`\n|    47.5% |               33.71 |               29.66 |    0.3% |      1.65 | `PicoJSON`\n|    94.4% |               16.98 |               58.90 |    0.2% |      0.83 | `RapidJSON`\n\n| relative |               ms/op |                op/s |    err% |     total | Parsing prettified JSON\n|---------:|--------------------:|--------------------:|--------:|----------:|:------------------------\n|   100.0% |               15.85 |               63.08 |    0.7% |      0.78 | `utl::json`\n|    24.4% |               64.88 |               15.41 |    0.2% |      3.19 | `nlohmann`\n|    45.6% |               34.77 |               28.76 |    0.5% |      1.69 | `PicoJSON`\n|    88.1% |               17.99 |               55.60 |    0.4% |      0.88 | `RapidJSON`\n\n| relative |               ms/op |                op/s |    err% |     total | Serializing minimized JSON\n|---------:|--------------------:|--------------------:|--------:|----------:|:---------------------------\n|   100.0% |               11.90 |               84.05 |    0.2% |      0.59 | `utl::json`\n|    42.2% |               28.22 |               35.44 |    0.4% |      1.39 | `nlohmann`\n|    33.1% |               36.00 |               27.78 |    0.2% |      1.76 | `PicoJSON`\n|    75.5% |               15.77 |               63.42 |    0.5% |      0.77 | `RapidJSON`\n\n| relative |               ms/op |                op/s |    err% |     total | Serializing prettified JSON\n|---------:|--------------------:|--------------------:|--------:|----------:|:----------------------------\n|   100.0% |               12.67 |               78.93 |    0.7% |      0.62 | `utl::json`\n|    41.7% |               30.41 |               32.88 |    3.4% |      1.52 | `nlohmann`\n|    33.2% |               38.20 |               26.18 |    0.6% |      1.88 | `PicoJSON`\n|    75.9% |               16.69 |               59.92 |    1.2% |      0.82 | `RapidJSON`\n\n\n====== BENCHMARKING ON DATA: `numbers.json` ======\n\n| relative |               ms/op |                op/s |    err% |     total | Parsing minimized JSON\n|---------:|--------------------:|--------------------:|--------:|----------:|:-----------------------\n|   100.0% |               10.95 |               91.35 |    0.7% |      0.54 | `utl::json`\n|    22.9% |               47.79 |               20.92 |    0.6% |      2.35 | `nlohmann`\n|    28.2% |               38.78 |               25.79 |    0.5% |      1.89 | `PicoJSON`\n|   144.6% |                7.57 |              132.11 |    0.4% |      0.37 | `RapidJSON`\n\n| relative |               ms/op |                op/s |    err% |     total | Parsing prettified JSON\n|---------:|--------------------:|--------------------:|--------:|----------:|:------------------------\n|   100.0% |               11.26 |               88.84 |    0.2% |      0.55 | `utl::json`\n|    22.6% |               49.88 |               20.05 |    0.5% |      2.51 | `nlohmann`\n|    28.1% |               39.99 |               25.00 |    1.4% |      1.96 | `PicoJSON`\n|   128.9% |                8.73 |              114.51 |    3.1% |      0.43 | `RapidJSON`\n\n| relative |               ms/op |                op/s |    err% |     total | Serializing minimized JSON\n|---------:|--------------------:|--------------------:|--------:|----------:|:---------------------------\n|   100.0% |               11.18 |               89.44 |    1.0% |      0.55 | `utl::json`\n|    65.2% |               17.14 |               58.33 |    0.4% |      0.85 | `nlohmann`\n|    13.9% |               80.48 |               12.43 |    0.6% |      3.95 | `PicoJSON`\n|    63.9% |               17.51 |               57.13 |    1.1% |      0.85 | `RapidJSON`\n\n| relative |               ms/op |                op/s |    err% |     total | Serializing prettified JSON\n|---------:|--------------------:|--------------------:|--------:|----------:|:----------------------------\n|   100.0% |               13.43 |               74.48 |    1.0% |      0.66 | `utl::json`\n|    65.0% |               20.64 |               48.44 |    0.6% |      1.02 | `nlohmann`\n|    16.3% |               82.14 |               12.17 |    0.4% |      4.04 | `PicoJSON`\n|    74.3% |               18.06 |               55.38 |    0.4% |      0.89 | `RapidJSON`\n\n\n====== BENCHMARKING ON DATA: `twitter.json` ======\n\n| relative |               ms/op |                op/s |    err% |     total | Parsing minimized JSON\n|---------:|--------------------:|--------------------:|--------:|----------:|:-----------------------\n|   100.0% |                2.48 |              402.89 |    0.5% |      0.12 | `utl::json`\n|    45.4% |                5.47 |              182.76 |    0.1% |      0.27 | `nlohmann`\n|    77.3% |                3.21 |              311.24 |    0.2% |      0.16 | `PicoJSON`\n|   221.6% |                1.12 |              892.87 |    1.3% |      0.05 | `RapidJSON`\n\n| relative |               ms/op |                op/s |    err% |     total | Parsing prettified JSON\n|---------:|--------------------:|--------------------:|--------:|----------:|:------------------------\n|   100.0% |                2.80 |              356.62 |    0.5% |      0.14 | `utl::json`\n|    45.2% |                6.21 |              161.12 |    0.4% |      0.31 | `nlohmann`\n|    74.9% |                3.74 |              267.05 |    0.6% |      0.18 | `PicoJSON`\n|   207.1% |                1.35 |              738.54 |    1.5% |      0.07 | `RapidJSON`\n\n| relative |               ms/op |                op/s |    err% |     total | Serializing minimized JSON\n|---------:|--------------------:|--------------------:|--------:|----------:|:---------------------------\n|   100.0% |                1.20 |              834.42 |    2.0% |      0.06 | `utl::json`\n|    52.8% |                2.27 |              440.27 |    2.0% |      0.13 | `nlohmann`\n|    29.0% |                4.14 |              241.62 |   21.3% |      0.20 | `PicoJSON`\n|    94.3% |                1.27 |              786.88 |    0.6% |      0.06 | `RapidJSON`\n\n| relative |               ms/op |                op/s |    err% |     total | Serializing prettified JSON\n|---------:|--------------------:|--------------------:|--------:|----------:|:----------------------------\n|   100.0% |                1.60 |              626.16 |    0.4% |      0.08 | `utl::json`\n|    57.9% |                2.76 |              362.32 |    0.3% |      0.14 | `nlohmann`\n|    44.4% |                3.60 |              277.81 |    0.4% |      0.18 | `PicoJSON`\n|    91.1% |                1.75 |              570.23 |    0.6% |      0.09 | `RapidJSON`\n\n\n====== BENCHMARKING ON DATA: `apache_builds.json` ======\n\n| relative |               ms/op |                op/s |    err% |     total | Parsing minimized JSON\n|---------:|--------------------:|--------------------:|--------:|----------:|:-----------------------\n|   100.0% |                0.47 |            2,134.76 |    0.7% |      0.02 | `utl::json`\n|    41.3% |                1.14 |              881.03 |    1.6% |      0.06 | `nlohmann`\n|    77.4% |                0.61 |            1,652.53 |    0.6% |      0.03 | `PicoJSON`\n|   172.2% |                0.27 |            3,675.37 |    1.3% |      0.01 | `RapidJSON`\n\n| relative |               ms/op |                op/s |    err% |     total | Parsing prettified JSON\n|---------:|--------------------:|--------------------:|--------:|----------:|:------------------------\n|   100.0% |                0.49 |            2,053.48 |    0.3% |      0.02 | `utl::json`\n|    38.7% |                1.26 |              794.02 |    1.4% |      0.06 | `nlohmann`\n|    71.5% |                0.68 |            1,468.49 |    0.7% |      0.03 | `PicoJSON`\n|   163.1% |                0.30 |            3,348.22 |    0.8% |      0.01 | `RapidJSON`\n\n| relative |               ms/op |                op/s |    err% |     total | Serializing minimized JSON\n|---------:|--------------------:|--------------------:|--------:|----------:|:---------------------------\n|   100.0% |                0.30 |            3,283.66 |    0.7% |      0.02 | `utl::json`\n|    57.5% |                0.53 |            1,889.72 |    0.8% |      0.03 | `nlohmann`\n|    46.2% |                0.66 |            1,518.06 |    0.6% |      0.03 | `PicoJSON`\n|   100.5% |                0.30 |            3,301.60 |    2.2% |      0.02 | `RapidJSON`\n\n| relative |               ms/op |                op/s |    err% |     total | Serializing prettified JSON\n|---------:|--------------------:|--------------------:|--------:|----------:|:----------------------------\n|   100.0% |                0.40 |            2,488.96 |    2.3% |      0.02 | `utl::json`\n|    61.9% |                0.65 |            1,540.09 |    1.5% |      0.03 | `nlohmann`\n|    53.8% |                0.75 |            1,338.57 |    1.6% |      0.04 | `PicoJSON`\n|    98.9% |                0.41 |            2,461.15 |    3.0% |      0.02 | `RapidJSON`\n</code></pre> <p>Important</p> <p>Clang with <code>libc++</code> below version 20 does not implement C++17 <code>std::from_chars</code>, forcing the library to fallback onto a significantly slower number parsing routine. This is mostly a MacOS issue. Fallback presence can be detected with <code>#ifdef UTL_JSON_FROM_CHARS_FALLBACK</code>.</p>"},{"location":"module_json.html#some-thoughts-on-implementation","title":"Some thoughts on implementation","text":"<p>The main weak-point of <code>utl::json</code> from the performance point of view is parsing  of object-heavy JSONs.</p> <p>Unfortunately, the issue is mostly caused by <code>std::map</code> insertion &amp; iteration, which dominates the runtime. A truly suitable for the purpose container doesn't really exist in the standard library, and would need a custom implementation like in <code>RapidJSON</code>, which would reduce the standard library interoperability thus going against the main goal of this library which is its simplicity of use.</p> <p>Flat maps maps seem like the way to go, slotting in a custom flat map implementation into <code>impl::object_type_impl</code> allowed <code>utl::json</code> to beat <code>RapidJSON</code> on all serializing tasks and significantly closed the gap of <code>database.json</code> parsing:</p> <pre><code>// Using associative wrapper for std::vector of pairs instead of std::map we can bridge the performance gap.\n// General-case usage however suffers, which is why this decision was ruled against.\n// Measurement below was done on a database very similar to 'twitter.json' but with even more objects &amp; nesting.\n\n====== BENCHMARKING ON DATA: `database.json` ======\n\n| relative |               ms/op |                op/s |    err% |     total | Parsing minimized JSON\n|---------:|--------------------:|--------------------:|--------:|----------:|:-----------------------\n|   100.0% |               13.22 |               75.65 |    0.6% |      0.95 | `utl::json`\n|    24.7% |               53.57 |               18.67 |    3.6% |      3.93 | `nlohmann`\n|    43.5% |               30.42 |               32.87 |    0.7% |      2.19 | `PicoJSON`\n|   139.5% |                9.48 |              105.51 |    0.2% |      0.68 | `RapidJSON`\n\n| relative |               ms/op |                op/s |    err% |     total | Parsing prettified JSON\n|---------:|--------------------:|--------------------:|--------:|----------:|:------------------------\n|   100.0% |               14.28 |               70.02 |    0.5% |      1.03 | `utl::json`\n|    25.8% |               55.36 |               18.06 |    0.5% |      3.99 | `nlohmann`\n|    41.1% |               34.75 |               28.78 |    0.2% |      2.50 | `PicoJSON`\n|   130.4% |               10.95 |               91.33 |    0.4% |      0.79 | `RapidJSON`\n\n| relative |               ms/op |                op/s |    err% |     total | Serializing minimized JSON\n|---------:|--------------------:|--------------------:|--------:|----------:|:---------------------------\n|   100.0% |                8.47 |              118.00 |    0.2% |      0.61 | `utl::json`\n|    35.7% |               23.74 |               42.12 |    0.3% |      1.71 | `nlohmann`\n|    23.6% |               35.85 |               27.89 |    0.4% |      2.57 | `PicoJSON`\n|    94.4% |                8.97 |              111.43 |    0.3% |      0.65 | `RapidJSON`\n\n| relative |               ms/op |                op/s |    err% |     total | Serializing prettified JSON\n|---------:|--------------------:|--------------------:|--------:|----------:|:----------------------------\n|   100.0% |               10.09 |               99.12 |    0.4% |      0.73 | `utl::json`\n|    39.2% |               25.74 |               38.85 |    0.5% |      1.85 | `nlohmann`\n|    26.8% |               37.61 |               26.59 |    0.4% |      2.71 | `PicoJSON`\n|    93.7% |               10.77 |               92.87 |    0.2% |      0.78 | `RapidJSON`\n</code></pre>"},{"location":"module_log.html","title":"utl::log","text":"<p>&lt;- to README.md</p> <p>&lt;- to implementation.hpp</p> <p>utl::log is a lean logging library that tries to make log syntax as simple as possible. It uses type traits to deduce how to serialize various types without depending on its their explicit support, while still providing customization points through formatter specialization. Due to compile-time parametrization &amp; custom formatting the logger achieves significantly lower overhead than standard <code>std::ostream</code>-based solutions.</p> <p>Key features:</p> <ul> <li>Simple API with no macros</li> <li>Serializes almost every type &amp; container</li> <li>Automatically adapts to containers with std-like API</li> <li>Concise syntax for alignment / color / number formatting</li> <li>Sync/async logging with various buffering policies</li> <li>Convenient <code>println()</code> and <code>stringify()</code></li> </ul> <p>Quirks of the library:</p> <ul> <li>Variadic syntax</li> <li>Compile-time parametrization</li> <li>Built-in formatting system</li> </ul> <p>Quick showcase:</p> <pre><code>log::info(\"Message 1\");\nlog::warn(\"Message 2\");\nlog::err (\"Message 3\");\n</code></pre> <p></p> <pre><code>const auto start = std::chrono::steady_clock::now();\n\nlog::println(\"value   = \"  , std::vector{2e-3, 3e-3, 4e-3}           );\nlog::println(\"error   = \"  , 1.357 | log::scientific(2)              );\nlog::println(\"message = \"  , \"low tolerance\" | log::color::bold_red  );\nlog::println(\"Finished in \", std::chrono::steady_clock::now() - start);\n</code></pre> <p></p>"},{"location":"module_log.html#definitions","title":"Definitions","text":"<pre><code>// Logger\ntemplate &lt;class... Sinks&gt;\nstruct Logger {\n    Logger(Sinks&amp;&amp;... sinks);\n\n    template &lt;class... Args&gt; void err  (const Args&amp;... args);\n    template &lt;class... Args&gt; void warn (const Args&amp;... args);\n    template &lt;class... Args&gt; void note (const Args&amp;... args);\n    template &lt;class... Args&gt; void info (const Args&amp;... args);\n    template &lt;class... Args&gt; void debug(const Args&amp;... args);\n    template &lt;class... Args&gt; void trace(const Args&amp;... args);\n};\n\n// Sink\ntemplate &lt;\n    policy::Type      type,     = /* inferred from constructor */,\n    policy::Level     level     = /* defaults based on 'type'  */,\n    policy::Color     color     = /* defaults based on 'type'  */,\n    policy::Format    format    = /* defaults based on 'type'  */,\n    policy::Buffering buffering = /* defaults based on 'type'  */,\n    policy::Flushing  flushing  = /* defaults based on 'type'  */,\n    policy::Threading threading = /* defaults based on 'type'  */\n&gt; struct Sink {\n    Sink(std::ofstream&amp;&amp;  file); // for file   sinks\n    Sink(std::string_view name); // for file   sinks\n    Sink(std::ostream&amp;      os); // for stream sinks\n    Sink(std::string&amp;      str); // for string sinks\n};\n\n// Policies\nnamespace policy {\n    enum class Type      { FILE, STREAM };\n    enum class Level     { ERR, WARN, NOTE, INFO, DEBUG, TRACE };\n    enum class Color     { NONE, ANSI };\n    enum class Format    { DATE, TITLE, THREAD, UPTIME, CALLSITE, LEVEL, NONE, FULL }; // bitmask\n    enum class Buffering { NONE, FIXED, TIMED };\n    enum class Flushing  { SYNC, ASYNC };\n    enum class Threading { UNSAFE, SAFE };\n}\n\n// Pre-defined global logger\ntemplate &lt;class... Args&gt; void err  (const Args&amp;... args);\ntemplate &lt;class... Args&gt; void warn (const Args&amp;... args);\ntemplate &lt;class... Args&gt; void note (const Args&amp;... args);\ntemplate &lt;class... Args&gt; void info (const Args&amp;... args);\ntemplate &lt;class... Args&gt; void debug(const Args&amp;... args);\ntemplate &lt;class... Args&gt; void trace(const Args&amp;... args);\n\n// Printing\ntemplate &lt;class... Args&gt; void print  (const Args&amp;... args);\ntemplate &lt;class... Args&gt; void println(const Args&amp;... args);\n\ntemplate &lt;class... Args&gt; std::string stringify(const Args&amp;... args);\n\n// Formatting modifiers\nconstexpr mods::FloatFormat general     (std::size_t precision = 6) noexcept;\nconstexpr mods::FloatFormat fixed       (std::size_t precision = 3) noexcept;\nconstexpr mods::FloatFormat scientific  (std::size_t precision = 3) noexcept;\nconstexpr mods::FloatFormat hex         (std::size_t precision = 3) noexcept;\nconstexpr mods::IntFormat   base        (std::size_t base         ) noexcept;\nconstexpr mods::AlignLeft   align_left  (std::size_t size         ) noexcept;\nconstexpr mods::AlignCenter align_center(std::size_t size         ) noexcept;\nconstexpr mods::AlignRight  align_right (std::size_t size         ) noexcept;\n// + all ANSI colors, see methods for the full list\n\ntemplate &lt;class T&gt;\nconstexpr /*formatted-value*/ operator|(T&amp;&amp; value, /*formatting-mod*/ modifier) noexcept;\n</code></pre>"},{"location":"module_log.html#methods","title":"Methods","text":""},{"location":"module_log.html#logger","title":"Logger","text":"<pre><code>template &lt;class... Sinks&gt;\nstruct Logger {\n    Logger(Sinks&amp;&amp;... sinks);\n    \n    template &lt;class... Args&gt; void err  (const Args&amp;... args);\n    template &lt;class... Args&gt; void warn (const Args&amp;... args);\n    template &lt;class... Args&gt; void note (const Args&amp;... args);\n    template &lt;class... Args&gt; void info (const Args&amp;... args);\n    template &lt;class... Args&gt; void debug(const Args&amp;... args);\n    template &lt;class... Args&gt; void trace(const Args&amp;... args);\n};\n</code></pre> <p>A logger containing one or several sinks.</p> <p>Functions <code>err()</code> / <code>warn()</code> / <code>note()</code> / <code>info()</code> / <code>debug()</code> / <code>trace()</code> create log entries at corresponding verbosity levels with <code>args...</code> as a message.</p> <p>Note: The <code>Logger</code> object can be used locally as a regular RAII object, or wrapped in a function to work globally.</p>"},{"location":"module_log.html#sink","title":"Sink","text":"<pre><code>template &lt;\n    policy::Type      type,     = /* inferred from constructor */,\n    policy::Level     level     = /* defaults based on 'type'  */,\n    policy::Color     color     = /* defaults based on 'type'  */,\n    policy::Format    format    = /* defaults based on 'type'  */,\n    policy::Buffering buffering = /* defaults based on 'type'  */,\n    policy::Flushing  flushing  = /* defaults based on 'type'  */,\n    policy::Threading threading = /* defaults based on 'type'  */\n&gt; struct Sink {\n    Sink(std::ofstream&amp;&amp;  file); // for file   sinks\n    Sink(std::string_view name); // for file   sinks\n    Sink(std::ostream&amp;      os); // for stream sinks\n    Sink(std::string&amp;      str); // for string sinks\n};\n</code></pre> <p>Logger sink is a wrapper around the file handle (<code>std::ofstream</code>) or stream (<code>std::ostream&amp;</code>) that handles writing log messages to them.</p> <p><code>Sink</code> behavior can be customized at compile-time using policies. See the example.</p> <p>By default, the <code>Sink</code> will infer its <code>type</code> based on the constructor argument, while its policies get defaulted to suit the common use case:</p> Type <code>Type::STREAM</code> <code>Type::FILE</code> Default <code>level</code> <code>Level::INFO</code> <code>Level::TRACE</code> Default <code>color</code> <code>Color::ANSI</code> <code>Color::NONE</code> Default <code>format</code> <code>Format::FULL</code> <code>Format::FULL</code> Default <code>buffering</code> <code>Buffering::NONE</code> <code>Buffering::FIXED</code> Default <code>flushing</code> <code>Flushing::SYNC</code> <code>Flushing::ASYNC</code> Default <code>threading</code> <code>Threading::SAFE</code> <code>Threading::SAFE</code>"},{"location":"module_log.html#policies","title":"Policies","text":"<p>Note</p> <p>All policies reside in a <code>log::policy</code> namespace.</p>"},{"location":"module_log.html#type","title":"Type","text":"<pre><code>enum class Type { FILE, STREAM };\n</code></pre> <p>Specifies the output type of the sink:</p> Value Output type <code>Type::FILE</code> File handle (<code>std::ofstream</code>) <code>Type::STREAM</code> Stream (<code>std::ostream&amp;</code>)"},{"location":"module_log.html#level","title":"Level","text":"<pre><code>enum class Level { ERR, WARN, NOTE, INFO, DEBUG, TRACE };\n</code></pre> <p>Specifies the verbosity level of the sink:</p> Value Verbosity level <code>Level::ERR</code> <code>ERR</code> only <code>Level::WARN</code> <code>WARN</code> or above <code>Level::NOTE</code> <code>NOTE</code> or above <code>Level::INFO</code> <code>INFO</code> or above <code>Level::DEBUG</code> <code>DEBUG</code> or above <code>Level::TRACE</code> <code>TRACE</code> or above"},{"location":"module_log.html#color","title":"Color","text":"<pre><code>enum class Color { NONE, ANSI };\n</code></pre> <p>Specifies the color setting of the sink:</p> Value Color setting <code>Color::NONE</code> Ignore color modifiers <code>Color::ANSI</code> Use ANSI escape sequences to format color modifiers"},{"location":"module_log.html#format","title":"Format","text":"<pre><code>enum class Format { DATE, TITLE, THREAD, UPTIME, CALLSITE, LEVEL, NONE, FULL };\n</code></pre> <p>Specifies the enabled parts of the sink output:</p> Value Enabled parts <code>DATE</code> Date &amp; time at the top of the log <code>TITLE</code> Column titles at the top of the log <code>THREAD</code> Thread id column <code>UPTIME</code> Uptime in milliseconds column <code>CALLSITE</code> Callsite column <code>LEVEL</code> Message level column <code>NONE</code> Only message is displayed <code>FULL</code> <code>DATE | TITLE | THREAD | UPTIME | CALLSITE | LEVEL</code> <p>Note: This <code>enum</code> works like bitmask, for example, value <code>THREAD | UPTIME</code> will correspond to formatting both columns.</p>"},{"location":"module_log.html#buffering","title":"Buffering","text":"<pre><code>enum class Buffering { NONE, FIXED, TIMED };\n</code></pre> <p>Specifies the buffering strategy of the sink output:</p> Value Buffering strategy <code>Buffering::NONE</code> All output is flushed immediately <code>Buffering::FIXED</code> Output is flushed after every 8 KiB <code>Buffering::TIMED</code> Output is flushed after every 5 milliseconds <p>Note: Instant buffering tends to be useful during debugging as it ensures no lost messages in case of a crash. Fixed buffering strategy is generally the most reliable in terms of performance. Timed buffering is a hybrid solution that doesn't suffer the full slowdown of instant buffering while still keeping the logs close to the real-time. </p>"},{"location":"module_log.html#flushing","title":"Flushing","text":"<pre><code>enum class Flushing  { SYNC, ASYNC };\n</code></pre> <p>Specifies the flushing strategy of the sink output:</p> Value Flushing strategy <code>Flushing::SYNC</code> Flushing is performed on the same thread <code>Flushing::ASYNC</code> Flushing is performed asynchronously on another thread <p>Note: Async flushing reduces logging latency for the caller, but increases the total amount of work that needs to be done by all threads. It is generally beneficial unless all threads are 100% busy.</p>"},{"location":"module_log.html#threading","title":"Threading","text":"<pre><code>enum class Threading { UNSAFE, SAFE };\n</code></pre> <p>Specifies the thread safety of the sink output:</p> Value Thread safety <code>Threading::UNSAFE</code> Logging is not thread-safe <code>Threading::SAFE</code> Logging is thread-safe <p>Note: Disabling thread safety is generally not advised, but can lead to a performance increase in single-threaded scenarios.</p>"},{"location":"module_log.html#pre-defined-global-logger","title":"Pre-defined global logger","text":"<pre><code>template &lt;class... Args&gt; void err  (const Args&amp;... args);\ntemplate &lt;class... Args&gt; void warn (const Args&amp;... args);\ntemplate &lt;class... Args&gt; void note (const Args&amp;... args);\ntemplate &lt;class... Args&gt; void info (const Args&amp;... args);\ntemplate &lt;class... Args&gt; void debug(const Args&amp;... args);\ntemplate &lt;class... Args&gt; void trace(const Args&amp;... args);\n</code></pre> <p>Convenience alias for the <code>err()</code> / <code>warn()</code> / <code>note()</code> / <code>info()</code> / <code>debug()</code> / <code>trace()</code> methods of a pre-defined global logger.</p> <p>The default logger is lazily initialized upon the first call to these functions, it sinks to <code>std::cout</code> and <code>latest.log</code> file using the default sink policies .</p>"},{"location":"module_log.html#printing","title":"Printing","text":"<pre><code>template &lt;class... Args&gt; void print  (const Args&amp;... args);\ntemplate &lt;class... Args&gt; void println(const Args&amp;... args);\n</code></pre> <p>Prints <code>args...</code> to <code>std::cout</code> using the formatter logic of this library.</p> <p>This is particularly useful during debugging and general CLI work, as <code>println()</code> is both more concise that regular <code>std::cout</code> usage and supports a large variety of types that can't be serialized by default. Formatting modifiers are also fully supported which allows coloring, alignment and numeric formatting beyond the regular capabilities of stream <code>&lt;ios&gt;</code>.</p> <p>In addition to this, <code>println()</code> is fully thread-safe and locale-independent (unless locale dependency is introduced by the user defining a custom formatter specialization).</p> <pre><code>template &lt;class... Args&gt; std::string stringify(const Args&amp;... args);\n</code></pre> <p>Formats <code>args...</code> into an <code>std::string</code> using the formatter logic of this library.</p> <p>This functions is effectively a universal variadic version of <code>std::to_string()</code>.</p> <p>Note: Due to a heavy compile-time logic utilization, this function is likely to significantly outperform any stringification based on <code>std::stringstream</code>. It also heavily outperforms floating-point <code>std::to_string()</code> and <code>sprintf()</code> due to a more advanced floating-point serialization algorithm based on <code>&lt;charconv&gt;</code>. Similarly to the <code>println()</code>, the output is locale-independent by default.</p>"},{"location":"module_log.html#formatting-modifiers","title":"Formatting modifiers","text":"<pre><code>template &lt;class T&gt;\nconstexpr /*formatted-value*/ operator|(T&amp;&amp; value, /*formatting-mod*/ modifier) noexcept;\n</code></pre> <p>Formatting <code>modifier</code> can be applied to a <code>value</code> by using the <code>operator|</code> on its right-hand side.</p> <p>For example, <code>x | mod_1 | mod_2</code> will apply formatting modifiers <code>mod_1</code> and <code>mod_2</code> to the value <code>x</code>.</p>"},{"location":"module_log.html#numeric-format","title":"Numeric format","text":"<pre><code>constexpr mods::FloatFormat general    (std::size_t precision = 6) noexcept;\nconstexpr mods::FloatFormat fixed      (std::size_t precision = 3) noexcept;\nconstexpr mods::FloatFormat scientific (std::size_t precision = 3) noexcept;\nconstexpr mods::FloatFormat hex        (std::size_t precision = 3) noexcept;\n</code></pre> <p>Modifiers that specify the precision and format of a floating point value.</p> <p>Note 1: Only applicable to floating-point values, this is checked at compile-time.</p> <p>Note 2: By default, general format is used with precision chosen according to the shortest representation, see <code>std::to_chars()</code>.</p> <p>Note 3: Standard streams implement similar behavior using <code>std::setprecision</code> in combination with <code>std::fixed</code> / <code>std::scientific</code> / <code>std::hexfloat</code> / <code>std::defaultfloat</code>.</p> <pre><code>constexpr mods::IntFormat base(std::size_t base) noexcept;\n</code></pre> <p>Modifier that specifies the base of an integer value.</p> <p>Note 1: Only applicable to integer values, this is checked at compile-time.</p> <p>Note 2: By default, integers are serialized in base <code>10</code>.</p> <p>Note 3: Standard streams implement similar behavior for base <code>10</code> / <code>16</code> / <code>8</code> using <code>std::dec</code> / <code>std::hex</code> / <code>std::oct</code>, other arbitrary bases are not supported by standard <code>&lt;ios&gt;</code>.</p>"},{"location":"module_log.html#alignment","title":"Alignment","text":"<pre><code>constexpr mods::AlignLeft   align_left  (std::size_t size) noexcept;\nconstexpr mods::AlignCenter align_center(std::size_t size) noexcept;\nconstexpr mods::AlignRight  align_right (std::size_t size) noexcept;\n</code></pre> <p>Modifiers that specify the horizontal alignment of serialized value.</p> <p>Note 1: When serialized value is <code>size</code> or more characters long, it is left unchanged.</p> <p>Note 2: Standard streams implement similar behavior using <code>std::setw()</code> in combination with <code>std::left</code> / <code>std::right</code>, except there is no manipulator for central alignment.</p>"},{"location":"module_log.html#colors","title":"Colors","text":"<pre><code>namespace color {\n    constexpr mods::Color black;\n    constexpr mods::Color red;\n    constexpr mods::Color green;\n    constexpr mods::Color yellow;\n    constexpr mods::Color blue;\n    constexpr mods::Color magenta;\n    constexpr mods::Color cyan;\n    constexpr mods::Color white;\n    constexpr mods::Color bright_black;\n    constexpr mods::Color bright_red;\n    constexpr mods::Color bright_green;\n    constexpr mods::Color bright_yellow;\n    constexpr mods::Color bright_blue;\n    constexpr mods::Color bright_magenta;\n    constexpr mods::Color bright_cyan;\n    constexpr mods::Color bright_white;\n    constexpr mods::Color bold_black;\n    constexpr mods::Color bold_red;\n    constexpr mods::Color bold_green;\n    constexpr mods::Color bold_yellow;\n    constexpr mods::Color bold_blue;\n    constexpr mods::Color bold_magenta;\n    constexpr mods::Color bold_cyan;\n    constexpr mods::Color bold_white;\n    constexpr mods::Color bold_bright_black;\n    constexpr mods::Color bold_bright_red;\n    constexpr mods::Color bold_bright_green;\n    constexpr mods::Color bold_bright_yellow;\n    constexpr mods::Color bold_bright_blue;\n    constexpr mods::Color bold_bright_magenta;\n    constexpr mods::Color bold_bright_cyan;\n    constexpr mods::Color bold_bright_white;\n}\n</code></pre> <p>Modifiers that specify the color &amp; font of the serialized value.</p> <p>Note 1: Coloring mods are implemented using ANSI escape sequences.</p> <p>Note 2: When formatted by a sink with colors disabled, these modifiers will be ignored.</p> <p>Note 3: While ANSI color code support is not entirely ubiquitous, it is provided by most modern terminals.</p>"},{"location":"module_log.html#examples","title":"Examples","text":""},{"location":"module_log.html#basic-logging","title":"Basic logging","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\n// Log with a default global logger\nlog::info(\"Message 1\");\nlog::warn(\"Message 2\");\nlog::err (\"Message 3\");\n</code></pre> <p>Output:</p> <p></p> <p><code>latest.log</code>:</p> <pre><code>| ------------------------------------------------------------------------------------------\n| date -&gt; 2025-10-10 03:05:49\n| ------ | -------- | ----------------------------- | ----- | ------------------------------\n| thread |   uptime |                      callsite | level | message\n| ------ | -------- | ----------------------------- | ----- | ------------------------------\n| 0      |     0.00 |                     main:7    |  INFO | Message 1\n| 0      |     0.00 |                     main:8    |  WARN | Message 2\n| 0      |     0.00 |                     main:9    |   ERR | Message 3\n</code></pre>"},{"location":"module_log.html#logging-objects","title":"Logging objects","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\nconst auto start = std::chrono::steady_clock::now();\n\nlog::info(\"val = \"      , std::vector{2e-3, 3e-3, 4e-3}           );\nlog::warn(\"err = \"      , std::complex&lt;double&gt;{2e14, 3e28}        );\nlog::err (\"Finished in \", std::chrono::steady_clock::now() - start);\n</code></pre> <p>Output:</p> <p></p> <p><code>latest.log</code>:</p> <pre><code>| ------------------------------------------------------------------------------------------\n| date -&gt; 2025-10-10 02:58:38\n| ------ | -------- | ----------------------------- | ----- | ------------------------------\n| thread |   uptime |                      callsite | level | message\n| ------ | -------- | ----------------------------- | ----- | ------------------------------\n| 0      |     0.00 |                     main:10   |  INFO | val = [ 0.002, 0.003, 0.004 ]\n| 0      |     0.00 |                     main:11   |  WARN | err = 2e+14 + 3e+28i\n| 0      |     0.00 |                     main:12   |   ERR | Finished in 683 us 74 ns\n</code></pre>"},{"location":"module_log.html#formatting-modifiers_1","title":"Formatting modifiers","text":"<p>Tip</p> <p>The exact same syntax can be used with <code>println()</code> / <code>stringify()</code>, which is both performant and convenient even outside of logging.</p> <p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\nlog::note(\"Colored:        \", \"text\" | log::color::red                );\nlog::note(\"Left-aligned:   \", \"text\" | log::align_left(10)            );\nlog::note(\"Center-aligned: \", \"text\" | log::align_center(10)          );\nlog::note(\"Right-aligned:  \", \"text\" | log::align_right(10)           );\nlog::note(\"Fixed:          \", 2.3578 | log::fixed(2)                  );\nlog::note(\"Scientific:     \", 2.3578 | log::scientific(2)             );\nlog::note(\"Hex:            \", 2.3578 | log::hex(2)                    );\nlog::note(\"Base-2:         \", 1024   | log::base(2)                   );\nlog::note(\"Multiple:       \", 1024   | log::base(2) | log::color::blue);\n</code></pre> <p>Output:</p> <p></p> <p><code>latest.log</code>:</p> <pre><code>| ------------------------------------------------------------------------------------------\n| date -&gt; 2025-10-10 02:47:01\n| ------ | -------- | ----------------------------- | ----- | ------------------------------\n| thread |   uptime |                      callsite | level | message\n| ------ | -------- | ----------------------------- | ----- | ------------------------------\n| 0      |     0.00 |                     main:6    |  NOTE | Colored:        text\n| 0      |     0.00 |                     main:7    |  NOTE | Left-aligned:   text      \n| 0      |     0.00 |                     main:8    |  NOTE | Center-aligned:    text   \n| 0      |     0.00 |                     main:9    |  NOTE | Right-aligned:        text\n| 0      |     0.00 |                     main:10   |  NOTE | Fixed:          2.36\n| 0      |     0.00 |                     main:11   |  NOTE | Scientific:     2.36e+00\n| 0      |     0.00 |                     main:12   |  NOTE | Hex:            1.2ep+1\n| 0      |     0.00 |                     main:13   |  NOTE | Base-2:         10000000000\n| 0      |     0.00 |                     main:14   |  NOTE | Multiple:       10000000000\n</code></pre>"},{"location":"module_log.html#local-logger","title":"Local logger","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\n// Create a local logger\nauto logger = log::Logger{\n    log::Sink{\"log.txt\"},\n    log::Sink{std::cout}\n};\n\n// Use it\nlogger.info(\"Message\");\n</code></pre> <p>Output:</p> <p></p> <p><code>log.txt</code>:</p> <pre><code>| ------------------------------------------------------------------------------------------\n| date -&gt; 2025-10-10 03:08:24\n| ------ | -------- | ----------------------------- | ----- | ------------------------------\n| thread |   uptime |                      callsite | level | message\n| ------ | -------- | ----------------------------- | ----- | ------------------------------\n| 0      |     0.00 |                     main:13   |  INFO | Message\n</code></pre>"},{"location":"module_log.html#global-logger","title":"Global logger","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\n// Create global logger\nauto&amp; logger() {\n    static auto logger = log::Logger{\n        log::Sink{\"log.txt\"},\n        log::Sink{std::cout}\n    };\n\n    return logger;\n}\n\n// ...\n\n// Use it\nlogger().info(\"Message\");\n</code></pre> <p>Output:</p> <p></p> <p><code>log.txt</code>:</p> <pre><code>| ------------------------------------------------------------------------------------------\n| date -&gt; 2025-10-10 03:10:57\n| ------ | -------- | ----------------------------- | ----- | ------------------------------\n| thread |   uptime |                      callsite | level | message\n| ------ | -------- | ----------------------------- | ----- | ------------------------------\n| 0      |     0.00 |                     main:17   |  INFO | Message\n</code></pre>"},{"location":"module_log.html#sink-configuration","title":"Sink configuration","text":"<p>Tip</p> <p>Most of the time default configuration works well enough: stream sinks are colored and flush instantly, while file sinks are buffered, async and stripped of any color codes.</p> <p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\n// Verbose async file logger\nauto logger = log::Logger{\n    log::Sink&lt;\n        log::policy::Type::FILE,\n        log::policy::Level::TRACE,\n        log::policy::Color::NONE,\n        log::policy::Format::FULL,\n        log::policy::Buffering::FIXED,\n        log::policy::Flushing::ASYNC\n        log::policy::Threading::SAFE\n    &gt;{\"latest.log\"}\n};\n\nlogger.info(\"Message 1\");\nlogger.note(\"Message 2\");\nlogger.warn(\"Message 3\");\n</code></pre> <p><code>latest.log</code>:</p> <pre><code>| ------------------------------------------------------------------------------------------\n| date -&gt; 2025-10-10 03:12:56\n| ------ | -------- | ----------------------------- | ----- | ------------------------------\n| thread |   uptime |                      callsite | level | message\n| ------ | -------- | ----------------------------- | ----- | ------------------------------\n| 0      |     0.00 |                     main:19   |  INFO | Message 1\n| 0      |     0.00 |                     main:20   |  NOTE | Message 2\n| 0      |     0.00 |                     main:21   |  WARN | Message 3\n</code></pre>"},{"location":"module_log.html#extending-formatter-for-custom-types","title":"Extending formatter for custom types","text":"<p>Tip</p> <p>This can also be used to override behavior for types that are already supported, user-defined explicit specialization always gets higher priority.</p> <p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\n// Custom type\nstruct Vec3 { double x, y, z; };\n\n// Extend formatter to support 'Vec3'\ntemplate &lt;&gt;\nstruct log::Formatter&lt;Vec3&gt; {\n    template &lt;class Buffer&gt;\n    void operator()(Buffer&amp; buffer, const Vec3&amp; vec) {\n        Formatter&lt;const char*&gt;{}(buffer, \"Vec3{\");\n        Formatter&lt;     double&gt;{}(buffer, vec.x  );\n        Formatter&lt;const char*&gt;{}(buffer, \", \"   );\n        Formatter&lt;     double&gt;{}(buffer, vec.y  );\n        Formatter&lt;const char*&gt;{}(buffer, \", \"   );\n        Formatter&lt;     double&gt;{}(buffer, vec.z  );\n        Formatter&lt;const char*&gt;{}(buffer, \"}\"    );\n    }\n};\n\n// ...\n\n// Test\nassert(log::stringify(Vec3{1, 2, 3}) == \"Vec3{1, 2, 3}\");\n</code></pre>"},{"location":"module_log.html#extending-formatter-for-custom-type-traits","title":"Extending formatter for custom type traits","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\n// Several custom classes\nstruct Class1 { std::string to_string() const { return \"Class 1\"; }; };\nstruct Class2 { std::string to_string() const { return \"Class 2\"; }; };\nstruct Class3 { std::string to_string() const { return \"Class 3\"; }; };\n\n// Type trait corresponding to those classes\ntemplate &lt;class T, class = void&gt;\nstruct has_to_string : std::false_type {};\n\ntemplate &lt;class T&gt;\nstruct has_to_string&lt;T, std::void_t&lt;decltype(std::declval&lt;T&gt;().to_string())&gt;&gt; : std::true_type {};\n\n// Extend formatter to support anything that provides '.to_string()' member function\ntemplate &lt;class T&gt;\nstruct log::Formatter&lt;T, std::enable_if_t&lt;has_to_string&lt;T&gt;::value&gt;&gt; {\n    template &lt;class Buffer&gt;\n    void operator()(Buffer&amp; buffer, const T&amp; arg) {\n        Formatter&lt;std::string&gt;{}(buffer, arg.to_string());\n    }\n};\n\n// ...\n\n// Test\nassert(log::stringify(Class1{}) == \"Class 1\");\nassert(log::stringify(Class2{}) == \"Class 2\");\nassert(log::stringify(Class2{}) == \"Class 3\");\n</code></pre>"},{"location":"module_log.html#serialization-support","title":"Serialization support","text":"<p>Serialization of following types is supported out of the box:</p> <ul> <li>Character types</li> <li>Enumerations</li> <li><code>std::path</code> and anything else that provides <code>.string()</code></li> <li>Anything convertible to <code>std::string_view</code></li> <li>Anything convertible to <code>std::string</code></li> <li>Booleans</li> <li>Integers</li> <li>Floats</li> <li>Pointers</li> <li><code>std::complex</code> and anything else that provides <code>.real()</code> &amp; <code>.imag()</code></li> <li>Array-like types (anything that provides a forward iterator)</li> <li>Tuple-like types (anything that supports <code>std::get&lt;&gt;()</code> and <code>std::tuple_size_v&lt;&gt;</code>)</li> <li>Container adaptors (<code>std::queue</code>, <code>std::deque</code> and etc.)</li> <li><code>&lt;chrono&gt;</code> duration</li> <li>Anything printable with <code>std::ostream</code></li> <li>Nested containers and types that can be resolved recursively (such as <code>std::map</code>, <code>std::unordered_map</code> and etc.)</li> </ul> <p>Additional types added by fully or partially specializing the <code>Formatter&lt;&gt;</code>.</p>"},{"location":"module_log.html#compatibility-with-other-modules","title":"Compatibility with other modules","text":"<ul> <li>utl::assertion \u2012 can be set up to log assertion failures</li> <li>utl::enum_reflect \u2012 provides an easy way to serialize enums</li> <li>utl::struct_reflect \u2012 provides an easy way to serialize classes</li> <li>utl::table \u2012 provides a way to serialize tables</li> <li>utl::time \u2012 provides a way to serialize time and date in various formats</li> </ul>"},{"location":"module_math.html","title":"utl::math","text":""},{"location":"module_math.html#utlmath","title":"utl::math","text":"<p>&lt;- to README.md</p> <p>&lt;- to implementation.hpp</p> <p>utl::math header is a collection of mathematical utils that includes:</p> <ul> <li>Constants</li> <li>Template math</li> <li>Non-overflowing functions</li> <li>Index functions</li> <li>Conversions and etc.</li> </ul> <p>All implementations <code>template</code>, <code>constexpr</code> and <code>noexcept</code>.</p> <p>Note</p> <p>For a more \"complete\" mathematical library check out DmitriBogdanov/GSE.</p>"},{"location":"module_math.html#definitions","title":"Definitions","text":"<pre><code>// Constants\nnamespace constants {\n    constexpr double pi      = 3.14159265358979323846;\n    constexpr double two_pi  = 2.0 * pi;\n    constexpr double half_pi = 0.5 * pi;\n    constexpr double inv_pi  = 1.0 / pi;\n    constexpr double e       = 2.71828182845904523536;\n    constexpr double phi     = 1.61803398874989484820;\n}\n\n// Basic functions\ntemplate &lt;class T&gt; constexpr T       abs(T x) noexcept;\ntemplate &lt;class T&gt; constexpr T      sign(T x) noexcept;\ntemplate &lt;class T&gt; constexpr T     bsign(T x) noexcept;\ntemplate &lt;class T&gt; constexpr T       sqr(T x) noexcept;\ntemplate &lt;class T&gt; constexpr T      cube(T x) noexcept;\ntemplate &lt;class T&gt; constexpr T       inv(T x) noexcept;\ntemplate &lt;class T&gt; constexpr T heaviside(T x) noexcept;\n\n// Non-overflowing functions\ntemplate &lt;class T&gt; constexpr T midpoint(T a, T b) noexcept;\ntemplate &lt;class T&gt; constexpr T  absdiff(T a, T b) noexcept;\n\n// Power functions\ntemplate &lt;class T, class U&gt; constexpr T     pow(T x, U p) noexcept;\ntemplate &lt;         class U&gt; constexpr U signpow(     U p) noexcept;\n\n// Index functions\ntemplate &lt;class T&gt; constexpr T kronecker_delta(T i, T j     ) noexcept;\ntemplate &lt;class T&gt; constexpr T     levi_civita(T i, T j, T k) noexcept;\n\n// Conversions\ntemplate &lt;class T&gt; constexpr T deg_to_rad(T degrees) noexcept;\ntemplate &lt;class T&gt; constexpr T rad_to_deg(T radians) noexcept;\n\n// Sequence operations\ntemplate &lt;class Idx, class Func&gt; constexpr auto  sum(Idx low, Idx high, Func&amp;&amp; func);\ntemplate &lt;class Idx, class Func&gt; constexpr auto prod(Idx low, Idx high, Func&amp;&amp; func);\n</code></pre> <p>Note</p> <p>All methods have appropriate SFINAE-restrictions, which are omitted in documentation to reduce verbosity.</p>"},{"location":"module_math.html#methods","title":"Methods","text":""},{"location":"module_math.html#constants","title":"Constants","text":"<pre><code>namespace constants {\n    constexpr double pi      = 3.14159265358979323846;\n    constexpr double two_pi  = 6.28318530717958647693;\n    constexpr double half_pi = 1.57079632679489661923;\n    constexpr double inv_pi  = 0.31830988618379067153;\n    constexpr double sqrtpi  = 1.77245385090551602729;\n    constexpr double e       = 2.71828182845904523536;\n    constexpr double egamma  = 0.57721566490153286060;\n    constexpr double phi     = 1.61803398874989484820;\n    constexpr double ln2     = 0.69314718055994530942;\n    constexpr double ln10    = 2.30258509299404568402;\n    constexpr double sqrt2   = 1.41421356237309504880;\n    constexpr double sqrt3   = 1.73205080756887729352;\n}\n</code></pre> <p>Basic mathematical constants. In C++20 most of these get standardized as a part of <code>&lt;numbers&gt;</code> header.</p> Identifier Mathematical notation Reference <code>pi</code> \\(\\pi\\) Mathematical constant \u03c0 <code>two_pi</code> \\(2 \\pi\\) - <code>half_pi</code> \\(\\pi / 2\\) - <code>inv_pi</code> \\(1 / \\pi\\) - <code>sqrtpi</code> \\(\\sqrt{\\pi}\\) - <code>e</code> \\(e\\) Euler's number <code>egamma</code> \\(\\gamma\\) Euler\u2013Mascheroni constant <code>phi</code> \\(\\varphi\\) Golden ratio <code>ln2</code> \\(\\ln{2}\\) - <code>ln10</code> \\(\\ln{10}\\) - <code>sqrt2</code> \\(\\sqrt{2}\\) - <code>sqrt3</code> \\(\\sqrt{3}\\) -"},{"location":"module_math.html#basic-functions","title":"Basic functions","text":"<pre><code>template &lt;class T&gt; constexpr T       abs(T x) noexcept;\ntemplate &lt;class T&gt; constexpr T      sign(T x) noexcept;\ntemplate &lt;class T&gt; constexpr T     bsign(T x) noexcept;\ntemplate &lt;class T&gt; constexpr T       sqr(T x) noexcept;\ntemplate &lt;class T&gt; constexpr T      cube(T x) noexcept;\ntemplate &lt;class T&gt; constexpr T       inv(T x) noexcept;\ntemplate &lt;class T&gt; constexpr T heaviside(T x) noexcept;\n</code></pre> <p>Returns \\(|x|\\), \\(\\mathrm{sign} (x)\\), \\(x^2\\), \\(x^3\\), \\(x^{-1}\\), or \\(H(x)\\). </p> <p><code>T</code> can be of any arithmetic type except <code>bool</code>.</p> <p>To reduce integer division surprises, <code>inv()</code> also requires a floating point.</p> <p>Note 1: <code>sign()</code> is a standard sign function which returns \\(-1\\), \\(0\\) or \\(1\\). <code>bsign()</code> is a binary variation that returns \\(1\\) instead of \\(0\\).</p> <p>Note 2: \\(H(x)\\) refers to Heaviside step function.</p>"},{"location":"module_math.html#non-overflowing-functions","title":"Non-overflowing functions","text":"<pre><code>template &lt;class T&gt; constexpr T midpoint(T a, T b) noexcept;\ntemplate &lt;class T&gt; constexpr T  absdiff(T a, T b) noexcept;\n</code></pre> <p>Computes \\(\\dfrac{a + b}{2}\\) or \\(|a - b|\\) without potential overflow.</p> <p><code>T</code> can be of any arithmetic type except <code>bool</code>.</p> <p>Integer <code>midpoint()</code> rounds down in case of a fractional result.</p> <p>Note 1: Correctly computing integer / float <code>midpoint()</code> is trickier than it might initially seem, naive <code>(a + b) / 2</code> formula suffers multiple issues when applied to values near min / max of the given type.</p> <p>Note 2: Compared to integer <code>std::midpoint()</code> (which rounds towards <code>a</code>), integer <code>math::midpoint()</code> (which rounds down) is commutative and faster to compute. Floating point behavior is the same.</p>"},{"location":"module_math.html#power-functions","title":"Power functions","text":"<pre><code>template &lt;class T, class U&gt; constexpr T     pow(T x, U p) noexcept;\ntemplate &lt;         class U&gt; constexpr U signpow(     U p) noexcept;\n</code></pre> <p>Returns \\(x^p\\) or \\(-1^p\\) .</p> <p><code>T</code> can be of any arithmetic type except <code>bool</code>.</p> <p><code>U</code> can be of any integral type.</p> <p>Note: Computing <code>signpow(p)</code> is significantly faster than <code>std::pow(-1, p)</code>.</p>"},{"location":"module_math.html#index-functions","title":"Index functions","text":"<pre><code>template &lt;class T&gt; constexpr T kronecker_delta(T i, T j) noexcept;\n</code></pre> <p>Computes Kronecker delta symbol: <code>1</code> if <code>i == j</code>, <code>0</code> otherwise.</p> <p><code>T</code> can be of any integral type.</p> <pre><code>template &lt;class T&gt; constexpr T levi_civita(T i, T j, T k) noexcept;\n</code></pre> <p>Computes Levi-Civita symbol: <code>1</code> if <code>(i, j, k)</code> form an even permutation, <code>-1</code> if <code>(i, j, k)</code> form an odd permutation, and <code>0</code> if any the adjacent letters are equal.</p> <p><code>T</code> can be of any integral type.</p>"},{"location":"module_math.html#conversions","title":"Conversions","text":"<pre><code>template &lt;class T&gt; constexpr T deg_to_rad(T degrees) noexcept;\ntemplate &lt;class T&gt; constexpr T rad_to_deg(T radians) noexcept;\n</code></pre> <p>Converts degrees to radians and back.</p> <p><code>T</code> can be of any floating point type.</p>"},{"location":"module_math.html#sequence-operations","title":"Sequence operations","text":"<pre><code>template &lt;class Idx, class Func&gt; constexpr auto  sum(Idx low, Idx high, Func&amp;&amp; f);\ntemplate &lt;class Idx, class Func&gt; constexpr auto prod(Idx low, Idx high, Func&amp;&amp; f);\n</code></pre> <p>Computes \\(\\sum_{i = low}^{high} f(i)\\) or \\(\\prod_{i = low}^{high} f(i)\\).</p> <p><code>Idx</code> can be of any integral type.</p> <p><code>noexcept</code> when <code>f</code> is non-throwing.</p>"},{"location":"module_math.html#examples","title":"Examples","text":""},{"location":"module_math.html#template-math-functions","title":"Template math functions","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\nstatic_assert( math::abs      (-7 ) ==  7  );\nstatic_assert( math::sign     ( 0 ) ==  0  );\nstatic_assert( math::bsign    ( 0 ) ==  1  );\nstatic_assert( math::sqr      (-2 ) ==  4  );\nstatic_assert( math::cube     (-2 ) == -8  );\nstatic_assert( math::inv      ( 2.) == 0.5 );\nstatic_assert( math::heaviside( 2.) ==  1  );\n\nstatic_assert( math::midpoint(3, 5) == 4 );\nstatic_assert( math::absdiff (4, 7) == 3 );\n\nstatic_assert( math::pow    (2, 7) ==  128 );\nstatic_assert( math::signpow(  -5) == -1   );\n</code></pre>"},{"location":"module_math.html#index-functions_1","title":"Index functions","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\nstatic_assert( math::kronecker_delta(3, 4) == 0 );\nstatic_assert( math::kronecker_delta(3, 3) == 1 );\n\nstatic_assert( math::levi_civita(3, 4, 4) ==  0 );\nstatic_assert( math::levi_civita(3, 4, 5) ==  1 );\nstatic_assert( math::levi_civita(5, 4, 3) == -1 );\n</code></pre>"},{"location":"module_math.html#conversions_1","title":"Conversions","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\nstatic_assert( math::absdiff(math::deg_to_rad(180.), math::constants::pi) &lt; 1e-16  );\n\nstatic_assert( math::absdiff(math::rad_to_deg(math::constants::pi), 180.) &lt; 1e-16  );\n</code></pre>"},{"location":"module_math.html#summation-product","title":"Summation &amp; product","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\nconstexpr auto  sum = math::sum( 1, 3, [](int i){ return math::sqr(i); }); // 1^2 + 2^2 + 3^2\nconstexpr auto prod = math::prod(1, 3, [](int i){ return math::sqr(i); }); // 1^2 * 2^2 * 3^2\n\nstatic_assert(  sum == 1 + 4 + 9 );\nstatic_assert( prod == 1 * 4 * 9 );\n</code></pre>"},{"location":"module_math.html#newer-standards","title":"Newer standards","text":"<p>Some parts of this header can be replaced with <code>std</code> features in newer standards:</p> <ul> <li>C++20 adds mathematical constants as <code>&lt;numbers&gt;</code></li> <li>C++20 adds <code>std::midpoint()</code></li> <li>C++23 adds <code>constexpr</code> support to <code>&lt;cmath&gt;</code> functions</li> </ul>"},{"location":"module_mvl.html","title":"utl::mvl","text":""},{"location":"module_mvl.html#utlmvl-experimental","title":"utl::mvl (experimental)","text":"<p>&lt;- to README.md</p> <p>&lt;- to implementation.hpp</p> <p>utl::mvl (aka Matrix View Library) implements generic classes for dense/strided/sparse vectors, matrices and views.</p> <p>Unlike most existing matrix implementations, mvl focuses on data-oriented matrices that support arbitrary element types and can be used similarly to std::vector. It's main goal is the simplicity of API and interoperability with most existing implementations.</p> <p>Important</p> <p>Due to rather extensive API, seeing usage examples first might be helpful.</p> <p>Warning</p> <p>This module is currently experimental. It is generally functional, however there are no guarantees about its API, stability and documentation coverage.</p>"},{"location":"module_mvl.html#class-structure","title":"Class structure","text":"<p>All vectors, matrices and views in mvl stem from a single generic template class, that can be specialized into any available behavior through its template parameters: <pre><code>// Generic template\ntemplate &lt;\n    class       T,\n    Dimension   dimension,\n    Type        type,\n    Ownership   ownership,\n    Checking    checking,\n    Layout      layout\n&gt;\nclass GenericTensor;\n\n// Example of manual specialization\nusing IntegerMatrix = GenericTensor&lt;int, Dimension::MATRIX, Type::DENSE, Ownership::CONTAINER, Checking::NONE, Layout::RC&gt;;\n</code></pre></p> <p>Note</p> <p>Here tensor will be used to refer to arbitrary vectors, matrices and views, not necessarily in a mathematical sense.</p> <p>This approach provides a generic way of working with matrices that is mostly agnostic to underlying layout and implementation. In practical usage manual specialization is rarely needed due to provided typedefs, however it is a powerful tool for implementing generic APIs.</p> <p>Below in an overview of all available arguments, typedefs and defaults:</p> <p></p>"},{"location":"module_mvl.html#performance-linear-algebra-operations","title":"Performance &amp; linear algebra operations","text":"<p>mvl classes are intended to be lightweight wrappers that allow convenient data manipulation without any performance tradeoffs on basic operations (loops, indexing, standard algorithms, etc.), this is achieved through conditional compilation and compile-time resolution of all indexing formulas. See benchmarks for details.</p> <p>Due to its arbitrary-data approach, linear algebra operations are intentionally NOT implemented by mvl. Numeric computation is a separate field and is much better handled by existing libraries like XTensor, Eigen and Blaze. In cases where matrix computation is needed, it's heavily recommended to use matrices provided by those libraries as a main implementation, and whenever mvl functions are needed, those can be wrapped in mvl view. For example:</p> <pre><code>Eigen::MatrixXd A; // in Eigen col-major by default\n\n// Do some computation with 'A'\n\nmvl::MatrixView&lt;double, Checking::NONE, Layout::CR&gt; view(A.rows(), A.cols(), A.data());\n\n// Use 'view' like any other MVL matrix\n</code></pre>"},{"location":"module_mvl.html#definitions","title":"Definitions","text":"<p>Important</p> <p><code>requires</code> tag specifies methods that get conditionally compiled by some specializations.</p> <p>Important</p> <p><code>Callable&lt;Args...&gt;</code> is a shortcut for a template parameter, restricted to callable objects with specific signature.</p> <pre><code>// Generic template\ntemplate &lt;\n    class       T,\n    Dimension   dimension,\n    Type        type,\n    Ownership   ownership,\n    Checking    checking,\n    Layout      layout\n&gt;\nclass GenericTensor {\n    // - Parameter reflection -\n    struct params {\n        constexpr static Dimension   dimension\n        constexpr static Type        type;\n        constexpr static Ownership   ownership;\n        constexpr static Checking    checking;\n        constexpr static Layout      layout;\n    };\n\n    // - Member types -\n    using self            = GenericTensor;\n    using value_type      = T;\n    using size_type       = std::size_t;\n    using difference_type = std::ptrdiff_t;\n    using reference       = T&amp;;\n    using const_reference = const T&amp;;\n    using pointer         = T*;\n    using const_pointer   = const T*;\n\n    using owning_reflection = GenericTensor&lt;value_type, params::dimension, params::type,\n                                            Ownership::CONTAINER, params::checking, params::layout&gt;;\n\n    // - Iterators -\n    using               iterator;\n    using       reverse_iterator;\n    using         const_iterator;\n    using const_reverse_iterator;\n\n    iterator begin();\n    iterator   end();\n\n    reverse_iterator rbegin();\n    reverse_iterator   rend();\n\n    const_iterator  begin() const;\n    const_iterator    end() const;\n    const_iterator cbegin() const;\n    const_iterator   cend() const;\n\n    const_reverse_iterator  rbegin() const;\n    const_reverse_iterator    rend() const;\n    const_reverse_iterator crbegin() const;\n    const_reverse_iterator   crend() const;   \n\n    // - Basic getters -\n    size_type       size() const;\n    size_type       rows() const; // requires MATRIX\n    size_type       cols() const; // requires MATRIX\n    size_type row_stride() const; // requires MATRIX &amp;&amp; (DENSE || STRIDED)\n    size_type col_stride() const; // requires MATRIX &amp;&amp; (DENSE || STRIDED)\n\n    const_pointer  data() const; // requires DENSE || STRIDED\n    pointer        data();       // requires DENSE || STRIDED\n    bool          empty() const;\n\n    // - Advanced getters -\n    bool      contains(const_reference value) const; // requires value_type::operator==()\n    size_type    count(const_reference value) const; // requires value_type::operator==()\n\n    bool is_sorted()                                                     const; // requires value_type::operator&lt;()\n    bool is_sorted(Callable&lt;bool(const_reference, const_reference)&gt; cmp) const;\n\n    std::vector&lt;value_type&gt; to_std_vector() const;\n\n    self transposed() const; // requires MATRIX &amp;&amp; DENSE\n\n    self clone() const; // requires CONTAINER\n    self move() &amp;; // requires CONTAINER\n\n    // - Indexation -\n    const_reference front() const;\n    const_reference  back() const;\n    reference       front();\n    reference        back();\n\n    reference       operator[](size_type idx);\n    reference       operator()(size_type i);                    // [TODO:] requires VECTOR\n    reference       operator()(size_type i, size_type j);       // requires MATRIX\n    const_reference operator[](size_type idx)            const;\n    const_reference operator()(size_type i)              const; // [TODO:] requires VECTOR\n    const_reference operator()(size_type i, size_type j) const; // requires MATRIX\n\n    // - Index conversions -\n    size_type get_idx_of_ij(size_type i, size_type j) const; // requires MATRIX\n    Index2D   get_ij_of_idx(size_type idx)            const; // requires MATRIX\n\n    bool contains_index(size_type i, size_type j) const; // requires MATRIX &amp;&amp; SPARSE\n\n    size_type extent_major() const; // requires MATRIX &amp;&amp; (DENSE || STRIDED)\n    size_type extent_minor() const; // requires MATRIX &amp;&amp; (DENSE || STRIDED)\n\n    // - Reductions -\n    value_type     sum() const; // requires value_type::operator+()\n    value_type product() const; // requires value_type::operator*()\n    value_type     min() const; // requires value_type::operator&lt;()\n    value_type     max() const; // requires value_type::operator&lt;()\n\n    // - Predicate operations -\n    bool true_for_any(Callable&lt;bool(const_reference)&gt;                       predicate) const;\n    bool true_for_any(Callable&lt;bool(const_reference, size_type)&gt;            predicate) const; // [TODO:] requires VECTOR\n    bool true_for_any(Callable&lt;bool(const_reference, size_type, size_type)&gt; predicate) const; // requires MATRIX\n    bool true_for_all(Callable&lt;bool(const_reference)&gt;                       predicate) const;\n    bool true_for_all(Callable&lt;bool(const_reference, size_type)&gt;            predicate) const; // [TODO:] requires VECTOR\n    bool true_for_all(Callable&lt;bool(const_reference, size_type, size_type)&gt; predicate) const; // requires MATRIX\n\n    // - Const algorithms -\n    const self&amp; for_each(Callable&lt;void(const_reference)&gt;                       func) const;\n    const self&amp; for_each(Callable&lt;void(const_reference, size_type)&gt;            func) const; // [TODO:] requires VECTOR\n    const self&amp; for_each(Callable&lt;void(const_reference, size_type, size_type)&gt; func) const; // requires MATRIX\n\n    // - Mutating algorithms -\n    self&amp; for_each(Callable&lt;void(reference)&gt;                       func);\n    self&amp; for_each(Callable&lt;void(reference, size_type)&gt;            func); // [TODO:] requires VECTOR\n    self&amp; for_each(Callable&lt;void(reference, size_type, size_type)&gt; func); // requires MATRIX\n\n    self&amp; transform(Callable&lt;value_type(const_reference)&gt;                       func);\n    self&amp; transform(Callable&lt;value_type(const_reference, size_type)&gt;            func); // [TODO:] requires VECTOR\n    self&amp; transform(Callable&lt;value_type(const_reference, size_type, size_type)&gt; func); // requires MATRIX\n\n    self&amp; fill(const_reference value);\n\n    self&amp; fill(Callable&lt;value_type()&gt;                       func);\n    self&amp; fill(Callable&lt;value_type(), size_type&gt;            func); // [TODO:] requires VECTOR\n    self&amp; fill(Callable&lt;value_type(), size_type, size_type&gt; func); // requires MATRIX\n\n    self&amp;        sort(); // requires value_type::operator&lt;()\n    self&amp; stable_sort(); // requires value_type::operator&lt;()\n    self&amp;        sort(Callable&lt;bool(const_reference, const_reference)&gt; cmp);\n    self&amp; stable_sort(Callable&lt;bool(const_reference, const_reference)&gt; cmp);\n\n    // - Block Subviews -\n    using block_view_type;\n    using block_const_view_type;\n\n    block_view_type       block(size_type i, size_type j, size_type rows, size_type cols);       // requires MATRIX\n    block_const_view_type block(size_type i, size_type j, size_type rows, size_type cols) const; // requires MATRIX\n\n    block_view_type       row();       // requires MATRIX\n    block_const_view_type row() const; // requires MATRIX\n\n    block_view_type       col();       // requires MATRIX\n    block_const_view_type col() const; // requires MATRIX\n\n    // - Sparse Subviews -\n    using sparse_view_type;\n    using sparse_const_view_type;\n\n    sparse_view_type filter(Callable&lt;bool(const_reference)&gt;                       predicate);\n    sparse_view_type filter(Callable&lt;bool(const_reference, size_type)&gt;            predicate); // [TODO:] requires VECTOR\n    sparse_view_type filter(Callable&lt;bool(const_reference, size_type, size_type)&gt; predicate); // requires MATRIX\n\n    sparse_const_view_type filter(Callable&lt;bool(const_reference)&gt;                       predicate) const;\n    sparse_const_view_type filter(Callable&lt;bool(const_reference, size_type)&gt;            predicate) const; // [TODO:] requires VECTOR\n    sparse_const_view_type filter(Callable&lt;bool(const_reference, size_type, size_type)&gt; predicate) const; // requires MATRIX\n\n    sparse_view_type       diagonal();       // requires MATRIX\n    sparse_const_view_type diagonal() const; // requires MATRIX\n\n    // - Sparse operations - (requires SPARSE)\n    using sparse_entry_type;\n\n    self&amp; rewrite_triplets(      std::vector&lt;triplet_type&gt;&amp;&amp; triplets); // requires MATRIX\n    self&amp;  insert_triplets(const std::vector&lt;triplet_type&gt;&amp;  triplets); // requires MATRIX\n    self&amp;   erase_triplets(      std::vector&lt;Index2D     &gt;   indices ); // requires MATRIX\n\n    // - Constructors -\n    // Note: Lots of entries in this section, \n    // following full documentation looks more digestible\n\n    // Default\n    GenericTensor(); // requires CONTAINER\n\n    // Copy/move\n    GenericTensor(  const self&amp;  other);\n    GenericTensor(        self&amp;&amp; other);\n    self&amp; operator=(const self&amp;  other);\n    self&amp; operator=(      self&amp;&amp; other);\n\n    // Copy over template parameter boundaries\n    template &lt;Type other_type, Ownership other_ownership, Checking other_checking, Layout other_layout&gt;\n    GenericTensor(  const GenericTensor&lt;...&gt;&amp;  other);\n    template &lt;Type other_type, Ownership other_ownership, Checking other_checking, Layout other_layout&gt;\n    self&amp; operator=(const GenericTensor&lt;...&gt;&amp;  other);\n\n    // Move over template parameter boundaries\n    template &lt;Checking other_checking&gt;\n    GenericTensor(  GenericTensor&lt;...&gt;&amp;&amp; other);\n    template &lt;Checking other_checking&gt;\n    self&amp; operator=(GenericTensor&lt;...&gt;&amp;&amp; other);\n\n    // 'Matrix' ctors (requires MATRIX &amp;&amp; DENSE &amp;&amp; CONTAINER)\n    explicit GenericTensor(size_type rows, size_type cols, const_reference value = value_type());\n    explicit GenericTensor(size_type rows, size_type cols, Callable&lt;value_type(size_type, size_type)&gt; init_func);\n    explicit GenericTensor(size_type rows, size_type cols, pointer data_ptr);\n    GenericTensor(std::initializer_list&lt;std::initializer_list&lt;value_type&gt;&gt; init_list);\n\n    // 'MatrixView' ctors (requires MATRIX &amp;&amp; DENSE &amp;&amp; VIEW)\n    explicit GenericTensor(size_type rows, size_type cols, pointer data_ptr);\n    template&lt;Ownership other_ownership, Checking other_checking, Layout other_layout&gt;\n    GenericTensor(const GenericTensor&lt;...&gt;&amp; other);\n\n    // 'ConstMatrixView' ctors (requires MATRIX &amp;&amp; DENSE &amp;&amp; CONST_VIEW)\n    explicit GenericTensor(size_type rows, size_type cols, const_pointer data_ptr);\n    template&lt;Ownership other_ownership, Checking other_checking, Layout other_layout&gt;\n    GenericTensor(const GenericTensor&lt;...&gt;&amp; other);\n\n    // 'StridedMatrix' ctors (requires MATRIX &amp;&amp; DENSE &amp;&amp; CONTAINER)\n    explicit GenericTensor(size_type rows, size_type cols, size_type row_stride, size_type col_stride,const_reference value = value_type());\n    explicit GenericTensor(size_type rows, size_type cols, size_type row_stride, size_type col_stride, Callable&lt;value_type(size_type, size_type)&gt; init_func);\n    explicit GenericTensor(size_type rows, size_type cols, size_type row_stride, size_type col_stride, pointer data_ptr);\n    GenericTensor(std::initializer_list&lt;std::initializer_list&lt;value_type&gt;&gt; init_list, size_type row_stride, size_type col_stride);\n\n    // 'StridedMatrixView' ctors (requires MATRIX &amp;&amp; DENSE &amp;&amp; VIEW)\n    explicit GenericTensor(size_type rows, size_type cols, size_type row_stride, size_type col_stride, pointer data_ptr);\n    template&lt;Ownership other_ownership, Checking other_checking, Layout other_layout&gt;\n    GenericTensor(const GenericTensor&lt;...&gt;&amp; other);\n\n    // 'ConstStridedMatrixView' ctors (requires MATRIX &amp;&amp; DENSE &amp;&amp; CONST_VIEW)\n    explicit GenericTensor(size_type rows, size_type cols, size_type row_stride, size_type col_stride, const_pointer data_ptr);\n    template&lt;Ownership other_ownership, Checking other_checking, Layout other_layout&gt;\n    GenericTensor(const GenericTensor&lt;...&gt;&amp; other);\n\n    // Sparse ctors (requires MATRIX &amp;&amp; DENSE)\n    explicit GenericTensor(size_type rows, size_type cols, const std::vector&lt;triplet_type&gt;&amp; data);\n    explicit GenericTensor(size_type rows, size_type cols, std::vector&lt;triplet_type&gt;&amp;&amp; data);\n};\n\n// - Tensor IO formats -\nnamespace format {\n    // Human-readable formats\n    std::string as_vector(    const GenericTensor&lt;Args...&gt; &amp;tensor);\n    std::string as_matrix(    const GenericTensor&lt;Args...&gt; &amp;tensor);\n    std::string as_dictionary(const GenericTensor&lt;Args...&gt; &amp;tensor);\n    // Export formats\n    std::string as_raw_text(  const GenericTensor&lt;Args...&gt; &amp;tensor);\n    std::string as_json_array(const GenericTensor&lt;Args...&gt; &amp;tensor);\n}\n\n// - Linear algebra operators -\n// Note:: In all operators below 'owning_reflection' is a shortcut for 'typename std::decay&lt;L&gt;::owning_reflection'\n\n// Unary operators\ntemplate &lt;class L&gt; owning_reflection operator+(L&amp;&amp; left);\ntemplate &lt;class L&gt; owning_reflection operator-(L&amp;&amp; left);\n\ntemplate &lt;class L, class Op&gt; owning_reflection apply_unary_op(L&amp;&amp; left, Op&amp;&amp; op);\n\n// Binary operators\ntemplate &lt;class L, class R&gt; owning_reflection           operator+(L&amp;&amp; left, R&amp;&amp; right);\ntemplate &lt;class L, class R&gt; owning_reflection           operator-(L&amp;&amp; left, R&amp;&amp; right);\ntemplate &lt;class L, class R&gt; owning_reflection elementwise_product(L&amp;&amp; left, R&amp;&amp; right);\n\ntemplate &lt;class L, class R&gt; owning_reflection operator*(const L&amp; left, const R&amp; right);\n\ntemplate &lt;class L, class R, class Op&gt; owning_reflection apply_binary_op(L&amp;&amp; left, R&amp;&amp; right, Op&amp;&amp; op);\n\n// Augmented assignment operators\ntemplate &lt;class L, class R&gt; L&amp; operator+=(L&amp;&amp; left, R&amp;&amp; right);\ntemplate &lt;class L, class R&gt; L&amp; operator-=(L&amp;&amp; left, R&amp;&amp; right);\n\n// - Typedefs -\ntemplate &lt;typename T, Checking checking = Checking::NONE, Layout layout = Layout::RC&gt;\nusing Matrix = GenericTensor&lt;T, Dimension::MATRIX, Type::DENSE, Ownership::CONTAINER, checking, layout&gt;;\n\ntemplate &lt;typename T, Checking checking = Checking::NONE, Layout layout = Layout::RC&gt;\nusing MatrixView = GenericTensor&lt;T, Dimension::MATRIX, Type::DENSE, Ownership::VIEW, checking, layout&gt;;\n\ntemplate &lt;typename T, Checking checking = Checking::NONE, Layout layout = Layout::RC&gt;\nusing ConstMatrixView = GenericTensor&lt;T, Dimension::MATRIX, Type::DENSE, Ownership::CONST_VIEW, checking, layout&gt;;\n\ntemplate &lt;typename T, Checking checking = Checking::NONE, Layout layout = Layout::RC&gt;\nusing StridedMatrix = GenericTensor&lt;T, Dimension::MATRIX, Type::STRIDED, Ownership::CONTAINER, checking, layout&gt;;\n\ntemplate &lt;typename T, Checking checking = Checking::NONE, Layout layout = Layout::RC&gt;\nusing StridedMatrixView = GenericTensor&lt;T, Dimension::MATRIX, Type::STRIDED, Ownership::VIEW, checking, layout&gt;;\n\ntemplate &lt;typename T, Checking checking = Checking::NONE, Layout layout = Layout::RC&gt;\nusing ConstStridedMatrixView = GenericTensor&lt;T, Dimension::MATRIX, Type::STRIDED, Ownership::CONST_VIEW, checking, layout&gt;;\n\ntemplate &lt;typename T, Checking checking = Checking::NONE&gt;\nusing SparseMatrix = GenericTensor&lt;T, Dimension::MATRIX, Type::SPARSE, Ownership::CONTAINER, checking, Layout::SPARSE&gt;;\n\ntemplate &lt;typename T, Checking checking = Checking::NONE&gt;\nusing SparseMatrixView = GenericTensor&lt;T, Dimension::MATRIX, Type::SPARSE, Ownership::VIEW, checking, Layout::SPARSE&gt;;\n\ntemplate &lt;typename T, Checking checking = Checking::NONE&gt;\nusing ConstSparseMatrixView = GenericTensor&lt;T, Dimension::MATRIX, Type::SPARSE, Ownership::CONST_VIEW, checking, Layout::SPARSE&gt;;\n</code></pre> <p>Note</p> <p><code>noexcept</code> specifiers are omitted in this section to reduce verbosity.</p> <p>Note</p> <p>From now on <code>mvl::GenericTensor::</code> will be omitted for the same reason.</p>"},{"location":"module_mvl.html#methods","title":"Methods","text":""},{"location":"module_mvl.html#parameter-reflection","title":"Parameter reflection","text":"<pre><code>struct params {\n    constexpr static Dimension   dimension\n    constexpr static Type        type;\n    constexpr static Ownership   ownership;\n    constexpr static Checking    checking;\n    constexpr static Layout      layout;\n};\n</code></pre> <p>Compile-time reflection of template parameters defining current <code>GenericTensor</code>.</p> <p>Useful for implementing templates over tensor types and conditional compilation  (for example, template over <code>TensorType</code> can use <code>if constexpr (TensorType::params::dimension == Dimension::MATRIX) {}</code> to conditionally enable logic for matrices).</p>"},{"location":"module_mvl.html#member-types","title":"Member types","text":"<pre><code>using self            = GenericTensor;\nusing value_type      = T;\nusing size_type       = std::size_t;\nusing difference_type = std::ptrdiff_t;\nusing reference       = T&amp;;\nusing const_reference = const T&amp;;\nusing pointer         = T*;\nusing const_pointer   = const T*;\n</code></pre> <p>A set of member types analogous to member types of std::vector.</p> <pre><code>using owning_reflection = GenericTensor&lt;value_type, params::dimension, params::type,\n                                           Ownership::CONTAINER, params::checking, params::layout&gt;;\n</code></pre> <p>Reflection of the tensor type with <code>ownership</code> set to <code>CONTAINER</code>.</p> <p>This is a return type of most algebraic operators, for example, addition <code>MatrixView&lt;T&gt; + MatrixView&lt;T&gt;</code> logically produces a <code>Matrix&lt;T&gt;</code>. See the table below for reference:</p> <code>GenericTensor</code> <code>GenericTensor::owning_reflection</code> <code>Matrix&lt;T&gt;</code> or <code>MatrixView&lt;T&gt;</code> or <code>ConstMatrixView&lt;T&gt;</code> <code>Matrix&lt;T&gt;</code> <code>StridedMatrix&lt;T&gt;</code> or <code>StridedMatrixView&lt;T&gt;</code> or <code>ConstStridedMatrixView&lt;T&gt;</code> <code>StridedMatrix&lt;T&gt;</code> <code>SparseMatrix&lt;T&gt;</code> or <code>SparseMatrixView&lt;T&gt;</code> or <code>ConstSparseMatrixView&lt;T&gt;</code> <code>SparseMatrix&lt;T&gt;</code>"},{"location":"module_mvl.html#iterators","title":"Iterators","text":"<pre><code>using               iterator;\nusing       reverse_iterator;\nusing         const_iterator;\nusing const_reverse_iterator;\n\niterator begin();\niterator   end();\n\nreverse_iterator rbegin();\nreverse_iterator   rend();\n\nconst_iterator  begin() const;\nconst_iterator    end() const;\nconst_iterator cbegin() const;\nconst_iterator   cend() const;\n\nconst_reverse_iterator  rbegin() const;\nconst_reverse_iterator    rend() const;\nconst_reverse_iterator crbegin() const;\nconst_reverse_iterator   crend() const;\n</code></pre> <p>Iterators for 1D iteration over the underlying array. API and functionality is exactly the same as the one provided by <code>std::vector</code> iterators.</p>"},{"location":"module_mvl.html#basic-getters","title":"Basic getters","text":"<pre><code>size_type size() const;\n</code></pre> <p>Returns the number of elements stored by the tensor. Size of the underlying array.</p> <p>Note: While <code>size() == rows() * cols()</code> is a valid assumption for dense matrices, the same cannot be said about the sparse case.</p> <pre><code>size_type rows() const; // requires MATRIX\nsize_type cols() const; // requires MATRIX\n</code></pre> <p>Returns number of rows/columns in the matrix.</p> <pre><code>size_type row_stride() const; // requires MATRIX &amp;&amp; (DENSE || STRIDED)\nsize_type col_stride() const; // requires MATRIX &amp;&amp; (DENSE || STRIDED)\n</code></pre> <p>Returns strides of the matrix.</p> <p>Note 1: Most linear algebra libraries use only one stride per matrix. In context of the <code>Layout::RC</code> that \"conventional\" stride will correspond to <code>col_stride()</code>. <code>row_stride()</code> denotes the number of elements which get \"skipped\" by indexing after the end of each row. Using two strides like this gives us a more general way of viewing into data, particularly in regard to blocking.</p> <p>Note 2: Dense non-strided matrices return trivial strides to accommodate API's that can work with both dense and strided inputs. There is no overhead from using actual unit-strides. What constitutes as \"trivial strides\" can be seen in the table below:</p> Matrix type Layout Trivial <code>row_stride()</code> / <code>col_stride()</code> <code>DENSE</code> <code>RC</code> 0 / 1 <code>DENSE</code> <code>CR</code> 1 / 0 <pre><code>const_pointer  data() const; // requires DENSE || STRIDED\npointer        data();       // requires DENSE || STRIDED\n</code></pre> <p>Returns the pointer to the underlying array.</p> <pre><code>bool empty() const;\n</code></pre> <p>Returns whether there are any elements stored in the tensor.</p>"},{"location":"module_mvl.html#advanced-getters","title":"Advanced getters","text":"<pre><code>bool contains(const_reference value) const; // requires value_type::operator==()\n</code></pre> <p>Returns whether matrix contains element equal to <code>value</code>.</p> <pre><code>size_type count(const_reference value) const; // requires value_type::operator==()\n</code></pre> <p>Returns number of matrix elements equal to<code>value</code>.</p> <pre><code>bool is_sorted()                                                     const; // requires value_type::operator&lt;()\nbool is_sorted(Callable&lt;bool(const_reference, const_reference)&gt; cmp) const;\n</code></pre> <p>Returns whether the underlying array is sorted. Uses <code>operator&lt;</code> to perform comparison by default, callable <code>cmp</code> can be passed to use a custom comparison instead.</p> <pre><code>std::vector&lt;value_type&gt; to_std_vector() const;\n</code></pre> <p>Returns a copy of the underlying array as <code>std::vector</code>.</p> <pre><code>self transposed() const; // requires MATRIX &amp;&amp; DENSE\n</code></pre> <p>Returns transpose of the matrix.</p> <pre><code>self clone() const; // requires CONTAINER\n</code></pre> <p>Returns a copy of the tensor.</p> <p>Useful when chaining mutating operations on a tensor with intent of saving the result to a new variable without modifying the original tensor. For example, <code>auto s = tensor.clone().transform(f).sum()</code> will apply function <code>f</code> to the tensor and sum the elements into <code>s</code> without modifying the original <code>tensor</code>.</p> <pre><code>self move() &amp;; // requires CONTAINER\n</code></pre> <p>Returns <code>std::move(*this)</code>. This is useful to avoid a copy when initializing objects with method chaining.</p> <p>See corresponding example.</p>"},{"location":"module_mvl.html#indexation","title":"Indexation","text":"<pre><code>const_reference front() const;\nconst_reference  back() const;\nreference       front();\nreference        back();\n</code></pre> <p>Returns first/last element from the underlying 1D representation of the tensor.</p> <pre><code>reference       operator[](size_type idx);\nconst_reference operator[](size_type idx) const;\n</code></pre> <p>Returns element number <code>idx</code> from the underlying 1D representation of the tensor.</p> <pre><code>reference       operator()(size_type i);                    // requires VECTOR\nconst_reference operator()(size_type i)              const; // requires VECTOR\nreference       operator()(size_type i, size_type j);       // requires MATRIX\nconst_reference operator()(size_type i, size_type j) const; // requires MATRIX\n</code></pre> <p>Returns element <code>i</code> (for vectors) or element <code>(i, j)</code> (for matrices) according to a logical index.</p> <p>Note: <code>operator()</code> is a default way of indexing tensors and should be used in vast majority of cases, the main purpose of <code>operator[]</code> is to allow efficient looping over the underlying data when uniform transforms are applied. It is a good idea to prefer <code>operator()</code> even for 1D vectors since in some cases (like sparse vectors) logical index <code>i</code> may not be the same as \"in-memory index\" <code>idx</code>.</p>"},{"location":"module_mvl.html#index-conversions","title":"Index conversions","text":"<pre><code>size_type get_idx_of_ij(size_type i, size_type j) const; // requires MATRIX\nIndex2D   get_ij_of_idx(size_type idx)            const; // requires MATRIX\n</code></pre> <p>Conversion between the underlying index <code>idx</code> and logical index <code>(i, j)</code> for matrices.</p> <pre><code>bool contains_index(size_type i, size_type j) const; // requires MATRIX &amp;&amp; SPARSE\n</code></pre> <p>Returns whether sparse matrix contains an element with a given index.</p> <pre><code>size_type extent_major() const; // requires MATRIX &amp;&amp; (DENSE || STRIDED)\nsize_type extent_minor() const; // requires MATRIX &amp;&amp; (DENSE || STRIDED)\n</code></pre> <p>Returns dense matrix extents according to a memory layout. For example: with a row-major layout (aka <code>Layout::RC</code>) <code>extent_major()</code> will return the number of rows and <code>extent_minor()</code> will return the number of columns.</p> <p>This is useful for creating generic logic for different layouts.</p>"},{"location":"module_mvl.html#reductions","title":"Reductions","text":"<pre><code>value_type     sum() const; // requires value_type::operator+()\nvalue_type product() const; // requires value_type::operator*()\nvalue_type     min() const; // requires value_type::operator&lt;()\nvalue_type     max() const; // requires value_type::operator&lt;()\n</code></pre> <p>Reduces matrix over a binary operation <code>+</code>, <code>*</code>, <code>min</code> or <code>max</code>.</p> <p>Particularly useful in combination with subviews.</p>"},{"location":"module_mvl.html#predicate-operations","title":"Predicate operations","text":"<pre><code>bool true_for_any(Callable&lt;bool(const_reference)&gt;                       predicate) const;\nbool true_for_any(Callable&lt;bool(const_reference, size_type)&gt;            predicate) const; // requires VECTOR\nbool true_for_any(Callable&lt;bool(const_reference, size_type, size_type)&gt; predicate) const; // requires MATRIX\n</code></pre> <p>Returns whether  <code>predicate</code> evaluates to <code>true</code> for any elements in the tensor.</p> <p>Overloads (2) and (3) allow predicates to also take element index into condition.</p> <pre><code>bool true_for_all(Callable&lt;bool(const_reference)&gt;                       predicate) const;\nbool true_for_all(Callable&lt;bool(const_reference, size_type)&gt;            predicate) const; // requires VECTOR\nbool true_for_all(Callable&lt;bool(const_reference, size_type, size_type)&gt; predicate) const; // requires MATRIX\n</code></pre> <p>Returns whether  <code>predicate</code> evaluates to <code>true</code> for all elements in the tensor.</p> <p>Overloads (2) and (3) allow predicates to also take element index into condition.</p>"},{"location":"module_mvl.html#const-algorithms","title":"Const algorithms","text":"<pre><code>const self&amp; for_each(Callable&lt;void(const_reference)&gt;                       func) const;\nconst self&amp; for_each(Callable&lt;void(const_reference, size_type)&gt;            func) const; // requires VECTOR\nconst self&amp; for_each(Callable&lt;void(const_reference, size_type, size_type)&gt; func) const; // requires MATRIX\n</code></pre> <p>Invokes non-mutating <code>func</code> for all elements in the tensor. </p> <p>Overloads (2) and (3) allow <code>func</code> to also use element index as an argument.</p>"},{"location":"module_mvl.html#mutating-algorithms","title":"Mutating algorithms","text":"<pre><code>self&amp; for_each(Callable&lt;void(reference)&gt;                       func);\nself&amp; for_each(Callable&lt;void(reference, size_type)&gt;            func); // requires VECTOR\nself&amp; for_each(Callable&lt;void(reference, size_type, size_type)&gt; func); // requires MATRIX\n</code></pre> <p>Invokes mutating <code>func</code> for all elements in the tensor. </p> <p>Overloads (2) and (3) allow <code>func</code> to also use element index as an argument.</p> <pre><code>self&amp; transform(Callable&lt;value_type(const_reference)&gt;                       func);\nself&amp; transform(Callable&lt;value_type(const_reference, size_type)&gt;            func); // requires VECTOR\nself&amp; transform(Callable&lt;value_type(const_reference, size_type, size_type)&gt; func); // requires MATRIX\n</code></pre> <p>Set <code>element</code> to <code>func(element)</code> for all element of the tensor.</p> <p>Overloads (2) and (3) allow <code>func</code> to also use element index as an argument.</p> <pre><code>self&amp; fill(const_reference value);\n</code></pre> <p>Sets all elements of the tensor to <code>value</code>.</p> <pre><code>self&amp; fill(Callable&lt;value_type()&gt;                       func);\nself&amp; fill(Callable&lt;value_type(), size_type&gt;            func); // requires VECTOR\nself&amp; fill(Callable&lt;value_type(), size_type, size_type&gt; func); // requires MATRIX\n</code></pre> <p>Sets all elements of the tensor to a value returned by <code>func()</code>.</p> <p>Overloads (2) and (3) allow <code>func</code> to also use element index as an argument.</p> <pre><code>self&amp;        sort(); // requires value_type::operator&lt;()\nself&amp; stable_sort(); // requires value_type::operator&lt;()\nself&amp;        sort(Callable&lt;bool(const_reference, const_reference)&gt; cmp);\nself&amp; stable_sort(Callable&lt;bool(const_reference, const_reference)&gt; cmp);\n</code></pre> <p>Sorts elements of the underlying array according to <code>operator&lt;</code> or a custom comparison <code>cmp</code>.</p> <p><code>stable_sort()</code> uses stable sorting algorithms to maintain the relative order of entries with equal values, however it may come at a cost of some performance (specifics depend on a compiler implementation).</p>"},{"location":"module_mvl.html#block-subviews","title":"Block subviews","text":"<pre><code>using block_view_type;\nusing block_const_view_type;\n</code></pre> <p>Types returned by blocking subview methods of the tensor.</p> <p>Dense and strided matrices will use appropriately strided views to efficiently represent blocking, while sparse matrices returns sparse views.</p> <p>All subviews inherit <code>T</code>, <code>Dimension</code> and <code>Checking</code> configuration from the parent.</p> <pre><code>block_view_type       block(size_type i, size_type j, size_type rows, size_type cols);        // requires MATRIX\nblock_const_view_type block(size_type i, size_type j, size_type rows, size_type cols) const;  // requires MATRIX\n</code></pre> <p>Returns block subview starting at <code>(i, j)</code> with size <code>rows</code> x <code>cols</code>. </p> <pre><code>block_view_type       row(size_type i);       // requires MATRIX\nblock_const_view_type row(size_type i) const; // requires MATRIX\n</code></pre> <p>Returns block subview corresponding to the <code>i</code>-th row.</p> <pre><code>block_view_type       col(size_type j);       // requires MATRIX\nblock_const_view_type col(size_type j) const; // requires MATRIX\n</code></pre> <p>Returns block subview corresponding to the <code>j</code>-th column.</p>"},{"location":"module_mvl.html#sparse-subviews","title":"Sparse subviews","text":"<pre><code>using sparse_view_type;\nusing sparse_const_view_type;\n</code></pre> <p>Types returned by sparse subview methods of the tensor.</p> <p>Evaluate to appropriate sparse tensor views that inherits <code>T</code>, <code>Dimension</code> and <code>Checking</code> configuration from the parent.</p> <pre><code>sparse_view_type filter(Callable&lt;bool(const_reference)&gt;                       predicate);\nsparse_view_type filter(Callable&lt;bool(const_reference, size_type)&gt;            predicate); // requires VECTOR\nsparse_view_type filter(Callable&lt;bool(const_reference, size_type, size_type)&gt; predicate); // requires MATRIX\n</code></pre> <p>Returns a sparse view to all elements satisfying the <code>predicate</code>.</p> <p>Overloads (2) and (3) allow predicates to also take element index into condition.</p> <pre><code>sparse_const_view_type filter(Callable&lt;bool(const_reference)&gt;                       predicate) const;\nsparse_const_view_type filter(Callable&lt;bool(const_reference, size_type)&gt;            predicate) const; // requires VECTOR\nsparse_const_view_type filter(Callable&lt;bool(const_reference, size_type, size_type)&gt; predicate) const; // requires MATRIX\n</code></pre> <p><code>const</code> version of the previous method.</p> <pre><code>sparse_view_type       diagonal();       // requires MATRIX\nsparse_const_view_type diagonal() const; // requires MATRIX\n</code></pre> <p>Returns sparse view to a matrix diagonal.</p>"},{"location":"module_mvl.html#sparse-operations","title":"Sparse operations","text":"<pre><code>using sparse_entry_type; // requires SPARSE\n</code></pre> <p><code>index</code> + <code>value</code> entry type corresponding to a sparse  tensor (aka pairs for vector and triplets for matrices). Such entries are used to initialize and fill sparse matrices with values (similarly to the vast majority of other sparse matrix implementation).</p> <p>A table of appropriate sparse entry types can be seen below:</p> Tensor dimension Ownership Value of <code>sparse_entry_type</code> <code>VECTOR</code> <code>CONTAINER</code> <code>SparseEntry1D&lt;value_type&gt;&gt;</code> <code>VECTOR</code> <code>VIEW</code> <code>SparseEntry1D&lt;std::reference_wrapper&lt;value_type&gt;&gt;</code> <code>VECTOR</code> <code>CONST_VIEW</code> <code>SparseEntry1D&lt;std::reference_wrapper&lt;const value_type&gt;&gt;</code> <code>MATRIX</code> <code>CONTAINER</code> <code>SparseEntry2D&lt;value_type&gt;&gt;</code> <code>MATRIX</code> <code>VIEW</code> <code>SparseEntry2D&lt;std::reference_wrapper&lt;value_type&gt;&gt;</code> <code>MATRIX</code> <code>CONST_VIEW</code> <code>SparseEntry2D&lt;std::reference_wrapper&lt;const value_type&gt;&gt;</code> <pre><code>self&amp; rewrite_triplets(std::vector&lt;triplet_type&gt;&amp;&amp; triplets); // requires MATRIX &amp;&amp; SPARSE\n</code></pre> <p>Replaces all existing entries in the sparse matrix with given <code>triplets</code>. </p> <pre><code>self&amp; insert_triplets(const std::vector&lt;triplet_type&gt;&amp;  triplets); // requires MATRIX &amp;&amp; SPARSE\n</code></pre> <p>Inserts given <code>triplets</code> into a sparse matrix.</p> <pre><code>self&amp; erase_triplets(std::vector&lt;Index2D&gt; indices ); // requires MATRIX &amp;&amp; SPARSE\n</code></pre> <p>Erases entries with given <code>indices</code> from the sparse matrix.</p>"},{"location":"module_mvl.html#linear-algebra-operators","title":"Linear algebra operators","text":""},{"location":"module_mvl.html#unary-operators","title":"Unary operators","text":"<pre><code>// Unary operators\ntemplate &lt;class L&gt; owning_reflection operator+(L&amp;&amp; left);\ntemplate &lt;class L&gt; owning_reflection operator-(L&amp;&amp; left);\n</code></pre> <p>Returns the result of applying unary operator <code>+</code> or <code>-</code> to all elements of the tensor <code>left</code>.</p> <p>Operators are only compiled if <code>value_type</code> of the tensor supports a corresponding unary operator.</p> <p>Note: Here and in all other methods of this section <code>owning_reflection</code> is a shortcut name for <code>typename std::decay&lt;L&gt;::owning_reflection</code>. This type represents the fact that while we can perform algebraic operations on matrix views, the resulting matrix will be a proper \"owning\" one.</p> <pre><code>template &lt;class L, class Op&gt; owning_reflection apply_unary_op(L&amp;&amp; left, Op&amp;&amp; op);\n</code></pre> <p>A generic function for applying unary operator <code>op</code> to all elements of the tensor <code>left</code>.</p>"},{"location":"module_mvl.html#binary-operators","title":"Binary operators","text":"<pre><code>// Binary operators\ntemplate &lt;class L, class R&gt; owning_reflection           operator+(L&amp;&amp; left, R&amp;&amp; right);\ntemplate &lt;class L, class R&gt; owning_reflection           operator-(L&amp;&amp; left, R&amp;&amp; right);\ntemplate &lt;class L, class R&gt; owning_reflection elementwise_product(L&amp;&amp; left, R&amp;&amp; right);\n</code></pre> <p>Returns the result of applying binary operator <code>+</code>, <code>-</code> or <code>*</code> to all pairs of elements in <code>left</code> and <code>right</code> tensors.</p> <p>Operators are only compiled if <code>value_type</code> of both tensors is the same and supports a corresponding binary operator.</p> <p>Note 1: Both binary and unary operators will reuse r-value arguments to avoid allocations if possible. This means that a long chain of operators like <code>A + B + C - (-D)</code> will usually only allocate once and then propagate that temporary throughout the chain, only computing the actual operations.</p> <p>Note 2: All operators are aware of matrix sparsity and will select appropriate implementations. Implementations have following time complexities:</p> Type of <code>L</code> Type of <code>R</code> Element-wise binary operator complexity <code>DENSE</code> or <code>STRIDED</code> <code>DENSE</code> or <code>STRIDED</code> \\(O(N^2)\\) <code>DENSE</code> or <code>STRIDED</code> <code>SPARSE</code> \\(O(N)\\) <code>SPARSE</code> <code>DENSE</code> or <code>STRIDED</code> \\(O(N)\\) <code>SPARSE</code> <code>SPARSE</code> \\(O(N)\\) <pre><code>template &lt;class L, class R, class Op&gt; owning_reflection apply_binary_op(L&amp;&amp; left, R&amp;&amp; right, Op&amp;&amp; op);\n</code></pre> <p>A generic function for applying binary operator <code>op</code> to all elements of the tensor <code>left</code>.</p> <pre><code>template &lt;class L, class R&gt; owning_reflection operator*(const L&amp; left, const R&amp; right);\n</code></pre> <p>Returns the matrix product \\(c_{ij} = \\sum_{k = 1}^{N} a_{ik} b_{kj}\\).</p> <p>Operator is only compiled if <code>value_type</code> of both tensors is the same and supports operators <code>+=</code> and <code>*</code>.</p> <p>Note 1: Matrix product is aware of matrix memory layout and will select the appropriate iteration order. Loop tiling is used to improve cache efficiency at large sizes. It should be noted however that <code>mvl</code> is not a linear algebra library at its core and will be significantly outperformed by dedicated BLAS routines in the task of number crunching.</p> <p>Note 2: Matrix product is aware of matrix sparsity and will select appropriate implementations. Implementations have following time complexities:</p> Type of <code>L</code> Type of <code>R</code> Matrix product complexity <code>DENSE</code> or <code>STRIDED</code> <code>DENSE</code> or <code>STRIDED</code> \\(O(N^3)\\) <code>DENSE</code> or <code>STRIDED</code> <code>SPARSE</code> \\(O(N^2)\\) <code>SPARSE</code> <code>DENSE</code> or <code>STRIDED</code> \\(O(N^2)\\) <code>SPARSE</code> <code>SPARSE</code> \\(O(N)\\)"},{"location":"module_mvl.html#augmented-assignment-operators","title":"Augmented assignment operators","text":"<p>```cpp // Augmented assignment operators template  L&amp; operator+=(L&amp;&amp; left, R&amp;&amp; right); template  L&amp; operator-=(L&amp;&amp; left, R&amp;&amp; right); <p>TODO: This behavior is not yet finalized, there are still some considerations to make.</p>"},{"location":"module_mvl.html#tensor-io-formats","title":"Tensor IO formats","text":"<pre><code>// Human-readable formats\nstd::string mvl::format::as_vector(    const GenericTensor&lt;...&gt; &amp;tensor);\nstd::string mvl::format::as_matrix(    const GenericTensor&lt;...&gt; &amp;tensor);\nstd::string mvl::format::as_dictionary(const GenericTensor&lt;...&gt; &amp;tensor);\n// Export formats\nstd::string mvl::format::as_raw_text(  const GenericTensor&lt;...&gt; &amp;tensor);\nstd::string mvl::format::as_json_array(const GenericTensor&lt;...&gt; &amp;tensor);\n</code></pre> <p>Converts tensor to string, formatted according to a chosen schema. All formats accept arbitrary tensors and properly handle sparse matrices.</p> Method Output <code>as_vector</code> Human-readable format. Formats tensor as a flat array of values. <code>as_matrix</code> Human-readable format. Formats tensor as a 1- or 2-D matrix. Missing sparse matrix entries are marked with <code>-</code>. <code>as_dictionary</code> Human-readable format. Formats tensor as a list of <code>key</code>-<code>value</code> pairs. Useful for sparse matrices. <code>as_raw_text</code> Export format. Formats tensor as a raw data separated by spaces and newlines (in case of matrices). <code>as_json_array</code> Export format. Formats tensor as a 1- or 2-D JSON array. <p>See corresponding example to get a better idea of what each output looks like.</p> <p>Note 1: Stringification works for any type with an existing <code>operator&lt;&lt;(std::ostream&amp;, const T&amp;)</code> overload.</p> <p>Note 2: <code>as_json_array</code> assumes that <code>operator&lt;&lt;(std::ostream&amp;, const T&amp;)</code> produces a string, corresponding to a valid JSON object. By default, <code>mvl</code> knows how to properly handle all built-in numeric, logical and string types, user-defined types have to handle their formatting themselves.</p> <p>Note 3: Human-readable formats automatically collapse matrices above a certain \"readable\" size (70+ rows or 40+ columns for <code>as_matrix</code>, 500+ elements for <code>as_vector</code> and <code>as_dictionary</code>).</p>"},{"location":"module_mvl.html#constructors","title":"Constructors","text":""},{"location":"module_mvl.html#generic-constructors","title":"Generic constructors","text":"<pre><code>GenericTensor(); // requires CONTAINER\n</code></pre> <p>Default-initializes an empty tensor. Only provided for containers, since views cannot exist without a target to view into.</p> <pre><code>GenericTensor(  const self&amp;  other);\nGenericTensor(        self&amp;&amp; other);\nself&amp; operator=(const self&amp;  other);\nself&amp; operator=(      self&amp;&amp; other);\n</code></pre> <p>Copy/move constructors and assignment operators for tensors of the same type.</p> <pre><code>template &lt;Type other_type, Ownership other_ownership, Checking other_checking, Layout other_layout&gt;\nGenericTensor(  const GenericTensor&lt;...&gt;&amp;  other);\n\ntemplate &lt;Type other_type, Ownership other_ownership, Checking other_checking, Layout other_layout&gt;\nself&amp; operator=(const GenericTensor&lt;...&gt;&amp;  other);\n</code></pre> <p>Converting copy constructor/assignment operator for tensors that have different types.</p> <p>Copy-conversion freely converts over the boundaries of <code>type</code>, <code>ownership</code>, <code>checking</code> and <code>layout</code>. It may use non-trivial logic to perform a \"logical copy\" for matrices with different APIs, such as, for example, convert sparse matrix to dense by cloning all the sparse contents and setting the other elements to default value, or, for example, construct sparse matrix from dense by filtering out all default-initialized elements and using the remainder as sparse contents (see an example of working with sparse matrices).</p> <pre><code>template &lt;Checking other_checking&gt;\nGenericTensor(  GenericTensor&lt;...&gt;&amp;&amp; other);\n\ntemplate &lt;Checking other_checking&gt;\nself&amp; operator=(GenericTensor&lt;...&gt;&amp;&amp; other);\n</code></pre> <p>Converting move constructor/assignment operator for tensors that have different types, yet can logically be converted to each other.</p> <p>Note that move-conversion is more restricting than copy-conversion due to move-semantics requiring both matrices to have a compatible memory layout of .</p>"},{"location":"module_mvl.html#matrix-constructors","title":"<code>Matrix</code> constructors","text":"<pre><code>explicit GenericTensor(size_type rows, size_type cols, const_reference value = value_type());\n</code></pre> <p>Constructs a <code>rows</code> by <code>cols</code> matrix with elements initialized to <code>value</code>.</p> <pre><code>explicit GenericTensor(size_type rows, size_type cols, Callable&lt;value_type(size_type, size_type)&gt; init_func);\n</code></pre> <p>Constructs a <code>rows</code> by <code>cols</code> matrix with elements initialized to <code>init_func(i, j)</code>.</p> <pre><code>explicit GenericTensor(size_type rows, size_type cols, pointer data_ptr);\n</code></pre> <p>Takes ownership of <code>C</code> array <code>data_ptr</code> and constructs a <code>rows</code> by <code>cols</code> matrix over it.</p> <pre><code>GenericTensor(std::initializer_list&lt;std::initializer_list&lt;value_type&gt;&gt; init_list);\n</code></pre> <p>Constructs matrix from a braced list: <code>{ { ... }, ... , { ... } }</code>.</p>"},{"location":"module_mvl.html#matrixview-constructors","title":"<code>MatrixView</code> constructors","text":"<pre><code>explicit GenericTensor(size_type rows, size_type cols, pointer data_ptr);\n</code></pre> <p>Constructs a <code>rows</code> by <code>cols</code> matrix view into the data stored at <code>data_ptr</code>.</p> <pre><code>template&lt;Ownership other_ownership, Checking other_checking, Layout other_layout&gt;\nGenericTensor(const GenericTensor&lt;...&gt;&amp; other);\n</code></pre> <p>Constructs a matrix view into another dense <code>mvl</code> matrix.</p>"},{"location":"module_mvl.html#constmatrixview-constructors","title":"<code>ConstMatrixView</code> constructors","text":"<pre><code>explicit GenericTensor(size_type rows, size_type cols, const_pointer data_ptr);\n</code></pre> <p>Constructs a <code>rows</code> by <code>cols</code> const  matrix view into the data stored at <code>data_ptr</code>.</p> <pre><code>template&lt;Ownership other_ownership, Checking other_checking, Layout other_layout&gt;\nGenericTensor(const GenericTensor&lt;...&gt;&amp; other);\n</code></pre> <p>Constructs a const matrix view into another dense <code>mvl</code> matrix.</p>"},{"location":"module_mvl.html#stridedmatrix-constructors","title":"<code>StridedMatrix</code> constructors","text":"<pre><code>explicit GenericTensor(size_type rows, size_type cols, size_type row_stride, size_type col_stride, const_reference value = value_type());\n</code></pre> <p>Constructs a <code>rows</code> by <code>cols</code> matrix with given strides and all elements initialized to <code>value</code>. </p> <p>Note 1: See \"Basic getters\" section to learn how row- and col- strides work in <code>mvl</code>.</p> <p>Note 2: Strides are usually used in the context of views. In case of an owning matrix strides function as an additional padding between elements, while rarely directly useful, in some cases it can be used to reduce cache misses caused by a particularly \"unlucky\" alignment of rows relative to a cache size.</p> <pre><code>explicit GenericTensor(size_type rows, size_type cols, size_type row_stride, size_type col_stride, Callable&lt;value_type(size_type, size_type)&gt; init_func);\n</code></pre> <p>Constructs a <code>rows</code> by <code>cols</code> matrix with given strides and all elements initialized to <code>init_func(i, j)</code>.</p> <pre><code>explicit GenericTensor(size_type rows, size_type cols, size_type row_stride, size_type col_stride, pointer data_ptr);\n</code></pre>"},{"location":"module_mvl.html#stridedmatrixview-constructors","title":"<code>StridedMatrixView</code> constructors","text":"<pre><code>explicit GenericTensor(size_type rows, size_type cols, size_type row_stride, size_type col_stride, pointer data_ptr);\n</code></pre> <p>Constructs a <code>rows</code> by <code>cols</code> strided matrix view into the data stored at <code>data_ptr</code>.</p> <pre><code>template&lt;Ownership other_ownership, Checking other_checking, Layout other_layout&gt;\nGenericTensor(const GenericTensor&lt;...&gt;&amp; other);\n</code></pre> <p>Constructs a strided matrix view into another strided <code>mvl</code> matrix.</p>"},{"location":"module_mvl.html#conststridedmatrixview-constructors","title":"<code>ConstStridedMatrixView</code> constructors","text":"<pre><code>explicit GenericTensor(size_type rows, size_type cols, size_type row_stride, size_type col_stride, const_pointer data_ptr);\n</code></pre> <p>Constructs a <code>rows</code> by <code>cols</code> const strided matrix view into the data stored at <code>data_ptr</code>.</p> <pre><code>template&lt;Ownership other_ownership, Checking other_checking, Layout other_layout&gt;\nGenericTensor(const GenericTensor&lt;...&gt;&amp; other);\n</code></pre> <p>Constructs a const strided matrix view into another strided <code>mvl</code> matrix.</p>"},{"location":"module_mvl.html#sparsematrix-constructors","title":"SparseMatrix constructors","text":"<pre><code>// pass triplets by copy\nexplicit GenericTensor(size_type rows, size_type cols, const std::vector&lt;sparse_entry_type&gt;&amp;  data);\n// pass triplets with move-semantics\nexplicit GenericTensor(size_type rows, size_type cols,       std::vector&lt;sparse_entry_type&gt;&amp;&amp; data);\n</code></pre> <p>Constructs a <code>rows</code> by <code>cols</code> sparse matrix from a list of <code>{ i, j, value }</code> triplets.</p> <p>If triplets aren't intended to be reused, they can be passed with <code>std::move()</code> for a faster construction.</p> <p>These constructors are valid for both owning sparse matrices and views, with the only difference being the expected <code>sparse_entry_type</code> (note that this is a member type of the tensor class, it can always be used directly as provided). Below is the table detailing possible triplet types for each ownership:</p> Ownership Value of <code>sparse_entry_type</code> <code>CONTAINER</code> <code>SparseEntry2D&lt;value_type&gt;</code> <code>VIEW</code> <code>SparseEntry2D&lt;std::reference_wrapper&lt;value_type&gt;&gt;</code> <code>CONST_VIEW</code> <code>SparseEntry2D&lt;std::reference_wrapper&lt;const value_type&gt;&gt;</code> <p>Here <code>mvl::SparseEntry2D&lt;T&gt;</code> is a simple POD struct:</p> <pre><code>template &lt;typename T&gt;\nstruct SparseEntry2D {\n    size_t i;\n    size_t j;\n    T      value;\n};\n</code></pre>"},{"location":"module_mvl.html#examples","title":"Examples","text":""},{"location":"module_mvl.html#declaring-and-indexing-a-matrix","title":"Declaring and indexing a matrix","text":"<pre><code>using namespace utl;\n\n// Declare regular dense matrix\nmvl::Matrix&lt;int&gt; A = {\n    { 1, 2, 3 },\n    { 4, 5, 6 }\n};\n\n// 2D indexation\nassert( A(0, 1) == 2 );\n\n// 1D indexation\nassert( A[2] == 3 );\n\n// Range-based loops\nfor (const auto &amp;element : A) assert( element &gt; 0 );\n\n// std::vector-like API &amp; iterators\nassert(  A.front()       == 1 );\nassert(  A.back()        == 6 );\nassert( *A.cbegin()      == 1 );\nassert( *(A.cend() - 1)  == 6 );\n\n// Basic getters\nassert( A.rows()  == 2     );\nassert( A.cols()  == 3     );\nassert( A.size()  == 6     );\nassert( A.empty() == false );\n\n// Declare matrix with enabled bound-checking\nmvl::Matrix&lt;int, mvl::Checking::BOUNDS&gt; B = A;\n\n// B(3, 2) = 1; // will throw with a message \"i (which is 3) &gt;= this-&gt;rows() (which is 2)\"\n</code></pre>"},{"location":"module_mvl.html#io-formats","title":"IO formats","text":"<pre><code>using namespace utl;\n\n// Create sparse matrix from triplets\nmvl::SparseMatrix&lt;double&gt; mat(3, 4,\n{\n    {0, 0, 3.14    },\n    {0, 1, 4.24    },\n    {1, 1, 7.15    },\n    {2, 2, 2.38    },\n    {2, 3, 734.835 }\n});\n\n// Showcase different IO formats\nstd::cout\n    // Human-readable formats\n    &lt;&lt; \"\\n## as_vector() ##\\n\\n\"     &lt;&lt; mvl::format::as_vector(    mat)\n    &lt;&lt; \"\\n## as_matrix() ##\\n\\n\"     &lt;&lt; mvl::format::as_matrix(    mat)\n    &lt;&lt; \"\\n## as_dictionary() ##\\n\\n\" &lt;&lt; mvl::format::as_dictionary(mat)\n    // Export formats\n    &lt;&lt; \"\\n## as_raw_text() ##\\n\\n\"   &lt;&lt; mvl::format::as_raw_text(  mat)\n    &lt;&lt; \"\\n## as_json_array() ##\\n\\n\" &lt;&lt; mvl::format::as_json_array(mat);\n\n// Human-readable formats will automatically collapse matrices above certain size to following format:\n// &gt; Tensor [size = 250000] (500 x 500):\n// &gt;   &lt;hidden due to large size&gt;\n</code></pre> <p>Output: <pre><code>## as_vector() ##\n\nTensor [size = 5] (3 x 4):\n  { 3.14, 4.24, 7.15, 2.38, 734.835 }\n\n## as_matrix() ##\n\nTensor [size = 5] (3 x 4):\n  [ 3.14 4.24    -       - ]\n  [    - 7.15    -       - ]\n  [    -    - 2.38 734.835 ]\n\n## as_dictionary() ##\n\nTensor [size = 5] (3 x 4):\n  (0, 0) = 3.14\n  (0, 1) = 4.24\n  (1, 1) = 7.15\n  (2, 2) = 2.38\n  (2, 3) = 734.835\n\n## as_raw_text() ##\n\n3.14 4.24 0 0 \n0 7.15 0 0 \n0 0 2.38 734.835\n\n## as_json_array() ##\n\n[\n  [ 3.14, 4.24,    0,       0 ], \n  [    0, 7.15,    0,       0 ], \n  [    0,    0, 2.38, 734.835 ] \n]\n</code></pre></p>"},{"location":"module_mvl.html#initializing-a-matrix-by-chaining-operations","title":"Initializing a matrix by chaining operations","text":"<pre><code>using namespace utl;\n\nstd::random_device         rd;    \nstd::default_random_engine gen(rd());\nstd::normal_distribution   dist(0., 1.);\n\nconst auto rand_value = [&amp;]()        { return dist(gen);   };\nconst auto abs        = [&amp;](double x){ return std::abs(x); };\n\n// Build 5x5 matrix where {a_ij} = |N(0, 1)|\n// '.move()' avoids a copy when assigning 'A'\nauto A = mvl::Matrix&lt;double&gt;(5, 5).fill(rand_value).transform(abs).move();\n\nstd::cout &lt;&lt; mvl::format::as_matrix(A);\n</code></pre> <p>Output: <pre><code>Tensor [size = 25] (5 x 5):\n  [ 0.592525 0.378606  1.94445 0.724242 0.0230773 ]\n  [ 0.854804 0.578115  2.33575  1.10363   1.24067 ]\n  [ 0.731419 0.870693 0.681755 0.446197  0.136237 ]\n  [ 0.889649  1.84099  1.17115  0.45199  0.506486 ]\n  [ 0.915286 0.287618 0.638074 0.489174    1.1951 ]\n</code></pre></p>"},{"location":"module_mvl.html#wrapping-external-data-into-views","title":"Wrapping external data into views","text":"<pre><code>using namespace utl;\n\n// Some raw data\n// (for example, received from an external 'C' library)\n// (let's also assume it's immutable and uses col-major layout for added challenge)\nconst float  data[] = { 1.f, 2.f, 3.f, 4.f, 5.f, 6.f };\nconst size_t rows   = 2;\nconst size_t cols   = 3;\n\n// Wrap data into MVL view and use it as a regular matrix\nmvl::ConstMatrixView&lt;float, mvl::Checking::NONE, mvl::Layout::CR&gt; A(\n    rows, cols, data\n);\n\n// This makes MVL easily compatible with almost every 3rd party\n// matrix library, views merely wrap around external data and expose\n// MVL matrix functionality with no copying/conversion overhead\n</code></pre>"},{"location":"module_mvl.html#usage-with-utlmath","title":"Usage with <code>utl::math</code>","text":"<pre><code>using namespace utl;\n\n// Create 7x7 identity matrix\nauto A = mvl::Matrix&lt;double&gt;(7, 7, math::kronecker_delta&lt;size_t&gt;);\n\n// Compute ||A||_inf norm\nconst auto norm = A.clone().transform(math::abs&lt;double&gt;).sum();\n\n// Compute tr(A)\nconst auto tr = A.diagonal().sum();\n\n// Split matrix into block views\nauto upper_half = A.block(0, 0,            0, A.size() / 2 - 1 );\nauto lower_half = A.block(0, 0, A.size() / 2, A.size() - 1     );\n\n// Set diagonal to { 1, 2, 3, ... , N }\nA.diagonal().for_each([](double &amp;elem, size_t i, size_t){ elem = i + 1; });\n\n// Evenly mesh [0, PI] x [0, 2 PI] with 100 intervals on each side\n// and save the 2D grid as a matrix\nusing vertex_t = std::pair&lt;double, double&gt;;\nauto  x        = math::linspace(0., math::PI,     math::Intervals(100));\nauto  y        = math::linspace(0., math::PI_TWO, math::Intervals(100));\nauto  grid     = mvl::Matrix&lt;vertex_t&gt;(x.size(), y.size(), [&amp;](size_t i, size_t j){ return vertex_t{ x[i], y[j] }; });\n</code></pre>"},{"location":"module_mvl.html#working-with-images","title":"Working with images","text":"<pre><code>using namespace utl;\n\n// Raw image RGB data\n// (outputted by most image decoders)\nconst uint8_t* data     = { /* ... */ };\nconst size_t   channels = 3;\nconst size_t   w        = 300;\nconst size_t   h        = 200;\n\n// View into R-G-B channels of an image as individual matrices\nmvl::ConstStridedMatrixView&lt;uint8_t&gt; R(w, h, 0, channels, data + 0);\nmvl::ConstStridedMatrixView&lt;uint8_t&gt; G(w, h, 0, channels, data + 1);\nmvl::ConstStridedMatrixView&lt;uint8_t&gt; B(w, h, 0, channels, data + 2);\n\n// Convert image to grayscale using linear formula\nmvl::Matrix&lt;uint8_t&gt; grayscale(w, h, [&amp;](size_t i, size_t j){\n    return 0.2126 * R(i, j)  + 0.7152 * G(i, j) + 0.0722 * B(i, j);\n});\n</code></pre>"},{"location":"module_mvl.html#working-with-sparse-matrices","title":"Working with sparse matrices","text":"<pre><code>using namespace utl;\n\n// Create sparse matrix from triplets\nmvl::SparseMatrix&lt;int&gt; A(3, 3, {\n    {0, 0, 1},\n    {1, 1, 2},\n    {2, 2, 3}\n});\n\n// Check that sparse matrix contains an element\nassert( A.contains_index(1, 1) == true  );\nassert( A.contains_index(1, 2) == false );\n\n// Convert sparse matrix to dense\nmvl::Matrix&lt;int&gt;        dense_A = A;\n// Convert dense matrix to sparse\nmvl::SparseMatrix&lt;int&gt; sparse_A = dense_A;\n\nstd::cout\n    &lt;&lt; \"\\n## A (sparse) ##\\n\\n\"                    &lt;&lt; mvl::format::as_matrix(       A)\n    &lt;&lt; \"\\n## A (sparse converted to dense) ##\\n\\n\" &lt;&lt; mvl::format::as_matrix( dense_A)\n    &lt;&lt; \"\\n## A (dense converted to sparse) ##\\n\\n\" &lt;&lt; mvl::format::as_matrix(sparse_A);\n</code></pre> <p>Output: <pre><code>## A (sparse) ##\n\nTensor [size = 3] (3 x 3):\n  [ 1 - - ]\n  [ - 2 - ]\n  [ - - 3 ]\n\n## A (sparse converted to dense) ##\n\nTensor [size = 9] (3 x 3):\n  [ 1 0 0 ]\n  [ 0 2 0 ]\n  [ 0 0 3 ]\n\n## A (dense converted to sparse) ##\n\nTensor [size = 3] (3 x 3):\n  [ 1 - - ]\n  [ - 2 - ]\n  [ - - 3 ]\n</code></pre></p>"},{"location":"module_mvl.html#roadmap-for-v100-release","title":"Roadmap for v1.0.0 release","text":"<ul> <li>Allow usage of static matrix extents</li> <li>Vector specializations</li> <li>Sparse matrices with a different \"default element\"</li> <li>Binary element-wise operators <code>+</code>, <code>-</code>, <code>*</code>, <code>+=</code>, <code>-=</code>, <code>*=</code> and etc.</li> <li>Matrix multiplication</li> <li>Matrix concatenation</li> <li>Additional algorithms: <code>sample()</code>, <code>shuffle()</code>, <code>clamp()</code> and etc.</li> <li>Benchmarks</li> </ul>"},{"location":"module_parallel.html","title":"utl::parallel","text":""},{"location":"module_parallel.html#utlparallel","title":"utl::parallel","text":"<p>&lt;- to README.md</p> <p>&lt;- to implementation.hpp</p> <p>utl::parallel module is a lightweight threading library providing API somewhat similar to Intel TBB.</p> <p>It implements classic building blocks of concurrent algorithms such as tasks, parallel for, reductions and etc. and provides a sane thread pool implementation with work-stealing and recursive parallelism support, in summary:</p> <ul> <li>Tasks, parallel loops and reductions</li> <li>Work-stealing thread pool with a fully thread-safe API</li> <li>Support for recursive parallelism</li> <li>Focus on simple &amp; uniform API</li> <li>Small (~<code>600</code> lines of code)</li> <li>Portable (no platform-specific code of any kind)</li> </ul> <p>Tip</p> <p>Benchmarks and usage examples can be found at the bottom.</p>"},{"location":"module_parallel.html#definitions","title":"Definitions","text":"<pre><code>// Scheduler\ntemplate &lt;class Backend = ThreadPool&gt;\nstruct Scheduler {\n    // Backend\n    Backend backend; // underlying thread pool\n\n    template &lt;class T = void&gt;\n    using future_type = typename Backend::future_type&lt;T&gt;;\n\n    template &lt;class... Args&gt;\n    explicit Scheduler(Args&amp;&amp;... args);\n\n    // Task API\n    template &lt;class F, class... Args&gt;           void  detached_task(F&amp;&amp; f, Args&amp;&amp;... args);\n    template &lt;class F, class... Args&gt; future_type&lt;R&gt; awaitable_task(F&amp;&amp; f, Args&amp;&amp;... args);\n\n    // Parallel-for API\n    template &lt;class It, class F&gt;          void  detached_loop(Range&lt;It&gt; range, F&amp;&amp; f);\n    template &lt;class It, class F&gt;          void  blocking_loop(Range&lt;It&gt; range, F&amp;&amp; f);\n    template &lt;class It, class F&gt; future_type&lt;&gt; awaitable_loop(Range&lt;It&gt; range, F&amp;&amp; f);\n\n    template &lt;class Idx, class F&gt;          void  detached_loop(IndexRange&lt;Idx&gt; range, F&amp;&amp; f);\n    template &lt;class Idx, class F&gt;          void  blocking_loop(IndexRange&lt;Idx&gt; range, F&amp;&amp; f);\n    template &lt;class Idx, class F&gt; future_type&lt;&gt; awaitable_loop(IndexRange&lt;Idx&gt; range, F&amp;&amp; f);\n\n    template &lt;class Container, class F&gt;          void  detached_loop(Container&amp;&amp; container, F&amp;&amp; f);\n    template &lt;class Container, class F&gt;          void  blocking_loop(Container&amp;&amp; container, F&amp;&amp; f);\n    template &lt;class Container, class F&gt; future_type&lt;&gt; awaitable_loop(Container&amp;&amp; container, F&amp;&amp; f);\n\n    // Parallel-reduce API\n    template &lt;class It, class Op&gt;             R   blocking_reduce(Range&lt;It&gt; range, Op&amp;&amp; op);\n    template &lt;class It, class Op&gt; future_type&lt;R&gt; awaitable_reduce(Range&lt;It&gt; range, Op&amp;&amp; op);\n\n    template &lt;class Container, class Op&gt;             R   blocking_reduce(Container&amp;&amp; container, Op&amp;&amp; op);\n    template &lt;class Container, class Op&gt; future_type&lt;R&gt; awaitable_reduce(Container&amp;&amp; container, Op&amp;&amp; op);\n};\n\n// Thread pool\nstruct ThreadPool {\n    // Initialization\n    explicit ThreadPool(std::size_t count = hardware_concurrency());\n\n    // Threading\n    void        set_thread_count(std::size_t count = hardware_concurrency());\n    std::size_t get_thread_count();\n\n    // Task queuing\n    template &lt;class F, class... Args&gt;           void  detached_task(F&amp;&amp; f, Args&amp;&amp;... args);\n    template &lt;class F, class... Args&gt; future_type&lt;R&gt; awaitable_task(F&amp;&amp; f, Args&amp;&amp;... args);\n\n    void wait();\n\n    // Future\n    template &lt;class T = void&gt; future_type { /* Same API as std::future&lt;T&gt; */ };\n};\n\ntemplate &lt;class T = void&gt;\nusing Future = ThreadPool::future_type&lt;T&gt;;\n\n// Ranges\ntemplate &lt;class It&gt;\nstruct Range {\n    Range() = delete;\n    Range(It begin, It end);\n    Range(It begin, It end, std::size_t grain_size);\n\n    template &lt;class Container&gt; Range(      Container&amp; container);\n    template &lt;class Container&gt; Range(const Container&amp; container);\n};\n\ntemplate &lt;class Idx = std::ptrdiff_t&gt;\nstruct IndexRange {\n    IndexRange() = delete;\n    IndexRange(Idx first, Idx last);\n    IndexRange(Idx first, Idx last, std::size_t grain_size);\n}\n\n// Binary operations\ntemplate &lt;class T = void&gt; struct  sum { constexpr T operator()(const T&amp; lhs, const T&amp; rhs) const; }\ntemplate &lt;class T = void&gt; struct prod { constexpr T operator()(const T&amp; lhs, const T&amp; rhs) const; }\ntemplate &lt;class T = void&gt; struct  min { constexpr T operator()(const T&amp; lhs, const T&amp; rhs) const; }\ntemplate &lt;class T = void&gt; struct  max { constexpr T operator()(const T&amp; lhs, const T&amp; rhs) const; }\n\n// Global scheduler\n/* 'Scheduler'  API, but placed directly into the namespace */\n/* 'ThreadPool' API, but placed directly into the namespace */\n/* This will use global lazily-initialized thread pool      */\n\n// Thread introspection\nnamespace this_thread {\n    std::optional&lt;      void*&gt; get_pool () noexcept;\n    std::optional&lt;std::size_t&gt; get_index() noexcept;\n}\n\nstd::size_t hardware_concurrency() noexcept;\n</code></pre> <p>Important</p> <p>There is no tight coupling between the <code>Scheduler&lt;&gt;</code> and the <code>ThreadPool</code>, other implementations may be used assuming they provide the 2 methods for submitting tasks.</p>"},{"location":"module_parallel.html#methods","title":"Methods","text":""},{"location":"module_parallel.html#scheduler","title":"Scheduler","text":""},{"location":"module_parallel.html#task-api","title":"Task API","text":"<pre><code>template &lt;class F, class... Args&gt; void detached_task(F&amp;&amp; f, Args&amp;&amp;... args);\n</code></pre> <p>Launches asynchronous task to execute callable <code>f</code> with arguments <code>args...</code>.</p> <p>Note: Callables constitute any objects with a defined <code>operator()</code>, for example: function pointers, functors, lambdas, <code>std::function</code>, <code>std::packaged_task</code>, <code>std::bind()</code> result and etc.</p> <pre><code>template &lt;class F, class... Args&gt; future_type&lt;R&gt; awaitable_task(F&amp;&amp; f, Args&amp;&amp;... args);\n</code></pre> <p>Launches asynchronous task to execute callable <code>f</code> with arguments <code>args...</code> and returns its future.</p>"},{"location":"module_parallel.html#parallel-for-api","title":"Parallel-for API","text":"<pre><code>template &lt;class It, class F&gt;          void  detached_loop(Range&lt;It&gt; range, F&amp;&amp; f);\ntemplate &lt;class It, class F&gt;          void  blocking_loop(Range&lt;It&gt; range, F&amp;&amp; f);\ntemplate &lt;class It, class F&gt; future_type&lt;&gt; awaitable_loop(Range&lt;It&gt; range, F&amp;&amp; f);\n</code></pre> <p>Detached / blocking / awaitable parallel-for loop over an iterator range.</p> <p>Loop body <code>f</code> can be defined in two ways:</p> <p>1. Single-argument <code>f(it)</code>, defining the body of a single loop iteration.</p> <p>2. Two-argument <code>f(low, high)</code>, defining how to execute a part of the loop spanning from <code>low</code> to <code>high</code>.</p> <p>Note 1: For most use cases (1) is a more intuitive option, closely resembling how we write a regular serial loop.</p> <p>Note 2: <code>It</code> is assumed to be a random access iterator.</p> <pre><code>template &lt;class Idx, class F&gt;          void  detached_loop(IndexRange&lt;Idx&gt; range, F&amp;&amp; f);\ntemplate &lt;class Idx, class F&gt;          void  blocking_loop(IndexRange&lt;Idx&gt; range, F&amp;&amp; f);\ntemplate &lt;class Idx, class F&gt; future_type&lt;&gt; awaitable_loop(IndexRange&lt;Idx&gt; range, F&amp;&amp; f);\n</code></pre> <p>Detached / blocking / awaitable parallel-for loop over an index range.</p> <p>Like in the iterator case, loop body <code>f</code> can be defined both for a single iteration and as a block.</p> <pre><code>template &lt;class Container, class F&gt;          void  detached_loop(Container&amp;&amp; container, F&amp;&amp; f);\ntemplate &lt;class Container, class F&gt;          void  blocking_loop(Container&amp;&amp; container, F&amp;&amp; f);\ntemplate &lt;class Container, class F&gt; future_type&lt;&gt; awaitable_loop(Container&amp;&amp; container, F&amp;&amp; f);\n</code></pre> <p>Detached / blocking / awaitable parallel-for loop over an iterator range spanning <code>container.begin()</code> to <code>container.end()</code>.</p> <p>Like in the usual case, loop body <code>f</code> can be defined both for a single iteration and as a block.</p>"},{"location":"module_parallel.html#parallel-reduce-api","title":"Parallel-reduce API","text":"<pre><code>template &lt;class It, class Op&gt;             R   blocking_reduce(Range&lt;It&gt; range, Op&amp;&amp; op);\ntemplate &lt;class It, class Op&gt; future_type&lt;R&gt; awaitable_reduce(Range&lt;It&gt; range, Op&amp;&amp; op);\n</code></pre> <p>Detached / blocking / awaitable parallel reduction over a binary operator <code>op</code> over an iterator range.</p> <p>Binary operator <code>op</code> is defined by the signature <code>T(const T&amp;, const T&amp;)</code> where <code>T</code> corresponds to the iterator <code>::value_type</code>.</p> <p>Note: Most commonly used to compute vector sum / product / min / max in parallel, see pre-defined binary operations.</p> <pre><code>template &lt;class Container, class Op&gt;             R   blocking_reduce(Container&amp;&amp; container, Op&amp;&amp; op);\ntemplate &lt;class Container, class Op&gt; future_type&lt;R&gt; awaitable_reduce(Container&amp;&amp; container, Op&amp;&amp; op);\n</code></pre> <p>Detached / blocking / awaitable parallel reduction over a binary operator <code>op</code> over an iterator range spanning <code>container.begin()</code> to <code>container.end()</code>.</p>"},{"location":"module_parallel.html#thread-pool","title":"Thread pool","text":""},{"location":"module_parallel.html#initialization","title":"Initialization","text":"<pre><code>explicit ThreadPool(std::size_t count = hardware_concurrency());\n</code></pre> <p>Creates thread pool with <code>count</code> threads.</p>"},{"location":"module_parallel.html#threading","title":"Threading","text":"<pre><code>void set_thread_count(std::size_t count = hardware_concurrency());\n</code></pre> <p>Changes the number of threads in the thread pool.</p> <p>Note 1: This method will block &amp; wait for all in-flight tasks to be completed before resizing the thread pool.</p> <p>Note 2: This and all the other thread pool methods are thread-safe, the pool can be resized from any number of external threads concurrently and no tasks will be lost. If called from a thread inside the pool itself (which would be a logical deadlock causing the thread to wait for its own termination)  throws <code>std::runtime_error</code>.</p> <pre><code>std::size_t get_thread_count();\n</code></pre> <p>Returns the number of threads in the thread pool.</p>"},{"location":"module_parallel.html#task-queuing","title":"Task queuing","text":"<pre><code>template &lt;class F, class... Args&gt; void detached_task(F&amp;&amp; f, Args&amp;&amp;... args);\n</code></pre> <p>Launches asynchronous task to execute callable <code>f</code> with arguments <code>args...</code>.</p> <pre><code>template &lt;class F, class... Args&gt; future_type&lt;R&gt; awaitable_task(F&amp;&amp; f, Args&amp;&amp;... args);\n</code></pre> <p>Launches asynchronous task to execute callable <code>f</code> with arguments <code>args...</code> and returns its future.</p> <pre><code>void wait();\n</code></pre> <p>Blocks current thread until all in-flight tasks are completed.</p>"},{"location":"module_parallel.html#future","title":"Future","text":"<pre><code>template &lt;class T = void&gt; future_type { /* Same API as std::future&lt;T&gt; */ };\n</code></pre> <p>A thin wrapper around <code>std::future</code> used by the thread pool. Exposes the same API as a standard future and can be constructed from it.</p> <p>This future allows the usage of recursive awaitable tasks. When waited with <code>get()</code> / <code>wait()</code> / <code>wait_for()</code> / <code>wait_until()</code> instead of just blocking it first looks for recursive work to do in the meantime.</p> <pre><code>template &lt;class T = void&gt;\nusing Future = ThreadPool::future_type&lt;T&gt;;\n</code></pre> <p>Alias for <code>ThreadPool::future_type&lt;T&gt;</code> placed at the namespace level.</p>"},{"location":"module_parallel.html#ranges","title":"Ranges","text":"<pre><code>template &lt;class It&gt;\nstruct Range {\n    Range() = delete;\n    Range(It begin, It end);\n    Range(It begin, It end, std::size_t grain_size);\n\n    template &lt;class Container&gt; Range(      Container&amp; container);\n    template &lt;class Container&gt; Range(const Container&amp; container);\n};\n</code></pre> <p>A lightweight struct representing an iterator range.</p> <p>Constructor (2) creates a range spanning <code>begin</code> to <code>end</code> and selects grain size automatically, which is recommended in most cases.</p> <p>Constructor (3) allows manual selection of <code>grain_size</code>.</p> <p>Constructors (4) and (5) create a range spanning <code>container.begin()</code> to <code>container.end()</code> for any container that supports standard member types <code>Container::iterator</code> and <code>Container::const_iterator</code>. Grain size is selected automatically.</p> <p>Note: <code>grain_size</code> is a maximum size of subranges, in which the main range gets split up for parallel execution. Splitting up workload into smaller grains can be beneficial for tasks with unpredictable or uneven complexity, but increases the overhead of scheduling &amp; synchronization. By default, the workload is split into <code>parallel::hardware_concurrency() * 4</code> grains.</p> <pre><code>template &lt;class Idx = std::ptrdiff_t&gt;\nstruct IndexRange {\n    IndexRange() = delete;\n    IndexRange(Idx first, Idx last);\n    IndexRange(Idx first, Idx last, std::size_t grain_size);\n}\n</code></pre> <p>A lightweight struct representing an index range.</p> <p>Constructor (2) creates a range spanning <code>first</code> to <code>last</code> and selects grain size automatically, which is recommended in most cases.</p> <p>Constructor (3) allows manual selection of <code>grain_size</code>.</p> <p>Note: Like all standard ranges, index range is exclusive and does not include <code>last</code>.</p>"},{"location":"module_parallel.html#binary-operations","title":"Binary operations","text":"<pre><code>template &lt;class T&gt; struct  sum { constexpr T operator()(const T&amp; lhs, const T&amp; rhs) const; }\ntemplate &lt;class T&gt; struct prod { constexpr T operator()(const T&amp; lhs, const T&amp; rhs) const; }\ntemplate &lt;class T&gt; struct  min { constexpr T operator()(const T&amp; lhs, const T&amp; rhs) const; }\ntemplate &lt;class T&gt; struct  max { constexpr T operator()(const T&amp; lhs, const T&amp; rhs) const; }\n\n// Transparent specializations\ntemplate&lt;&gt; struct  sum&lt;void&gt; { template&lt;class T, class U&gt; constexpr auto operator()(T&amp;&amp; lhs, T&amp;&amp; rhs) const; }\ntemplate&lt;&gt; struct prod&lt;void&gt; { template&lt;class T, class U&gt; constexpr auto operator()(T&amp;&amp; lhs, T&amp;&amp; rhs) const; }\ntemplate&lt;&gt; struct  min&lt;void&gt; { template&lt;class T, class U&gt; constexpr auto operator()(T&amp;&amp; lhs, T&amp;&amp; rhs) const; }\ntemplate&lt;&gt; struct  max&lt;void&gt; { template&lt;class T, class U&gt; constexpr auto operator()(T&amp;&amp; lhs, T&amp;&amp; rhs) const; }\n</code></pre> <p>Pre-defined binary operations for parallel reductions.</p> <p>Note 1: All functors will be <code>noexcept</code> if possible.</p> <p>Note 2: \"Transparent functors\" are <code>void</code> specializations that deduce their parameter and return types from the arguments. This is how function objects should usually be used. See cppreference for details.</p>"},{"location":"module_parallel.html#global-scheduler","title":"Global scheduler","text":"<p>For user convenience all <code>Scheduler&lt;&gt;</code> and <code>ThreadPool</code> methods are also doubled at the namespace scope, in which case they use a global lazily-initialized <code>Scheduler&lt;&gt;</code> with a <code>ThreadPool</code> backend. See examples.</p>"},{"location":"module_parallel.html#thread-introspection","title":"Thread introspection","text":"<pre><code>namespace this_thread {\n    std::optional&lt;      void*&gt; get_pool () noexcept;\n    std::optional&lt;std::size_t&gt; get_index() noexcept;\n}\n</code></pre> <p>Returns thread index or type-erased pointer to the parent thread pool for the current thread.</p> <p>Returns <code>std::nullopt</code> if current thread does not belong to a thread pool.</p> <p>Note 1: Similar to functions from <code>std::this_thread</code>.</p> <p>Note 2: Can be supported by any custom thread pool, assuming it sets the appropriate variables.</p> <pre><code>std::size_t hardware_concurrency() noexcept;\n</code></pre> <p>Same thing as <code>std::thread::hardware_concurrency()</code>, but instead of returning <code>0</code> when the number of threads can't be determined, it returns <code>4</code> as a fallback.</p>"},{"location":"module_parallel.html#examples","title":"Examples","text":""},{"location":"module_parallel.html#detached-tasks","title":"Detached tasks","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\nconst std::string message = \"&lt;some hypothetically very large message&gt;\";\n\n// Log the message asynchronously\nparallel::detached_task([&amp;]{ std::ofstream(\"log.txt\") &lt;&lt; message; });\n\n// ... do some work in the meantime ...\n\nparallel::wait(); // wait for tasks to complete\n</code></pre>"},{"location":"module_parallel.html#awaitable-tasks","title":"Awaitable tasks","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>double some_heavy_computation(double x) {\n    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n    return x + 32;\n}\n\n// ...\n\nusing namespace utl;\n\n// Launch asynchronous computation\nauto future = parallel::awaitable_task(some_heavy_computation, 10);\n\n// ... do some work in the meantime ...\n\n// Await the result\nconst double result = future.get();\n\nassert( result == 42 );\n</code></pre>"},{"location":"module_parallel.html#parallel-for-loop","title":"Parallel for loop","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>double f(double x) { return std::exp(std::sin(x)); }\n\n// ...\n\nusing namespace utl;\n\nstd::vector&lt;double&gt; vals(200'000, 0.5);\n\n// (optional) Select the number of threads \nparallel::set_thread_count(8);\n\n// Apply f() to all elements of the vector\nparallel::blocking_loop(vals, [&amp;](auto it) { *it = f(*it); });\n\n// Apply f() to indices [0, 100)\nparallel::blocking_loop(parallel::IndexRange{0, 100}, [&amp;](int i) { vals[i] = f(vals[i]); });\n\n// Specify computation in blocks instead of element-wise\nparallel::blocking_loop(parallel::IndexRange{0, 100}, [&amp;](int low, int high) {\n    for (int i = low; i &lt; high; ++i) vals[i] = f(vals[i]);\n});\n</code></pre>"},{"location":"module_parallel.html#reducing-over-a-binary-operation","title":"Reducing over a binary operation","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\nconst std::vector&lt;double&gt; vals(200'000, 2);\n\n// Reduce container over a binary operation\nconst double sum = parallel::blocking_reduce(vals, parallel::sum&lt;&gt;());\n\nassert( sum == 200'000 * 2 );\n\n// Reduce iterator range over a binary operation\nconst double subrange_sum = parallel::blocking_reduce(parallel::Range{vals.begin() + 100, vals.end()}, parallel::sum&lt;&gt;{});\n\nassert( subrange_sum == (200'000 - 100) * 2 );\n</code></pre>"},{"location":"module_parallel.html#using-a-local-thread-pool","title":"Using a local thread pool","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\nparallel::ThreadPool pool; // uses as many threads as it detects\n\npool.detached_task([]{ std::cout &lt;&lt; \"Hello from the task\\n\"; });\n\npool.set_thread_count(0); // will wait for the tasks, join all threads and release the memory\n</code></pre> <p>Output:</p> <pre><code>Hello from the task\n</code></pre>"},{"location":"module_parallel.html#recursive-tasks","title":"Recursive tasks","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\n// Deeply recursive illustrative task, not a practical way of computing fibonacci numbers\nstd::function&lt;int(int)&gt; fibonacci = [&amp;](int n) {\n    if (n &lt; 2) return n;\n\n    auto future_prev_1 = parallel::awaitable_task([&amp;] { return fibonacci(n - 1); });\n    auto future_prev_2 = parallel::awaitable_task([&amp;] { return fibonacci(n - 2); });\n\n    return future_prev_1.get() + future_prev_2.get();\n};\n\nassert( fibonacci(8) == 21 );\n</code></pre>"},{"location":"module_parallel.html#awaitable-parallel-loop-with-specific-grain-size","title":"Awaitable parallel loop with specific grain size","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\nstd::vector&lt;int&gt; a(200'000, 27);\nstd::vector&lt;int&gt; b(200'000, 13);\nstd::vector&lt;int&gt; c(200'000,  0);\n\n// Launch the task to compute { c = a + b } in parallel, we know this\n// workload is very even so we can use coarser grains than by default\nconst std::size_t grain_size = 200'000 / parallel::get_thread_count();\n\nauto future = parallel::awaitable_loop(parallel::IndexRange&lt;std::size_t&gt;{0, 200'000, grain_size},\n    [&amp;](std::size_t i){ c[i] = a[i] + b[i]; }\n);\n\n// ... do some work in the meantime ...\n\n// Await the result\nfuture.wait();\n\nfor (std::size_t i = 0; i &lt; 200'000; ++i) assert( c[i] == a[i] + b[i] );\n</code></pre>"},{"location":"module_parallel.html#thread-introspection_1","title":"Thread introspection","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\n// In debugging it is often useful to have some information about the thread whereabouts,\n// we can detect if current thread belongs to a pool, which pool and at which index\nauto future = parallel::awaitable_task([]{\n    std::cout &lt;&lt; \"I am a thread [\" &lt;&lt; *parallel::this_thread::get_index() &lt;&lt; \"]\"\n              &lt;&lt; \" in the pool  [\" &lt;&lt; *parallel::this_thread::get_pool()  &lt;&lt; \"]\" \n              &lt;&lt; std::endl;\n});\nfuture.wait();\n\nauto std_future = std::async([]{\n    std::cout &lt;&lt; \"Am I a pool thread? -&gt; \" &lt;&lt; (parallel::this_thread::get_pool() ? \"true\" : \"false\")\n              &lt;&lt; std::endl;\n});\nstd_future.wait();\n</code></pre> <p>Output:</p> <pre><code>I am a thread [0] in the pool [0x5f0c90a781f0]\nAm I a pool thread? -&gt; false\n</code></pre>"},{"location":"module_parallel.html#motivation","title":"Motivation","text":""},{"location":"module_parallel.html#the-problem","title":"The problem","text":"<p>Naive use of std::async and std::thread suffers greatly from the overhead of thread creation, this overhead makes small tasks (under a few ms) largely inefficient and introduces a great degree of performance instability. </p> <p>Thread pools are a classic solution to this problem. There are many existing implementations in C++, most of them tend to use a shared-queue design. This approach is easy to implement and works for simple parallelization, however it doesn't really function for scatter-gather workloads with nested subtasks.</p> <p>Something as simple as splitting a task into awaitable subtasks will deadlock the vast majority of thread pool implementations found online (even the ones that do implement work-stealing as they tend to work only with detached recursion), which was the initial motivation behind writing this library.</p>"},{"location":"module_parallel.html#what-is-work-stealing","title":"What is work-stealing","text":"<p>Large concurrency frameworks such as OpenMP and Intel TBB tend to use work-stealing design where each thread keeps its own queue of tasks and steals work from the backs of other queues when its own queue gets exhausted. Such approach introduces a whole slew of potential benefits:</p> <ol> <li>We can offload task scheduling to idle threads</li> <li>We can reduce lock contention by splitting scheduling over multiple queues</li> <li>Pushing/executing local tasks in the Last-In-First-Out (LIFO) order is likely to keep work hot in cache  </li> <li>Stealing in the First-In-First-Out (FIFO) order is likely to pull larger tasks (as they will be closer to the recursion root), minimizing contention over small task scheduling</li> </ol> <p>Recursive workloads in general are also quite difficult to sensibly implement with a single queue which is why work-stealing approach is usually used. All of this makes work-stealing a rather good general case solution as it tends to perform well on most workloads.</p>"},{"location":"module_parallel.html#benchmarks","title":"Benchmarks","text":"<p><code>utl::parallel</code> does not claim to be superior to vendor-optimized concurrency frameworks, what it does is expose a simple threading API with a concise (~<code>600</code> L.O.C.) implementation written entirely in standard C++17. As of now this niche seems to be rather empty as there is almost no stand-alone thread pools supporting recursion.</p> <p>Below are a few benchmarks comparing performance of <code>utl::parallel::ThreadPool</code> with <code>std::async</code> and some other thread pools. For comparison we will use bshoshany/thread-pool and progschj/ThreadPool as those two seem to be the most popular stand-alone thread pool implementations.</p> <p>Important</p> <p>Consequent benchmarks were measured on a <code>6</code>-core <code>AMD Ryzen 5 5600H</code> with hyper-threading disabled. Compiled with <code>g++ 11.4.0</code> at <code>-O2</code>. Ideal speedup from parallelization would be <code>600%</code>.</p>"},{"location":"module_parallel.html#uneven-non-recursive-tasks","title":"Uneven non-recursive tasks","text":"<p>Scenario 1: Small tasks. Submit <code>1000</code> tasks busy-waiting for <code>0</code> to <code>100</code> microseconds randomly. <code>std::async()</code> performs extremely poorly due to the overhead of thread creation overshadowing the actual work. Thread pools perform about the same, results might fluctuate a bit depending on the run.</p> <pre><code>| relative |               ms/op |                op/s |    err% |     total | Small non-recursive tasks\n|---------:|--------------------:|--------------------:|--------:|----------:|:--------------------------\n|   100.0% |               50.09 |               19.97 |    0.1% |     12.12 | `Serial`\n|   214.0% |               23.40 |               42.73 |    0.8% |     12.11 | `std::async()`\n|   573.3% |                8.74 |              114.47 |    0.4% |     11.84 | `parallel::ThreadPool`\n|   570.2% |                8.78 |              113.84 |    0.9% |     11.81 | `BS::thread_pool`\n|   565.6% |                8.86 |              112.92 |    1.2% |     11.83 | `progschj/ThreadPool`\n</code></pre> <p>Scenario 2: Large tasks. Submit <code>1000</code> tasks busy-waiting for <code>1000</code> to <code>3000</code> microseconds randomly. Since workload is large enough to overshadow the overhead of thread creation and scheduling, <code>std::async()</code> more-or-less catches up to the thread pools. This only becomes the case once the average task duration is over a millisecond.</p> <pre><code>| relative |               ms/op |                op/s |    err% |     total | Large non-recursive tasks\n|---------:|--------------------:|--------------------:|--------:|----------:|:--------------------------\n|   100.0% |            1,999.59 |                0.50 |    0.5% |     21.94 | `Serial`\n|   564.2% |              354.42 |                2.82 |    0.7% |     11.37 | `std::async()`\n|   597.0% |              334.96 |                2.99 |    0.4% |     11.41 | `parallel::ThreadPool`\n|   594.0% |              336.65 |                2.97 |    0.3% |     11.43 | `BS::thread_pool`\n|   593.4% |              336.95 |                2.97 |    0.2% |     11.45 | `progschj/ThreadPool`\n</code></pre>"},{"location":"module_parallel.html#uneven-recursive-tasks","title":"Uneven recursive tasks","text":"<p>Scenario 1: Shallow recursion. Submit <code>1000</code> tasks busy-waiting for <code>0</code> to <code>100</code> microseconds randomly and then spawning &amp; awaiting another such task with a <code>70%</code> chance. <code>std::async()</code> gets the job done, but experiences significant slowdown. <code>BS::thread_pool</code> and <code>progschj/ThreadPool</code> deadlock due to recursion.</p> <pre><code>| relative |               ms/op |                op/s |    err% |     total | Shallow recursive tasks\n|---------:|--------------------:|--------------------:|--------:|----------:|:------------------------\n|   100.0% |              167.20 |                5.98 |    0.7% |     12.04 | `Serial`\n|   161.1% |              103.80 |                9.63 |    5.1% |     12.10 | `std::async()`\n|   583.0% |               28.68 |               34.87 |    0.3% |     12.09 | `parallel::ThreadPool`\n</code></pre> <p>Scenario 2: Deep recursion. Submit <code>1000</code> tasks busy-waiting for <code>0</code> to <code>100</code> microseconds randomly and then spawning &amp; awaiting another 2 such tasks with a <code>49%</code> chance. This rate means on average tasks recursively expand into <code>50</code> different subtasks.</p> <pre><code>| relative |               ms/op |                op/s |    err% |     total | Deep recursive tasks\n|---------:|--------------------:|--------------------:|--------:|----------:|:---------------------\n|   100.0% |              183.88 |                5.44 |    0.6% |     12.29 | `Serial`\n|   154.7% |              118.83 |                8.42 |    6.8% |     11.94 | `std::async()`\n|   565.1% |               32.54 |               30.73 |    1.2% |     11.90 | `parallel::ThreadPool`\n</code></pre>"},{"location":"module_parallel.html#questions-answers","title":"Questions &amp; answers","text":"<p>Q: Why use custom future type instead of <code>std::future&lt;&gt;</code>?</p> <p>A: This is necessary for recursive tasks. When <code>wait()</code>'ed from a pool thread instead of blocking right-away it first checks if there any recursive subtasks tasks to do in the meantime. The usual future would deadlock in this case by design, no way around it. Other than that this is a very thin wrapper around a standard <code>std::future&lt;&gt;</code>.</p> <p>Q: Are there any improvement to be made in terms of performance?</p> <p>A: Indeed. \"Ideal\" work-stealing executor would likely use a global lock-free MPMC queue for external tasks and per-thread Chase-Lev SPMC lock-free queues for task stealing. \"Ideal\" thread pool would also use a custom implementation of <code>std::function&lt;&gt;</code> (something closer to <code>std::move_only_function&lt;&gt;</code> from C++23). Unfortunately all of those things are highly complex and there are very few clean and correct implementations out there. A proper lock-free MPMC queue implementation with exception correctness alone would be higher in size and complexity than this entire library, the same applies to custom delegates and SPMC queues, which is why they are often pulled in as dependencies. This implementation tries to do the best it can while keeping the thread pool logic simple enough to be copy-pastable into a different project. Additional gains can also be made by getting rid of <code>wait()</code> and making the API a bit more rigid. It is also likely that some locks can be replaced with atomics.</p> <p>Q: Is it possible to deadlock the pool?</p> <p>A: Deadlocks caused by the thread pool design itself shouldn't be possible. Logical deadlocks caused by a cyclical inter-thread dependency are still possible, but this is a user-level bug since no thread pool design could possibly prevent this.</p> <p>Q: How was this library tested?</p> <p>A: It has a wide testing suite covering a multitude of use cases that runs in CI on all major platforms. GCC &amp; clang builds run under ASan, TSan (locally) and UBSan. Tests also include some reasonable fuzzing.</p> <p>Q: Why no benchmarks against Leopard, riften::ThiefPool and dp::thread_pool?</p> <p>A: All of these require C++20 to build, which is above the required standard for building this repo. <code>riften::ThiefPool</code> also includes several dependencies. Out of these 3 implementations, recursive workload seems to only be supported by <code>Leopard</code> and even that requires some algorithm adjustments on user-side with <code>run_task()</code> needing to be called in the right places to avoid a deadlock.</p>"},{"location":"module_predef.html","title":"utl::predef","text":""},{"location":"module_predef.html#utlpredef","title":"utl::predef","text":"<p>&lt;- to README.md</p> <p>&lt;- to implementation.hpp</p> <p>utl::predef module contains macros and constant expressions for detecting compilation details.</p> <p>It uses known implementation-defined macros to deduce compilation details and abstracts them away behind a unified API.</p> <p>Note</p> <p>There exists a very similar Boost library with the same name, it supports more exotic platforms, but has a different API and doesn't provide some of the things defined in this module.</p>"},{"location":"module_predef.html#definitions","title":"Definitions","text":"<pre><code>// Compiler detection\n#define UTL_PREDEF_COMPILER_IS_MSVC // only one of these macros will be defined\n#define UTL_PREDEF_COMPILER_IS_GCC\n#define UTL_PREDEF_COMPILER_IS_CLANG\n#define UTL_PREDEF_COMPILER_IS_LLVM\n#define UTL_PREDEF_COMPILER_IS_ICC\n#define UTL_PREDEF_COMPILER_IS_PGI\n#define UTL_PREDEF_COMPILER_IS_IBMCPP\n#define UTL_PREDEF_COMPILER_IS_NVCC\n#define UTL_PREDEF_COMPILER_IS_UNKNOWN\n\nconstexpr std::string_view compiler_name;\nconstexpr std::string_view compiler_full_name;\n\n// Platform detection\n#define UTL_PREDEF_PLATFORM_IS_WINDOWS_X64 // only one of these macros will be defined\n#define UTL_PREDEF_PLATFORM_IS_WINDOWS_X32\n#define UTL_PREDEF_PLATFORM_IS_CYGWIN\n#define UTL_PREDEF_PLATFORM_IS_ANDROID\n#define UTL_PREDEF_PLATFORM_IS_LINUX\n#define UTL_PREDEF_PLATFORM_IS_UNIX\n#define UTL_PREDEF_PLATFORM_IS_MACOS\n#define UTL_PREDEF_PLATFORM_IS_UNKNOWN\n\nconstexpr std::string_view platform_name;\n\n// Architecture detection\n#define UTL_PREDEF_ARCHITECTURE_IS_X86_64 // only one of these macros will be defined\n#define UTL_PREDEF_ARCHITECTURE_IS_X86_32\n#define UTL_PREDEF_ARCHITECTURE_IS_ARM\n#define UTL_PREDEF_ARCHITECTURE_IS_UNKNOWN\n\nconstexpr std::string_view architecture_name;\n\n// Language standard detection\n#define UTL_PREDEF_STANDARD_IS_23_PLUS // multiple of these macros can be defined\n#define UTL_PREDEF_STANDARD_IS_20_PLUS\n#define UTL_PREDEF_STANDARD_IS_17_PLUS\n#define UTL_PREDEF_STANDARD_IS_14_PLUS\n#define UTL_PREDEF_STANDARD_IS_11_PLUS\n#define UTL_DEFINE_STANDARD_IS_UNKNOWN\n\nconstexpr std::string_view standard_name;\n\n// Compilation mode detection\n#define UTL_PREDEF_MODE_IS_RELEASE // only one of these macros will be defined\n#define UTL_PREDEF_MODE_IS_DEBUG\n\nconstexpr std::string_view mode_name\n\n// Compilation summary    \nstd::string compilation_summary();\n\n// Optimization macros\n#define UTL_PREDEF_UNREACHABLE\n#define UTL_PREDEF_FORCE_INLINE\n#define UTL_PREDEF_NO_INLINE\n#define UTL_PREDEF_ASSUME\n</code></pre>"},{"location":"module_predef.html#methods","title":"Methods","text":""},{"location":"module_predef.html#compiler-detection","title":"Compiler detection","text":"<pre><code>// Compiler detection\n#define UTL_PREDEF_COMPILER_IS_MSVC\n#define UTL_PREDEF_COMPILER_IS_GCC\n#define UTL_PREDEF_COMPILER_IS_CLANG\n#define UTL_PREDEF_COMPILER_IS_LLVM\n#define UTL_PREDEF_COMPILER_IS_ICC\n#define UTL_PREDEF_COMPILER_IS_PGI\n#define UTL_PREDEF_COMPILER_IS_IBMCPP\n#define UTL_PREDEF_COMPILER_IS_NVCC\n#define UTL_PREDEF_COMPILER_IS_UNKNOWN\n</code></pre> <p>Only one of these macros will be defined. The macro that gets defined corresponds to the detected compiler. If no other option is suitable, unknown is used as a fallback.</p> <p>This is useful for compiler-specific conditional compilation.</p> <pre><code>constexpr std::string_view compiler_name;\n</code></pre> <p><code>constexpr</code> string that evaluates to the abbreviated name of the detected compiler.</p> <p>Possible values: <code>MSVC</code>, <code>GCC</code>, <code>clang</code>, <code>LLVM</code>, <code>ICC</code>, <code>PGI</code>, <code>IBMCPP</code>, <code>NVCC</code>, <code>&lt;unknown&gt;</code>.</p> <pre><code>constexpr std::string_view compiler_full_name;\n</code></pre> <p><code>constexpr</code> string that evaluates to the full name of the detected compiler.</p> <p>Possible values: <code>Microsoft Visual C++ Compiler</code>, <code>GNU C/C++ Compiler</code>, <code>Clang Compiler</code>, <code>LLVM Compiler</code>, <code>Intel C/C++ Compiler</code>, <code>Portland Group C/C++ Compiler</code>, <code>IBM XL C/C++ Compiler</code>, <code>Nvidia Cuda Compiler Driver</code>, <code>&lt;unknown&gt;</code>.</p>"},{"location":"module_predef.html#platform-detection","title":"Platform detection","text":"<pre><code>// Platform detection\n#define UTL_PREDEF_PLATFORM_IS_WINDOWS_X64\n#define UTL_PREDEF_PLATFORM_IS_WINDOWS_X32\n#define UTL_PREDEF_PLATFORM_IS_CYGWIN\n#define UTL_PREDEF_PLATFORM_IS_ANDROID\n#define UTL_PREDEF_PLATFORM_IS_LINUX\n#define UTL_PREDEF_PLATFORM_IS_UNIX\n#define UTL_PREDEF_PLATFORM_IS_MACOS\n#define UTL_PREDEF_PLATFORM_IS_UNKNOWN\n</code></pre> <p>Only one of these macros will be defined. The macro that gets defined corresponds to the detected platform. If no other option is suitable, unknown is used as a fallback.</p> <p>This is useful for platform-specific conditional compilation.</p> <pre><code>constexpr std::string_view platform_name;\n</code></pre> <p><code>constexpr</code> string that evaluates to the name of the detected platform.</p> <p>Possible values: <code>Windows64</code>, <code>Windows32</code>, <code>Windows (CYGWIN)</code>, <code>Android</code>, <code>Linux</code>, <code>Unix-like OS</code>, <code>MacOS</code>, <code>&lt;unknown&gt;</code>. </p>"},{"location":"module_predef.html#architecture-detection","title":"Architecture detection","text":"<pre><code>#define UTL_PREDEF_ARCHITECTURE_IS_X86_64\n#define UTL_PREDEF_ARCHITECTURE_IS_X86_32\n#define UTL_PREDEF_ARCHITECTURE_IS_ARM\n#define UTL_PREDEF_ARCHITECTURE_IS_UNKNOWN\n</code></pre> <p>Only one of these macros will be defined. The macro that gets defined corresponds to the detected CPU architecture. If no other option is suitable, unknown is used as a fallback.</p> <p>This is useful for architecture-specific conditional compilation.</p> <pre><code>constexpr std::string_view architecture_name;\n</code></pre> <p><code>constexpr</code> string that evaluates to the name of the detected CPU architecture.</p> <p>Possible values: <code>x86-64</code>, <code>x86-32</code>, <code>ARM</code>, <code>&lt;unknown&gt;</code></p>"},{"location":"module_predef.html#language-standard-detection","title":"Language standard detection","text":"<pre><code>#define UTL_PREDEF_STANDARD_IS_23_PLUS\n#define UTL_PREDEF_STANDARD_IS_20_PLUS\n#define UTL_PREDEF_STANDARD_IS_17_PLUS\n#define UTL_PREDEF_STANDARD_IS_14_PLUS\n#define UTL_PREDEF_STANDARD_IS_11_PLUS\n#define UTL_DEFINE_STANDARD_IS_UNKNOWN\n</code></pre> <p>Multiple of these macros can be defined. The macro that gets defined corresponds to the available C++ standard. If no other option is suitable, unknown is used as a fallback.</p> <p>This is useful for conditional compilation based on available standard.</p> <pre><code>constexpr std::string_view standard_name;\n</code></pre> <p><code>constexpr</code> string that evaluates to the name of the detected C++ standard. Possible values: <code>C++23</code>, <code>C++20</code>, <code>C++17</code>, <code>C++14</code>, <code>C++11</code>, <code>&lt;unknown&gt;</code>.</p> <p>Note: Considering that this is a C++17 library, there should be no feasible way to get values below <code>C++17</code>, however they are still provided for the sake of implementation completeness, shall the source code be copied directly.</p>"},{"location":"module_predef.html#compilation-mode-detection","title":"Compilation mode detection","text":"<pre><code>#define UTL_PREDEF_MODE_IS_RELEASE\n#define UTL_PREDEF_MODE_IS_DEBUG\n</code></pre> <p>Multiple of these macros can be defined. The macro that gets defined corresponds to the selected compilation mode.</p> <p>This is useful for conditional compilation in <code>Debug</code> mode.</p> <pre><code>constexpr std::string_view mode_name\n</code></pre> <p><code>constexpr</code> string that evaluates to the name of the mode. Possible values: <code>Release</code>, <code>Debug</code>, <code>&lt;unknown&gt;</code></p>"},{"location":"module_predef.html#compilation-summary","title":"Compilation summary","text":"<pre><code>std::string compilation_summary();\n</code></pre> <p>Returns a string containing a detailed summary of compilation details based on the other functionality of this header. See the example.</p>"},{"location":"module_predef.html#optimization-macros","title":"Optimization macros","text":"<pre><code>#define UTL_PREDEF_UNREACHABLE\n</code></pre> <p>Equivalent to C++23 <code>std::unreachable</code> that supports earlier standards using compiler builtins.</p> <p>Compiler implementations may use this to optimize impossible code branches away.</p> <p>Note 1: Requires semicolon at the end similarly to a regular function.</p> <p>Note 2: Compiles to nothing if there is no suitable compiler support.</p> <pre><code>#define UTL_PREDEF_FORCE_INLINE\n</code></pre> <p>Hints (<code>MSVC</code>) or forces (<code>GCC</code>, <code>clang</code> and <code>ICX</code>) function inlining using compiler built-ins.</p> <p>Note: Compiles to nothing if there is no suitable compiler support.</p> <pre><code>#define UTL_PREDEF_NO_INLINE\n</code></pre> <p>Disables function inlining using compiler built-ins.</p> <p>Note: Compiles to regular <code>inline</code> if there is no suitable compiler support.</p> <pre><code>#define UTL_PREDEF_ASSUME(condition)\n</code></pre> <p>Equivalent to C++23 <code>[[assume(condition)]]</code> that supports earlier standards using <code>MSVC</code> and <code>clang</code> built-ins.</p> <p>Invokes undefined behavior if statement <code>condition</code> evaluates to false, which provides compiler with additional optimization opportunities since implementations may assume that undefined behavior can never happen and the statement always holds.</p> <p>Note 1: Compiles to nothing if there is no suitable compiler support.</p> <p>Note 2: In debug mode also works like an <code>assert()</code>.</p>"},{"location":"module_predef.html#examples","title":"Examples","text":""},{"location":"module_predef.html#conditional-compilation","title":"Conditional compilation","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>#if defined(UTL_PREDEF_COMPILER_IS_GCC) || defined(UTL_PREDEF_COMPILER_IS_CLANG)\nstd::cout &lt;&lt; \"Running Clang or GCC\";\n#elif defined(UTL_PREDEF_COMPILER_IS_MSVC)\nstd::cout &lt;&lt; \"Running MSVC\";\n#else\nstd::cout &lt;&lt; \"Running some other compiler\";\n#endif\n</code></pre> <p>Output: <pre><code>Running Clang or GCC\n</code></pre></p>"},{"location":"module_predef.html#compilation-summary_1","title":"Compilation summary","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>std::cout &lt;&lt; utl::predef::compilation_summary();\n</code></pre> <p>Output: <pre><code>Compiler:          GNU C/C++ Compiler\nPlatform:          Linux\nArchitecture:      x86-64\nL1 cache line (D): 64\nL1 cache line (C): 64\nCompiled in mode:  Debug\nCompiled under OS: true\nCompilation date:  Jul 19 2025 12:25:37\n</code></pre></p>"},{"location":"module_predef.html#optimization-macros_1","title":"Optimization macros","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>enum class State { YES, NO };\n\nUTL_PREDEF_FORCE_INLINE\nstd::string to_string(State value) {\n    switch (value) {\n        case State::YES: return \"YES\";\n        case State::NO : return \"NO\" ;\n        default        : UTL_PREDEF_UNREACHABLE;\n    }\n}\n\n// ...\n\nassert( to_string(State::YES) == \"YES\" );\n</code></pre>"},{"location":"module_profiler.html","title":"utl::profiler","text":""},{"location":"module_profiler.html#utlprofiler","title":"utl::profiler","text":"<p>&lt;- to README.md</p> <p>&lt;- to implementation.hpp</p> <p>utl::profiler is a single-include solution for localized profiling. It features simple macros to measure how much time is taken by a certain scope / expression / code segment. The profiler automatically builds a call graph for all profiled functions and prints a nicely formatted table for every thread. See the examples.</p> <p>Key features:</p> <ul> <li>Easy to use</li> <li>Low overhead</li> <li>No reliance on system APIs</li> <li>Supports multi-threading &amp; recursion</li> <li>Supports CPU-counter timestamps</li> <li>Can export results at any point of the program</li> <li>Can be fully disabled</li> </ul> <p>Below is an output example from profiling a JSON parser:</p> <p></p>"},{"location":"module_profiler.html#definitions","title":"Definitions","text":"<pre><code>// Profiling macros\nUTL_PROFILER_SCOPE(label);\n\nUTL_PROFILER(label);\n\nUTL_PROFILER_BEGIN(segment, label);\nUTL_PROFILER_END(segment);\n\n// Style options\nstruct Style {\n    std::size_t indent = 2;\n    bool        color  = true;\n\n    double cutoff_red    = 0.40; // &gt; 40% of total runtime\n    double cutoff_yellow = 0.20; // &gt; 20% of total runtime\n    double cutoff_gray   = 0.01; // &lt;  1% of total runtime\n};\n\n// Global profiler object\nstruct Profiler {\n    void print_at_exit(bool value) noexcept;\n\n    void upload_this_thread();\n\n    std::string format_results(const Style&amp; style = Style{});\n};\n\ninline Profiler profiler;\n</code></pre>"},{"location":"module_profiler.html#methods","title":"Methods","text":""},{"location":"module_profiler.html#profiling-macros","title":"Profiling macros","text":"<pre><code>UTL_PROFILER_SCOPE(label);\n</code></pre> <p>Attaches profiler to the current scope.</p> <p>If profiled scope was entered at any point of the program, upon exiting <code>main()</code> a per-thread call graph will be built for all profiled segments.</p> <p>Note 1: <code>label</code> is a string literal name that will be shown in the results table.</p> <p>Note 2: Automatic printing on exit can be disabled.</p> <pre><code>UTL_PROFILER(label);\n</code></pre> <p>Attaches profiler to the scope of the following expression.</p> <p>Convenient to profile individual loops / function calls / ifs and etc.</p> <pre><code>UTL_PROFILER_BEGIN(segment, label);\nUTL_PROFILER_END(segment);\n</code></pre> <p>Attaches profiler to the code section between two <code>BEGIN</code>/<code>END</code> macros with the same <code>segment</code> label.</p>"},{"location":"module_profiler.html#style-options","title":"Style options","text":"<pre><code>struct Style {\n    std::size_t indent = 2;\n    bool        color  = true;\n\n    double cutoff_red    = 0.40; // &gt; 40% of total runtime\n    double cutoff_yellow = 0.20; // &gt; 20% of total runtime\n    double cutoff_gray   = 0.01; // &lt;  1% of total runtime\n};\n</code></pre> <p>A struct with formatting settings for <code>Profiler::format_results()</code>.</p>"},{"location":"module_profiler.html#global-profiler-object","title":"Global profiler object","text":"<p><code>cpp void Profiler::print_at_exit(bool value) noexcept;</code></p> <p>Sets whether profiling results should be automatically printed after exiting from <code>main()</code>. <code>true</code> by default.</p> <p>Note: This and all other profiler object methods are thread-safe.</p> <p><code>cpp void Profiler::upload_this_thread();</code></p> <p>Uploads profiling results from the current thread to the profiler object.</p> <p>Can be used to upload results from detached threads. Otherwise results are automatically uploaded once detached thread joins another one. </p> <p><code>cpp std::string Profiler::format_results(const Style&amp; style = Style{});</code></p> <p>Formats profiling results to a string using given <code>style</code> options.</p> <pre><code>inline Profiler profiler;\n</code></pre> <p>Global profiler object.</p>"},{"location":"module_profiler.html#examples","title":"Examples","text":""},{"location":"module_profiler.html#profiling-a-code-segment","title":"Profiling a code segment","text":"<p>Note</p> <p>Online compiler explorer may be a little weird when it comes to sleep &amp; time measurement precision.</p> <p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace std::chrono_literals;\n\nvoid computation_1() { std::this_thread::sleep_for(300ms); }\nvoid computation_2() { std::this_thread::sleep_for(200ms); }\nvoid computation_3() { std::this_thread::sleep_for(400ms); }\nvoid computation_4() { std::this_thread::sleep_for(600ms); }\nvoid computation_5() { std::this_thread::sleep_for(100ms); }\n\n// ...\n\n// Profile a scope\nUTL_PROFILER_SCOPE(\"Computation 1 - 5\");\ncomputation_1();\ncomputation_2();\n\n// Profile an expression\nUTL_PROFILER(\"Computation 3\") computation_3();\n\n// Profile a code segment\nUTL_PROFILER_BEGIN(comp_45, \"Computation 4 - 5\");\ncomputation_4();\ncomputation_5();\nUTL_PROFILER_END(comp_45);\n</code></pre> <p>Output:</p> <p></p>"},{"location":"module_profiler.html#profiling-recursion","title":"Profiling recursion","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>void recursive(int depth = 0) {\n    if (depth &gt; 4) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(50));\n        return;\n    }\n\n    UTL_PROFILER(\"1st recursion branch\") recursive(depth + 1);\n    UTL_PROFILER(\"2nd recursion branch\") recursive(depth + 2);\n}\n\n// ...\n\nrecursive();\n</code></pre> <p>Output:</p> <p></p>"},{"location":"module_profiler.html#profiling-parallel-section","title":"Profiling parallel section","text":"<p>Note</p> <p>In this example we will use utl::parallel to represent a parallel section concisely.</p> <p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\nusing namespace std::chrono_literals;\n\n// Run loop on the main thread\nUTL_PROFILER(\"Single-threaded loop\")\nfor (int i = 0; i &lt; 30; ++i) std::this_thread::sleep_for(10ms);\n\n// Run the same loop on 3 threads\nparallel::set_thread_count(3);\n\nUTL_PROFILER(\"Multi-threaded loop\")\nparallel::blocking_loop(parallel::IndexRange{0, 30}, [](int low, int high){\n    UTL_PROFILER(\"Worker thread loop\")\n    for (int i = low; i &lt; high; ++i) std::this_thread::sleep_for(10ms);\n});\n\nparallel::set_thread_count(0);\n</code></pre> <p>Output:</p> <p></p>"},{"location":"module_profiler.html#profiling-detached-threads-uploading-results","title":"Profiling detached threads &amp; uploading results","text":"<p>Note</p> <p>In this example we will use utl::parallel to represent detached section concisely.</p> <p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\nusing namespace std::chrono_literals;\n\nparallel::set_thread_count(2);\n\n// Detached task\nUTL_PROFILER(\"Uploading task 1\")\nparallel::detached_task([]{\n    UTL_PROFILER(\"Detached task 1: part 1\") std::this_thread::sleep_for(700ms);\n});\n\n// Detached task with explicit result upload\nUTL_PROFILER(\"Uploading task 2\")\nparallel::detached_task([]{\n    UTL_PROFILER(\"Detached task 2: part 1\") std::this_thread::sleep_for(50ms);\n    UTL_PROFILER(\"Detached task 2: part 2\") std::this_thread::sleep_for(50ms);\n\n    // Manually upload results to the main thread,\n    // otherwise results get collected once the thread joins\n    profiler::profiler.upload_this_thread();\n\n    UTL_PROFILER(\"Detached task 2: part 3\") std::this_thread::sleep_for(500ms);\n});\n\n// Wait a little so the 2nd task has time to reach manual upload\nUTL_PROFILER(\"Waiting for task 2 to be partially done\")\nstd::this_thread::sleep_for(200ms);\n\n// Format results explicitly\nprofiler::profiler.print_at_exit(false);\n\nstd::cout &lt;&lt; profiler::profiler.format_results();\n</code></pre> <p>Output:</p> <p></p>"},{"location":"module_profiler.html#custom-style-exporting-results-to-a-file","title":"Custom style &amp; exporting results to a file","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\nusing namespace std::chrono_literals;\n\n// Profile something\nUTL_PROFILER(\"Loop\")\nfor (int i = 0; i &lt; 10; ++i) {\n    UTL_PROFILER(\"1st half of the loop\") std::this_thread::sleep_for(10ms);\n    UTL_PROFILER(\"2nd half of the loop\") std::this_thread::sleep_for(10ms);\n}\n\n// Disable automatic printing\nprofiler::profiler.print_at_exit(false);\n\n// Disable colors, remove indent, format to string\nprofiler::Style style;\nstyle.color  = false;\nstyle.indent = 0;\n\nconst std::string results = profiler::profiler.format_results(style);\n\n// Export to file &amp; console\nstd::ofstream(\"profiling_results.txt\") &lt;&lt; results;\nstd::cout                              &lt;&lt; results;\n</code></pre> <p>Output:</p> <pre><code>-------------------- UTL PROFILING RESULTS ---------------------\n\n# Thread [main] (reuse 0) (running) (runtime -&gt; 201.81 ms)\n - 99.99%  | 201.79 ms |                 Loop | example.cpp:8, main()  |\n - 49.91%  | 100.73 ms | 1st half of the loop | example.cpp:10, main() |\n - 50.07%  | 101.04 ms | 2nd half of the loop | example.cpp:11, main() |\n</code></pre>"},{"location":"module_profiler.html#reducing-overhead-with-x86-intrinsics","title":"Reducing overhead with x86 intrinsics","text":"<p>By far the most significant part of profiling overhead comes from calls to <code>std::chrono::steady_clock::now()</code>.</p> <p>It is possible to significantly reduce that overhead by using CPU-counter intrinsics. To do so simply define <code>UTL_PROFILER_USE_INTRINSICS_FOR_FREQUENCY</code> macro for appropriate frequency:</p> <pre><code>#define UTL_PROFILER_USE_INTRINSICS_FOR_FREQUENCY 3.3e9 // 3.3 GHz (AMD Ryzen 5 5600H)\n#include \"UTL/profiler.hpp\"                             // will now use 'rdtsc' for timestamps\n</code></pre> <p>This is exceedingly helpful when profiling code on a hot path. Below are a few benchmarks showcasing the difference on particular hardware:</p> <pre><code>======= USING std::chrono ========\n\n| relative |               ms/op |                op/s |    err% |     total | benchmark\n|---------:|--------------------:|--------------------:|--------:|----------:|:----------\n|   100.0% |                3.46 |              289.22 |    0.1% |      0.44 | `Runtime without profiling`\n|    53.9% |                6.41 |              155.90 |    0.3% |      0.77 | `Theoretical best std::chrono profiler`\n|    52.2% |                6.62 |              151.07 |    0.2% |      0.80 | `UTL_PROFILER()`\n\n// very light workload - just 8 computations of 'std::cos()' per 2 time measurements, difficult to\n// time and sensitive to overhead, here profiled code is ~2x slower then the non-profiled workload\n\n====== USING __rdtsc() ======\n\n| relative |               ms/op |                op/s |    err% |     total | benchmark\n|---------:|--------------------:|--------------------:|--------:|----------:|:----------\n|   100.0% |                3.50 |              286.11 |    0.6% |      0.43 | `Runtime without profiling`\n|    86.3% |                4.05 |              247.01 |    0.2% |      0.49 | `Theoretical best __rdtsc() profiler`\n|    73.7% |                4.74 |              210.97 |    0.3% |      0.57 | `UTL_PROFILER()`\n\n// notable reduction in profiling overhead\n</code></pre> <p>Note</p> <p>Here \"theoretical best\" refers to a hypothetical profiler that requires zero operations aside from measuring the time at two points  \u2014 before and after entering the code segment.</p>"},{"location":"module_profiler.html#disabling-profiling","title":"Disabling profiling","text":"<p>To disable any profiling code from interfering with the program, simply define <code>UTL_PROFILER_DISABLE</code> before including the header:</p> <pre><code>#define UTL_PROFILER_DISABLE\n#include \"UTL/profiler.hpp\"\n// - the header is now stripped of any and all code and only provides no-op mocks of the public API,\n//   this means effectively no impact on compile times\n// - 'profiler.format_results()' now returns \"&lt;profiling is disabled&gt;\"\n</code></pre>"},{"location":"module_profiler.html#behind-the-scenes","title":"Behind the scenes","text":"<p>A simple &amp; naive way to construct a call graph would be through building a tree of nodes using <code>std::unordered_map&lt;std::string, Node&gt;</code> with call-site as a key. Such approach however makes the overhead of tree expansion &amp; traversal incredibly high, rendering profiler useless for small tasks.</p>"},{"location":"module_profiler.html#call-graph-traversal","title":"Call graph traversal","text":"<p>This library uses a bunch of <code>thread_local</code> variables (created by macros) to correlate call-sites with integer IDs and reduces tree traversal logic to traversing a \"network\" of indices encoded as a dense \\(M \\times N\\) matrix where \\(M\\) \u2014 number of call-sites visited by this thread, \\(N\\) \u2014 number of nodes in the call graph.</p> <p>There are some additional details &amp; arrays, but the bottom-line is that by associating everything we can with linearly growing IDs and delaying \"heavy\" things as much as possible until thread destruction / formatting, we can reduce almost all common operations outside of time measurement to trivial integer array lookups.</p> <p>This way, the cost of re-entry on existing call graph nodes (aka the fast path taken most of the time) is reduced down to a single array lookup &amp; branch that gets predicted most of the time.</p> <p>New call-site entry &amp; new node creation are rare slow paths, they only happen during call-graph expansion and will have very little contribution to the runtime outside of measuring very deep recursion. By using an <code>std::vector</code>-like allocation strategy for both rows &amp; columns it is possible to make reallocation amortized \\(O(1)\\).</p>"},{"location":"module_profiler.html#memory-usage","title":"Memory usage","text":"<p>Memory overhead of profiling is mostly defined by the aforementioned call graph matrix. For example, on a thread that runs into <code>20</code> profiling macros and creates <code>100</code> nodes, memory overhead is going to be <code>8 kB</code>. A thread that runs into <code>100</code> profiling macros and creates <code>500</code> call graph nodes, memory overhead will be <code>0.2 MB</code>.</p> <p>It is possible to further reduce memory overhead (down to <code>4 kB</code> and <code>0.1 MB</code>) by defining a <code>UTL_PROFILER_USE_SMALL_IDS</code> macro before the include:</p> <pre><code>#define UTL_PROFILER_USE_SMALL_IDS\n#include \"UTL/profiler.hpp\"\n</code></pre> <p>This switches implementation to 16-bit IDs, which limits the max number of nodes to <code>65535</code>. For most practical purposes this should be more than enough as most machines will reach stack overflow far before reaching such depth of the call graph.</p>"},{"location":"module_profiler.html#thread-safety","title":"Thread safety","text":"<p>Almost all profiling is lock-free, there are only 3 points at which implementation needs to lock a mutex:</p> <ul> <li>When creating a new thread</li> <li>When joining a thread</li> <li>When manually calling <code>profiler.upload_this_thread()</code></li> </ul> <p>All public API is thread-safe.</p>"},{"location":"module_progressbar.html","title":"utl::progressbar","text":""},{"location":"module_progressbar.html#utlprogressbar","title":"utl::progressbar","text":"<p>&lt;- to README.md</p> <p>&lt;- to implementation.hpp</p> <p>utl::progressbar header adds configurable progress bars for CLI apps.</p> <p>Below is basic showcase:</p> <pre><code>// progressbar::Percentage with default style\n[############..................] 42.67% (remaining: 8 sec)\n\n// progressbar::Ruler with default style\n0    10   20   30   40   50   60   70   80   90   100%\n|----|----|----|----|----|----|----|----|----|----|\n#######################\n</code></pre>"},{"location":"module_progressbar.html#definitions","title":"Definitions","text":"<pre><code>// 'Percentage' progress bar\nstruct Percentage {\npublic:\n    // - Style configuration -\n    struct Style {\n        char        fill            = '#';\n        char        empty           = '.';\n        char        left            = '[';\n        char        right           = ']';\n        std::string estimate_prefix = \"(remaining: \";\n        std::string estimate_suffix = \")\";\n    } style;\n\n    bool show_bar        = true;\n    bool show_percentage = true;\n    bool show_estimate   = true;\n\n    std::size_t bar_length  = 30;\n    double      update_rate = 2.5e-3;\n\n    // - Methods -\n    Percentage();\n    void set_progress(double value);\n    void finish();\n\n    void update_style();\n};\n\n// 'Ruler' progress bar\nclass Ruler {\npublic:\n    // - Style configuration -\n    struct Style {\n        char fill            = '#';\n        char ruler_line      = '-';\n        char ruler_delimiter = '|';\n    } style;\n\n    bool show_ticks = true;\n    bool show_ruler = true;\n    bool show_bar   = true;\n\n    // - Methods -\n    Ruler();\n    void set_progress(double percentage);\n    void finish();\n\n    void update_style();\n};\n</code></pre>"},{"location":"module_progressbar.html#methods","title":"Methods","text":""},{"location":"module_progressbar.html#percentage-progress-bar","title":"<code>Percentage</code> progress bar","text":"<p>Note</p> <p>This is a general progress bar suitable for most applications. It should be a default option unless environment is extremely limited.</p> <pre><code>// - Style configuration -\nstruct Style {\n    char        fill            = '#';\n    char        empty           = '.';\n    char        left            = '[';\n    char        right           = ']';\n    std::string estimate_prefix = \"(remaining: \";\n    std::string estimate_suffix = \")\";\n} style;\n\nbool show_bar        = true;\nbool show_percentage = true;\nbool show_estimate   = true;\n\nstd::size_t bar_length  = 30;\ndouble      update_rate = 2.5e-3;\n</code></pre> <p>Style parameters that can be adjusted:</p> Option Description <code>style.fill</code> Character used for \"filled\" part of the bar <code>style.empty</code> Character used for \"empty\" part of the bar <code>style.left</code> Character used for the left end of the bar <code>style.right</code> Character used for the right end of the bar <code>style.estimate_prefix</code> Text displayed before the time estimate <code>style.estimate_suffix</code> Text displayed after the time estimate <code>show_bar</code> Whether to render the main bar display <code>show_percentage</code> Whether to render a numeric label after the bar <code>show_estimate</code> Whether to render a remaining time estimate <code>bar_length</code> Progress bar length in characters <code>update_rate</code> How often should the bar update, <code>1e-2</code> corresponds to <code>1%</code> <p>Note: Progress bar style doesn't update until the next redraw. Immediate redraw can be triggered using <code>update_style()</code>.</p> <pre><code>Percentage();\nvoid Percentage::set_progress(double value);\nvoid Percentage::finish();\n</code></pre> <p>Start, update &amp; finish progress bar display. Progress is a <code>value</code> in <code>[0, 1]</code> range, corresponding to a portion of total workload.</p> <pre><code>void update_style();\n</code></pre> <p>Redraws progress bar to update its style configuration immediately.</p>"},{"location":"module_progressbar.html#ruler-progress-bar","title":"<code>Ruler</code> progress bar","text":"<p>Note</p> <p>This is a very minimalistic progress bar, it should be used for terminals that do not support <code>\\r</code>.</p> <pre><code>// - Style configuration -\nstruct Style {\n    char fill            = '#';\n    char ruler_line      = '-';\n    char ruler_delimiter = '|';\n} style;\n\nbool show_ticks = true;\nbool show_ruler = true;\nbool show_bar   = true;\n</code></pre> <p>Style parameters that can be adjusted:</p> Option Description <code>style.fill</code> Character used for \"filled\" part of the bar <code>style.ruler_line</code> Character used for \"line\" part of the ruler above <code>style.ruler_delimiter</code> Character used for delimiter on of the ruler above <code>show_ticks</code> Whether to render the main bar display <code>show_ruler</code> Whether to render a numeric label after the bar <code>show_bar</code> Whether to render a remaining time estimate <p>Note: Disabling <code>show_bar</code> makes little practical sense, considering it makes progress bar not display any progress, but it is still provided for the sake of API uniformity.</p> <pre><code>Ruler();\nvoid Ruler::set_progress(double percentage);\nvoid Ruler::finish();\n</code></pre> <p>Start, update &amp; finish progress bar display. Progress is a <code>value</code> in <code>[0, 1]</code> range, corresponding to a portion of total workload.</p> <pre><code>void update_style();\n</code></pre> <p>Redraws progress bar to update its style configuration immediately.</p>"},{"location":"module_progressbar.html#examples","title":"Examples","text":""},{"location":"module_progressbar.html#progress-bar","title":"Progress bar","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\nusing namespace std::chrono_literals;\n\nconst int  iterations = 1500;\nconst auto some_work  = [] { std::this_thread::sleep_for(10ms); };\n\nprogressbar::Percentage bar;\nfor (int i = 0; i &lt; iterations; ++i) {\n    some_work();\n    bar.set_progress((i + 1.) / iterations);\n}\nbar.finish();\n</code></pre> <p>Output (at some point in time): <pre><code>[############..................] 42.67% (remaining: 8 sec)\n</code></pre></p>"},{"location":"module_progressbar.html#progress-bar-with-custom-style","title":"Progress bar with custom style","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\nusing namespace std::chrono_literals;\n\nconst int  iterations = 1500;\nconst auto some_work  = [] { std::this_thread::sleep_for(10ms); };\n\nprogressbar::Percentage bar;\n\nbar.show_bar              = false;\nbar.style.estimate_prefix = \"complete, remaining time: \";\nbar.style.estimate_suffix = \"\";\n\nbar.update_style();\n\nfor (int i = 0; i &lt; iterations; ++i) {\n    some_work();\n    bar.set_progress((i + 1.) / iterations);\n}\nbar.finish();\n</code></pre> <p>Output (at some point in time): <pre><code>68.00% complete, remaining time: 4 sec\n</code></pre></p>"},{"location":"module_random.html","title":"utl::random","text":""},{"location":"module_random.html#utlrandom","title":"utl::random","text":"<p>&lt;- to README.md</p> <p>&lt;- to implementation.hpp</p> <p>utl::random module implements several additions to std &lt;random&gt; that aim to:</p> <ul> <li>Make random friendlier for the \"naive\" use without compromising on quality</li> <li>Improve random performance</li> </ul> <p>The module was created during my past work on a thesis that used stochastic differential equations and Monte\u2014Carlo method to model explosive heat transfer in a turbulent flow.</p> <p>It implements several random bit generators seamlessly compatible with &lt;random&gt;:</p> <ul> <li>16-bit Romu Mono PRNG</li> <li>32-bit Romu Trio PRNG</li> <li>32-bit SplitMix PRNG</li> <li>32-bit Xoshiro128++ PRNG</li> <li>64-bit Romu Duo Jr. PRNG</li> <li>64-bit SplitMix PRNG</li> <li>64-bit Xoshiro256++ PRNG</li> <li>ChaCha8 CSPRNG</li> <li>ChaCha12 CSPRNG</li> <li>ChaCha20 CSPRNG</li> </ul> <p>These pseudorandom number generators (aka PRNGs) cover most of the common uses cases better than somewhat outdated standard library PRNGs, see notes on random number generation.</p> <p>Why use <code>utl::random</code> over built-in functions?</p> <ul> <li>Easier API for most \"daily\" use cases</li> <li>Likely to be faster than built-in methods</li> <li>Provides better quality random than built-in methods</li> <li>Reproducible results, built-in engines may differ compiler to compiler</li> <li>Random generators &amp; distributions work even in <code>constexpr</code> context</li> <li>Almost everything is <code>noexcept</code></li> <li>An option to use cryptographically secure PRNGs</li> <li>More reliable sources of entropy than std::random_device</li> </ul>"},{"location":"module_random.html#definitions","title":"Definitions","text":"<pre><code>// PRNG implementations\nnamespace generators {\n    class GeneratorAPI {\n        using result_type;\n\n        static constexpr result_type min() noexcept;\n        static constexpr result_type max() noexcept;\n\n        constexpr GeneratorAPI(result_type seed) noexcept;\n        constexpr void    seed(result_type seed) noexcept;\n\n        template&lt;class SeedSeq&gt; GeneratorAPI(SeedSeq&amp; seq);\n        template&lt;class SeedSeq&gt; void    seed(SeedSeq&amp; seq);\n\n        constexpr result_type operator()() noexcept;\n    };\n\n    // 16-bit PRNGs\n    class RomuMono16   { /* Generator API */ };\n    // 32-bit PRNGs\n    class RomuTrio32   { /* Generator API */ };\n    class SplitMix32   { /* Generator API */ };\n    class Xoshiro128PP { /* Generator API */ };\n    // 64-bit PRNGs\n    class RomuDuoJr64  { /* Generator API */ };\n    class SplitMix64   { /* Generator API */ };\n    class Xoshiro256PP { /* Generator API */ };\n    // CSPRNGs\n    class ChaCha8      { /* Generator API */ };\n    class ChaCha12     { /* Generator API */ };\n    class ChaCha20     { /* Generator API */ };\n}\n\n// Entropy\nstd::seed_seq entropy_seq();\nstd::uint32_t entropy();\n\n// Distributions\ntemplate &lt;class T&gt;\nstruct UniformIntDistribution   { /* same API as std::uniform_int_distribution&lt;T&gt;  */ };\ntemplate &lt;class T&gt;\nstruct UniformRealDistribution  { /* same API as std::uniform_real_distribution&lt;T&gt; */ };\ntemplate &lt;class T&gt;\nstruct NormalDistribution       { /* same API as std::normal_distribution&lt;T&gt;       */ };\ntemplate &lt;class T&gt;\nstruct ApproxNormalDistribution { /* same API as std::normal_distribution&lt;T&gt;       */ };\n\ntemplate &lt;class T, class Gen&gt;\nconstexpr T generate_canonical(Gen&amp; gen) noexcept(noexcept(gen()));\n\n// Default PRNG\nusing PRNG = generators::Xoshiro256PP;\n\nPRNG&amp; thread_local_prng();\n\n// Convenient random (generic)\ntemplate &lt;class Dist&gt; auto variate(Dist&amp;&amp; dist); // any distribution\n\ntemplate &lt;class T&gt; T uniform(T min, T max); // integer U[min, max]\ntemplate &lt;class T&gt; T uniform(            ); // boolean U[0, 1]\ntemplate &lt;class T&gt; T uniform(T min, T max); // float   U[min, max)\ntemplate &lt;class T&gt; T uniform(            ); // float   U[0, 1)\n\ntemplate &lt;class T&gt; T normal(T mean, T stddev); // float N(mean, stddev)\ntemplate &lt;class T&gt; T normal(                ); // float N(0, 1)\n\n// Convenient random (shortcuts for standard types)\nusing Uint = unsigned int;\n\nint    uniform_int   (   int min,    int max); // U[min, max]\nUint   uniform_uint  (  Uint min,   Uint max); // U[min, max]\nbool   uniform_bool  (                      ); // U[0, 1]\nfloat  uniform_float ( float min,  float max); // U[min, max)\ndouble uniform_double(double min, double max); // U[min, max)\nfloat  uniform_float (                      ); // U[0, 1)\ndouble uniform_double(                      ); // U[0, 1)\n\nfloat  normal_float ( float mean,  float stddev); // N(mean, stddev)\ndouble normal_double(double mean, double stddev); // N(mean, stddev)\nfloat  normal_float (                          ); // N(0, 1)\ndouble normal_double(                          ); // N(0, 1)\n\n// Convenient random (other)\ntemplate &lt;class T&gt;            T choose(std::initializer_list&lt;T&gt; list);\ntemplate &lt;class Container&gt; auto choose(const Container&amp;         list);\n</code></pre>"},{"location":"module_random.html#methods","title":"Methods","text":""},{"location":"module_random.html#random-bit-generators","title":"Random bit generators","text":"<pre><code>class GeneratorAPI {\n    using result_type;\n\n    static constexpr result_type min() noexcept;\n    static constexpr result_type max() noexcept;\n\n    constexpr GeneratorAPI(result_type seed) noexcept;\n    constexpr void    seed(result_type seed) noexcept;\n\n    template&lt;class SeedSeq&gt; GeneratorAPI(SeedSeq&amp; seq);\n    template&lt;class SeedSeq&gt; void    seed(SeedSeq&amp; seq);\n\n    constexpr result_type operator()() noexcept;\n};\n\n// 16-bit PRNGs\nclass RomuMono16   { /* Generator API */ };\n// 32-bit PRNGs\nclass RomuTrio32   { /* Generator API */ };\nclass SplitMix32   { /* Generator API */ };\nclass Xoshiro128PP { /* Generator API */ };\n// 64-bit PRNGs\nclass RomuDuoJr64  { /* Generator API */ };\nclass SplitMix64   { /* Generator API */ };\nclass Xoshiro256PP { /* Generator API */ };\n// CSPRNGs\nclass ChaCha8      { /* Generator API */ };\nclass ChaCha12     { /* Generator API */ };\nclass ChaCha20     { /* Generator API */ };\n</code></pre> <p>All of these generators satisfy uniform random bit generator generator requirements and std::uniform_random_bit_generator concept, which makes them drop-in replacements for standard generators such as <code>std::mt19937</code>.</p> <p>Unlike standard generators these can also be used in <code>constexpr</code> functions.</p> <p>Note: All provided PRNGs have <code>min() == 0</code> and <code>max() == std::numeric_limits&lt;result_type&gt;::max()</code>.</p>"},{"location":"module_random.html#entropy","title":"Entropy","text":"<pre><code>std::seed_seq entropy_seq();\nstd::uint32_t entropy();\n</code></pre> <p>These functions serve a role of a \"slightly better and more convenient std::random_device\".</p> <p><code>std::random_device</code> has a critical deficiency in it's design \u2014 in case its implementation doesn't provide a proper source of entropy, it is free to fallback onto a regular PRNGs that don't change from run to run. The method std::random_device::entropy() which should be able to detect that information is notoriously unreliable and returns different things on every platform.</p> <p><code>entropy()</code> samples several sources of entropy (including the <code>std::random_device</code> itself) and is (almost) guaranteed to change from run to run even if it can't provide a proper hardware-sourced entropy that would be suitable for cryptography. It can be used as a drop-in replacement to <code>std::random_device{}()</code> calls.</p> <p><code>entropy_seq()</code> generates a full std::seed_seq instead of a single number, it is mainly useful for seeding generators with a large state.</p> <p>Note: Entropy functions are thread-safe.</p>"},{"location":"module_random.html#distributions","title":"Distributions","text":""},{"location":"module_random.html#uniform-integer-distribution","title":"Uniform integer distribution","text":"<pre><code>template &lt;class T&gt;\nstruct UniformIntDistribution {\n    /* ... */\n};\n</code></pre> <p>Uniform integer distribution class that provides a 1-to-1 copy of <code>std::uniform_int_distribution</code> API, except:</p> <ul> <li>Everything is <code>constexpr</code> and <code>noexcept</code></li> <li><code>operator()</code> is <code>const</code>-qualified</li> <li><code>std::uint8_t</code>, <code>std::int8_t</code> and <code>char</code>, <code>std::char8_t</code>, <code>std::char16_t</code>, <code>std::char32_t</code> specializations are properly supported</li> <li>Distribution sequence is platform-independent</li> </ul> <p>Note: This is a close reimplementation of <code>std::uniform_int_distribution</code> for GCC libstdc++ with some additional considerations, it provides similar performance and in some cases may even produce the same sequence.</p>"},{"location":"module_random.html#uniform-real-distribution","title":"Uniform real distribution","text":"<pre><code>template &lt;class T&gt;\nstruct UniformRealDistribution {\n    /* ... */\n};\n</code></pre> <p>Uniform floating-point distribution class that provides a 1-to-1 copy of <code>std::uniform_real_distribution</code> API, except:</p> <ul> <li>Everything is <code>constexpr</code> and <code>noexcept</code></li> <li><code>operator()</code> is <code>const</code>-qualified</li> <li>Performance on a common use case is drastically improved (~1.3 to ~4 times faster <code>double</code> and <code>float</code> generation)</li> <li>Distribution sequence is platform-independent</li> </ul> <p>Note: This is a close reimplementation of <code>std::uniform_real_distribution</code> for MSVC STL with some additional considerations and special logic for common optimizable cases.</p> <p>How is it faster than std: Parts of <code>std::generate_canonical&lt;&gt;()</code> which is used by  <code>std::uniform_real_distribution</code> can be moved to <code>constexpr</code> , avoiding the runtime <code>std::log()</code> computation. Some cases such as <code>double</code> &amp; <code>float</code> generation with bit-uniform PRNGs (aka all PRNGs of this module and <code>std::mt19937</code>) can be handled with a simple bitmask rather than a generic implementation of <code>std::generate_canonical&lt;&gt;()</code> which accounts for all the esoteric PRNGs with weird ranges that could exist. This produces a speedup of up to 4 times. Combined with a speedup from faster PRNGs it is possible to achieve over 10 times faster random <code>double</code> generation in an interval.</p> <pre><code>template &lt;class T, class Gen&gt;\nconstexpr T generate_canonical(Gen&amp; gen) noexcept(noexcept(gen()));\n</code></pre> <p>Generates a random floating point number in range \\([0, 1)\\) similarly to <code>std::generate_canonical&lt;&gt;()</code>.</p> <p>Always generates <code>std::numeric_limits&lt;T&gt;::digits</code> bits of randomness, which is enough to fill the mantissa. See <code>UniformRealDistribution</code> for notes on implementation improvements.</p>"},{"location":"module_random.html#normal-distribution","title":"Normal distribution","text":"<pre><code>template &lt;class T&gt;\nstruct NormalDistribution {\n    /* ... */\n};\n</code></pre> <p>Normal floating-point distribution class that provides a 1-to-1 copy of <code>std::normal_distribution</code> API, except:</p> <ul> <li>Everything is <code>noexcept</code></li> <li>Performance on a common use case is slightly improved (~1.1 to ~1.3 times faster distribution)</li> <li>Distribution sequence is platform-independent</li> </ul> <p>How is it faster than std: It uses faster uniform real distribution for rejection sampling, the underlying Marsaglia polar method itself is implemented exactly the same as in all major compilers.</p>"},{"location":"module_random.html#approximate-normal-distribution","title":"Approximate normal distribution","text":"<pre><code>template &lt;class T&gt;\nstruct ApproxNormalDistribution {\n    /* ... */\n};\n</code></pre> <p>Normal floating-point distribution class that provides a 1-to-1 copy of <code>std::normal_distribution</code> API, except:</p> <ul> <li>Everything is <code>constexpr</code> and <code>noexcept</code></li> <li><code>operator()</code> is <code>const</code>-qualified</li> <li>Extremely good performance (~4 times faster distribution) at the cost of precision (see distribution approximations)</li> <li>Distribution sequence is platform-independent</li> </ul> <p>How is it faster than std: It uses the fact that popcount of a uniformly distributed integer follows a binomial distribution. By rescaling that binomial distribution and adding some linear fill we can achieve a curve very similar to a proper normal distribution in just a few instructions. While that level of precision is not suitable for a general use, in instances where quality is not particularly important (gamedev, fuzzing) this is perhaps the fastest possible way of generating normally distributed floats.</p>"},{"location":"module_random.html#default-prng","title":"Default PRNG","text":"<pre><code>using PRNG = generators::Xoshiro256PP;\n</code></pre> <p>Typedef for a default PRNG. Good choice for most applications.</p> <pre><code>PRNG&amp; thread_local_prng();\n</code></pre> <p>Thread-local PRNG automatically seeded with entropy.</p>"},{"location":"module_random.html#convenient-random","title":"Convenient random","text":"<p>Note</p> <p>This is a <code>rand()</code>-like API for various distributions. Uses thread-local PRNG lazily seeded with entropy.</p>"},{"location":"module_random.html#generic","title":"Generic","text":"<pre><code>template &lt;class Dist&gt; auto variate(Dist&amp;&amp; dist); // any distribution\n</code></pre> <p>Returns value from distribution <code>dist</code> using thread-local random generator.</p> <p>Effectively equivalent to <code>dist(thread_local_prng())</code>.</p> <pre><code>template &lt;class T&gt; T uniform(T min, T max); // integer U[min, max]\ntemplate &lt;class T&gt; T uniform(            ); // boolean U[0, 1]\n</code></pre> <p>Returns random integer <code>T</code> in a \\([min, max]\\) range.</p> <p>When <code>T</code> is a <code>bool</code>, function doesn't require any arguments.</p> <pre><code>template &lt;class T&gt; T uniform(T min, T max); // float   U[min, max)\ntemplate &lt;class T&gt; T uniform(            ); // float   U[0, 1)\n</code></pre> <p>Returns random floating point <code>T</code> in a \\([min, max)\\) range.</p> <p>When no arguments are passed uses \\([0, 1)\\) range. </p> <pre><code>template &lt;class T&gt; T normal(T mean, T stddev); // float N(mean, stddev)\ntemplate &lt;class T&gt; T normal(                ); // float N(0, 1)\n</code></pre> <p>Returns random normally distributed <code>T</code> with <code>mean</code> and <code>stddev</code>.</p> <p>When no arguments are passed uses standard mean and deviation.</p>"},{"location":"module_random.html#shortcuts-for-standard-types","title":"Shortcuts for standard types","text":"<pre><code>int    uniform_int   (   int min,    int max); // U[min, max]\nUint   uniform_uint  (  Uint min,   Uint max); // U[min, max]\nbool   uniform_bool  (                      ); // U[0, 1]\n</code></pre> <p><code>int</code>, <code>unsigned int</code> and <code>bool</code> instantiations of the integer <code>uniform&lt;T&gt;()</code>.</p> <pre><code>float  uniform_float ( float min,  float max); // U[min, max)\ndouble uniform_double(double min, double max); // U[min, max)\nfloat  uniform_float (                      ); // U[0, 1)\ndouble uniform_double(                      ); // U[0, 1)\n</code></pre> <p><code>float</code> and <code>double</code> instantiations of the floating point <code>uniform&lt;T&gt;()</code>.</p> <pre><code>float  normal_float ( float mean,  float stddev); // N(mean, stddev)\ndouble normal_double(double mean, double stddev); // N(mean, stddev)\nfloat  normal_float (                          ); // N(0, 1)\ndouble normal_double(                          ); // N(0, 1)\n</code></pre> <p><code>float</code> and <code>double</code> instantiations of the <code>normal&lt;T&gt;()</code>.</p>"},{"location":"module_random.html#other","title":"Other","text":"<pre><code>template &lt;class T&gt;            T choose(std::initializer_list&lt;T&gt; list);\ntemplate &lt;class Container&gt; auto choose(const Container&amp;         list);\n</code></pre> <p>Returns random element from a <code>list</code>.</p> <p>Generic template requires <code>Container::at()</code> and <code>Container::size()</code> to exist.</p>"},{"location":"module_random.html#examples","title":"Examples","text":""},{"location":"module_random.html#getting-random-values","title":"Getting random values","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\n// Generic functions\nstd::cout\n    &lt;&lt; \"integer U[-5, 5] -&gt; \" &lt;&lt; random::uniform(-5, 5)    &lt;&lt; \"\\n\"\n    &lt;&lt; \"boolean U[0, 1]  -&gt; \" &lt;&lt; random::uniform&lt;bool&gt;()   &lt;&lt; \"\\n\"\n    &lt;&lt; \"float   U[1, 2)  -&gt; \" &lt;&lt; random::uniform(1.f, 2.f) &lt;&lt; \"\\n\"\n    &lt;&lt; \"float   U[0, 1)  -&gt; \" &lt;&lt; random::uniform&lt;float&gt;()  &lt;&lt; \"\\n\";\n\n// Standard shortcuts\nstd::cout\n    &lt;&lt; \"U[0, 1] -&gt; \" &lt;&lt; random::uniform_bool()  &lt;&lt; \"\\n\"\n    &lt;&lt; \"N(0, 1) -&gt; \" &lt;&lt; random::normal_double() &lt;&lt; \"\\n\";\n\n// Other distributions\nstd::cout\n    &lt;&lt; \"Exp(4) -&gt; \" &lt;&lt; random::variate(std::exponential_distribution{4.f})  &lt;&lt; \"\\n\";\n</code></pre> <p>Output: <pre><code>integer U[-5, 5] -&gt; 4\nboolean U[0, 1]  -&gt; 1\nfloat   U[1, 2)  -&gt; 1.57933\nfloat   U[0, 1)  -&gt; 0.787372\n\nU[0, 1] -&gt; 0\nN(0, 1) -&gt; -0.391094\n\nExp(4) -&gt; 0.384687\n</code></pre></p>"},{"location":"module_random.html#using-custom-prngs-with-random","title":"Using custom PRNGs with &lt;random&gt;","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\nrandom::generators::SplitMix64 gen{random::entropy()};\nstd::chi_squared_distribution distr{2.}; // Chi-squared distribution with N = 2\n\nstd::cout &lt;&lt; \"Random value from distribution -&gt; \" &lt;&lt; distr(gen) &lt;&lt; \"\\n\";\n</code></pre> <p>Output: <pre><code>Random value from distribution -&gt; 4.80049\n</code></pre></p>"},{"location":"module_random.html#constexpr-random","title":"Constexpr random","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\ntemplate &lt;std::size_t size&gt;\nconstexpr auto random_integers(std::uint64_t seed, int min, int max) {\n    std::array&lt;int, size&gt;          res{};\n    random::UniformIntDistribution dist{min, max};\n    random::PRNG                   gen(seed);\n\n    for (auto &amp;e : res) e = dist(gen);\n    return res;\n}\n\n// ...\n\nconstexpr auto random_array = random_integers&lt;6&gt;(0, -10, 10);\n\nlog::println(random_array); // using another module for convenience\n\n// compile-time random like this can be used to automatically build\n// lookup tables and generate seemingly random patterns\n</code></pre> <p>Output: <pre><code>{ -4, -2, -3, -10, 0, -10 }\n</code></pre></p>"},{"location":"module_random.html#improving-entropy-with-x86x64-intrinsics","title":"Improving entropy with x86/x64 intrinsics","text":"<p><code>utl::random</code> can also make use of x86/x64 intrinsics, to enable their usage simply define <code>UTL_RANDOM_USE_INTRINSICS</code> before including the header:</p> <pre><code>#define UTL_RANDOM_USE_INTRINSICS\n#include \"UTL/random.hpp\" // will now use intrinsics\n</code></pre> <p>This achieves two things:</p> <ul> <li><code>entropy()</code> and <code>entropy_seq()</code> will now use CPU-counter intrinsics as an additional source of relatively high-quality entropy</li> <li>MSVC will now use a more efficient implementation of 64-bit <code>UniformIntDistribution</code></li> </ul>"},{"location":"module_random.html#notes-on-random-number-generation","title":"Notes on random number generation","text":"<p>As of 2025, the selection of pseudorandom number generators (aka PRNGs) in the standard library &lt;random&gt; is quite outdated, with most generators being developed before year 2000 and providing sub-par characteristics relative to what can be achieved.</p> <p>While suitable for most uses cases, better performance &amp; quality can be achieved virtually \"for free\" by switching to some of the newer PRNG implementations.</p> <p>Thankfully, <code>&lt;random&gt;</code> design is quite flexible and fully abstracts the concept of a random bit generator, which makes it seamlessly compatible with any custom PRNG that exposes the necessary API.</p> <p><code>utl::random</code> provides <code>&lt;random&gt;</code>-compatible implementations of several modern PRNGs. By default, rand functions from this header use Xoshiro256++ as it is well tested, used by several languages (Rust, Julia, slightly different version is used by .NET, GNU FORTRAN and Lua) as their default and provides an excellent balance of speed and statistical quality.</p>"},{"location":"module_random.html#overview-of-available-prngs","title":"Overview of available PRNGs","text":"Generator Performance Memory Result type Quality Period Motivation <code>RomuMono16</code> ~500% 4 bytes <code>std::uint16_t</code> \u2605\u2605\u2606\u2606\u2606 \\(\\approx 2^{32}\\) Fastest 16-bit PRNG \u207d\u00b9\u207e <code>RomuTrio32</code> ~470% 12 bytes <code>std::uint32_t</code> \u2605\u2605\u2606\u2606\u2606 Chaotic \u207d\u00b2\u207e Fastest 32-bit PRNG <code>SplitMix32</code> ~540% 4 bytes <code>std::uint32_t</code> \u2605\u2605\u2605\u2606\u2606 \\(2^{32}\\) Smallest state 32-bit PRNG <code>Xoshiro128PP</code> ~375% 16 bytes <code>std::uint32_t</code> \u2605\u2605\u2605\u2605\u2606 \\(2^{128} \u2212 1\\) Best all purpose 32-bit PRNG <code>RomuDuoJr64</code> ~600% 16 bytes <code>std::uint64_t</code> \u2605\u2605\u2606\u2606\u2606 Chaotic Fastest 64-bit PRNG <code>SplitMix64</code> ~540% 8 bytes <code>std::uint64_t</code> \u2605\u2605\u2605\u2605\u2606 \\(2^{64}\\) Smallest state 64-bit PRNG <code>Xoshiro256PP</code> ~385% 32 bytes <code>std::uint64_t</code> \u2605\u2605\u2605\u2605\u2606 \\(2^{256} \u2212 1\\) Best all purpose 64-bit PRNG <code>ChaCha8</code> \u207d\u00b3\u207e ~125% 120 bytes <code>std::uint32_t</code> \u2605\u2605\u2605\u2605\u2605 \\(2^{128}\\) Cryptographically secure PRNG <code>ChaCha12</code> ~105% 120 bytes <code>std::uint32_t</code> \u2605\u2605\u2605\u2605\u2605 \\(2^{128}\\) Cryptographically secure PRNG <code>ChaCha20</code> ~70% 120 bytes <code>std::uint32_t</code> \u2605\u2605\u2605\u2605\u2605 \\(2^{128}\\) Cryptographically secure PRNG <code>std::minstd_rand</code> 100% 8 bytes <code>std::uint64_t</code> \u2605\u2606\u2606\u2606\u2606 \\(2^{31} \u2212 1\\) <code>rand()</code> ~80% Platform-dependent \u207d\u2074\u207e <code>int</code> \u2605\u2606\u2606\u2606\u2606 Platform-dependent <code>std::mt19937</code> ~105% 5000 bytes <code>std::uint32_t</code> \u2605\u2605\u2605\u2606\u2606 \\(2^{19937} \u2212 1\\) <code>std::knuth_b</code> ~55% 2064 bytes <code>std::uint64_t</code> \u2605\u2605\u2606\u2606\u2606 \\(2^{31} \u2212 1\\) <code>std::ranlux48</code> ~4% 120 bytes <code>std::uint64_t</code> \u2605\u2605\u2605\u2605\u2606 \\(\\approx 2^{576}\\) <p>Important</p> <p>Performance ratings are relative to the commonly used  <code>std::minstd_rand</code> / <code>rand()</code>.  Particular numbers may differ depending on the hardware and compilation settings, however general trends tend to stay the same. Results above were measured on <code>AMD Ryzen 5 5600H</code> with <code>g++ 11.4.0</code>. Benchmarks can be found here.</p> <p>Important</p> <p>Performance is measured in values per unit of time, to get a bytes per unit of time metric, the measurements can be normalized by a <code>sizeof(result_type)</code>, making 32-bit generators effectively two times slower than listed in the table.</p> <p>Note</p> <p>(1) Here \"fastest\" also takes into account such things as register pressure and \"friendliness\" towards instruction-level parallelism, which is not always apparent on a heavily loaded benchmark.</p> <p>Note</p> <p>(2) Non-linear PRNGs also known as \"chaotic PRNGs\" have a cycle length that is different for each seed. This introduces a theoretical possibility of encountering short cycles, but opens up several avenues for optimization.</p> <p>Note</p> <p>(3) The difference between <code>ChaCha8</code>, <code>ChaCha12</code> and <code>ChaCha20</code> is the number of stream cypher rounds \u2014 8, 12 and 20 correspondingly. More rounds make the state more difficult to discover, but have a negative effect on performance. As of now (year 2025) <code>ChaCha12</code> seems like a reasonable default since it provides 5 rounds of security margin over the best known attack.</p> <p>Note</p> <p>(4) <code>C</code> function rand() is implementation-defined, on most existing implementations it uses an old LCG engine similar to <code>std::minstd_rand</code>. It is generally an extremely low-quality way of generating random and faces a host of additional issues on platforms with low <code>RAND_MAX</code>, which includes Windows where <code>RAND_MAX</code> is equal <code>32767</code> (less than 2 bytes of information, an almost ridiculous value, really). GCC, which is used in this benchmark, implements <code>rand()</code> using linear feedback shift register, which is less likely to encounter the most blatant of issues, but is still ultimately an inferior approach.</p> <p>Random quality ratings are as follows:</p> Quality rating Usage Quality description \u2605\u2605\u2605\u2605\u2605 Suitable for cryptography Cryptographically secure, satisfies CSPRNG requirements, this usually comes at the price of performance \u2605\u2605\u2605\u2605\u2606 Suitable for most use cases No significant issues in qualitative testing, passes TestU01 Big Crush \u2605\u2605\u2605\u2606\u2606 Suitable for most use cases No significant issues in qualitative testing, might fail a few tests on Big Crush \u2605\u2605\u2606\u2606\u2606 Suitable for simple applications Significant flaws in statistical quality in certain aspects \u2605\u2606\u2606\u2606\u2606 Suitable for simple applications Significant flaws in statistical quality all-around"},{"location":"module_random.html#why-rng-quality-matters","title":"Why RNG quality matters","text":"<p>Using low-quality random may introduce artificial biases and unexpected effects into what should be a stochastic simulation. Below are some examples of such effects:</p> <ul> <li>Inaccurate statical estimates in Monte\u2014Carlo simulations and stochastic modeling</li> <li>Biased optimizations in genetic algorithms</li> <li>Noticeable biases in entity path finding and behavior in games</li> <li>Issues in procedural generation</li> </ul> <p>These issues become particularly dangerous and difficult to diagnose in multidimensional simulations, as a lot of older PRNGs have significant statistical issues in higher dimensions that simply aren't apparent in a 1D case. </p> <p>In general, most statistical issues fall into following groups:</p> <ul> <li>Shorter-than-expected periods for some seed states</li> <li>Non-uniform distribution of values over the output range</li> <li>Correlation of successive values</li> <li>Correlation of successive bits in a value</li> <li>Correlation of successive seeds</li> <li>Poor dimensional distribution of the output sequence</li> </ul>"},{"location":"module_random.html#visual-examples","title":"Visual examples","text":""},{"location":"module_random.html#randu","title":"RANDU","text":"<p>The most famous example of low-quality random is IBM's RANDU (a variation of the same LCG used by most <code>C</code> programmers to this day) which was widely used in 1960s and 1970s for the lack of a better knowledge.</p> <p>As a simplest showcase of its flaws, let's generate <code>10000</code> random points in a \\([0, 1]^3\\) cube, each points will generate with coordinates <code>{ randu(), randu(), randu() }</code>. After plotting the resulting picture and looking at it from a correct angle, we can clearly see that all points fall into just 15 distinct planes:</p> <p></p> <p></p> <p>What we just observed is called \"failing the spectral test at an extremely low dimension\", and for RANDU that dimension is 3. Such quality is clearly not something one would want in their Monte\u2014Carlo simulation with \"random\" realizations.</p> <p>In fact, this quality is generic to all LCGs \u2014 any LCG with modulus \\(m\\) used to generate points in \\(N\\)-dimensional space will result in no more that \\((N! \\times m)^{1/N}\\) hyperplanes, with other LCG implementations it's just not as noticeable that one could see the planes visually.</p>"},{"location":"module_random.html#minstd_rand-rand","title":"minstd_rand &amp; rand()","text":"<p>While RANDU algorithm is no longer in use today, its family of algorithms (LCG) is still frequently used through <code>rand()</code> and <code>std::minstd_rand</code>, with <code>rand()</code> being the worst offender as it is the default way of generating random numbers in <code>C</code> (<code>C++</code> guides and documentation tend to prefer <code>std::mt19937</code> which despite not being ideal avoids most of the significant issues).</p> <p>Note: Since nothing in the standard specifies how <code>rand()</code> should be implemented it is generally not something one could rely upon, in most cases it's LCG, sometimes it's linear-feedback shift register which is a little better.</p> <p>We can easily demonstrate a significant correlation of successive seeds in the default implementation by creating a \\(160 \\times 200\\) matrix of random <code>1</code>s and <code>0</code>s, while re-seeding the generator with <code>i</code> at the beginning of each row <code>i</code>. This will lead to a following image:</p> <p></p> <p>Using <code>std::mt19937</code> (or any other even slightly sensible engine) will not lead to such an horrific correlation, we get a visually uniform image:</p> <p></p> <p>In practice, something like this would be encountered during any stochastic simulation where each run is simulated with a new seed.</p>"},{"location":"module_random.html#why-not-just-use-mersenne-twister","title":"Why not just use Mersenne Twister","text":"<p>One could argue that a widely used Mersenne Twister, which, in case of <code>C++</code> is called <code>std::mt19937</code> should be good enough for most purposes and that is true. For quite a while Mersenne Twister used to be the default choice for new RNG facilities \u2014 it is acceptably performant and has a decent statistical quality with a huge period.</p> <p>However Mersenne Twister still fails some of the less obvious statistical tests on TestU01 BigCrush, combined with rather subpar performance relative to the newer methods and a huge state (5000 bytes against 32 used by Xoshiro256++) there is little reason to use it in a modern environment.</p> <p>This trend can be observed rather clearly by looking at the lineup of default PRNGs used in different programming languages:</p> Language Fist release Default PRNG Quality <code>C</code> 1972 LCG Bad <code>Matlab</code> 1979 Mersenne Twister Decent <code>C++</code> 1985 Mersenne Twister / LCG Decent / Bad <code>Python</code> 1991 Mersenne Twister Decent <code>GNU Octave</code> 1993 Mersenne Twister Decent <code>Python NumPy</code> 2006 Mersenne Twister (below v.1.17) \u2794 PCG64 (above v.1.17) Decent \u2794 Good <code>Julia</code> 2012 Xoshiro256++ Good <code>Rust</code> 2015 ChaCha12 / Xoshiro256++ Good <code>.NET</code> 2016 Subtractive Generator (below v.6) \u2794 Xoshiro256**\u00a0(above v.6) Decent \u2794 Good <p>While older languages usually stick to their already existing implementations, newer projects tend to choose modern PRNGs for the purpose. This establishes a strong case for switching to using <code>Xoshiro</code> / <code>PCG</code> family of PRNGs as a default choice in new projects. Engines of families such as <code>ChaCha</code> and <code>ISAAC</code> also provide cryptographic security to the random sequence, which in essence means that the state of the engine cannot be easily discovered from a piece of its random sequence. This usually has a noticeable performance cost, however even they fair rather well compared to the old monsters such as <code>std::ranlux48</code> which runs almost 80 times slower than Xoshiro256++.</p>"},{"location":"module_random.html#additional-considerations","title":"Additional considerations","text":""},{"location":"module_random.html#output-range","title":"Output range","text":"<p>In practice, most PRNG outputs aren't used directly as they are generated but rather pass through an additional layer of abstraction such as, for example <code>std::uniform_int_distribution</code>, to compute a distributed value.</p> <p>This has a noticeable effect on quality and performance of some PRNGs, for example, engines with <code>::min() != 0</code> or <code>::max() != std::numeric_limits&lt;result_type&gt;::max()</code> are inherently at a disadvantage due to preventing the usage of Lemire's algorithm for uniform integer distribution in an interval, which makes <code>libstdc++</code> fallback onto a significantly slower generic algorithm, effectively making the PRNG benchmark misleading about real performance.</p> <p>For this reason all generators selected for this module provide a full range from <code>0</code> to <code>std::numeric_limits&lt;result_type&gt;::max()</code> and try to avoid \"surprises\".</p>"},{"location":"module_random.html#seeding","title":"Seeding","text":"<p>Some engines can be \"picky\" about zero-seeding or require a non-trivial seeding with <code>std::seed_seq</code> which is cumbersome and difficult to get right. This is exactly the case with widely used <code>std::mt19937</code> which is usually seeded like this:</p> <pre><code>std::random_device rd; // create source of entropy\n\nstd::mt19937 gen{rd()}; // seed with too little state\n</code></pre> <p>This is not nearly enough entropy for a huge state of <code>std::mt19937</code>, a \"proper\" way of seeding would be using more entropy and \"spreading\" it to the state using <code>std::seed_seq</code>:</p> <pre><code>std::random_device rd;\nstd::array&lt;std::mt19937::result_type, std::mt19937::state_size&gt; seed;\nstd::generate_n(seed.data(), seed.size(), std::ref(rd));\nstd::seed_seq seq(seed.begin(), seed.end());\nstd::mt19937 gen(seq);\n</code></pre> <p>Such approach however is beyond cumbersome and is rarely used in practice, which is why it is sensible to pick generators that work well with a single-number seeding as a default option.</p>"},{"location":"module_random.html#entropy_1","title":"Entropy","text":"<p>Unfortunately the is no \"nice\" and portable way of getting proper cryptographic entropy in the standard library. Main issues were already mentioned in the section documenting <code>random::entropy_seq()</code>, the best we can do without using system API is to sample everything we can (<code>std::random_device</code>, time in nanoseconds, address space, CPU ticks, some other PRNG and etc.) and use seeding sequence to mash it all together into a single state.</p> <p>The result of such approach is generally satisfactory, however oftentimes not sufficient for proper cryptographic security.</p>"},{"location":"module_random.html#distribution-approximations","title":"Distribution approximations","text":"<p>Most non-uniform distributions transform their inputs with slow non-linear functions like <code>std::sqrt()</code>, <code>std::log()</code>, <code>std::exp()</code> and etc. In many practical cases (gamedev, fuzzing, rendering) we don't need distributions to be particularly precise, this warrants usage of approximations which can completely avoid non-linear functions and get \"close enough\" results in a fraction of time.</p> <p>Below is an example of an empirical PDF produced by a regular <code>NormalDistribution&lt;&gt;</code> and an  <code>ApproxNormalDistribution&lt;&gt;</code> which is about 3\u20134 times faster to compute.</p> <p></p>"},{"location":"module_shell.html","title":"utl::shell","text":""},{"location":"module_shell.html#utlshell","title":"utl::shell","text":"<p>&lt;- to README.md</p> <p>&lt;- to implementation.hpp</p> <p>utl::shell is a small header that contains:</p> <ul> <li>Temporary file creation with RAII handles</li> <li>A function to run shell commands while capturing status / stdout / stderr</li> </ul> <p>It is mainly useful for invoking scripts and other executables in a portable (but not particularly secure) way.</p>"},{"location":"module_shell.html#definitions","title":"Definitions","text":"<pre><code>// Temporary files\nstruct TemporaryHandle {\n    TemporaryHandle()                       = delete;\n    TemporaryHandle(const TemporaryHandle&amp;) = delete;\n    TemporaryHandle(TemporaryHandle&amp;&amp;)      = default;\n\n    // Construction\n    static TemporaryHandle    create(std::filesystem::path filepath);\n    static TemporaryHandle    create(                              );\n    static TemporaryHandle overwrite(std::filesystem::path filepath);\n    static TemporaryHandle overwrite(                              );\n\n    // Getters\n    std::ifstream ifstream(std::ios::openmode mode = std::ios::in ) const;\n    std::ofstream ofstream(std::ios::openmode mode = std::ios::out) const;\n\n    const std::filesystem::path&amp; path() const noexcept;\n    const std::string          &amp;  str() const noexcept;\n};\n\n// Shell commands\nstruct CommandResult {\n    int         status;\n    std::string out;\n    std::string err;\n};\n\nCommandResult run_command(std::string_view command);\n</code></pre>"},{"location":"module_shell.html#methods","title":"Methods","text":""},{"location":"module_shell.html#temporary-files","title":"Temporary files","text":"<pre><code>TemporaryHandle()                       = delete;\nTemporaryHandle(const TemporaryHandle&amp;) = delete;\nTemporaryHandle(TemporaryHandle&amp;&amp;)      = default;\n</code></pre> <p><code>TemporaryHandle</code> \"owns\" the file lifetime and has move-only semantics. </p> <pre><code>static TemporaryHandle    create(std::filesystem::path filepath); // (1)\nstatic TemporaryHandle    create(                              ); // (2)\n</code></pre> <p>Overload (1) generates temporary file with a given <code>filepath</code>.</p> <p>Overload (2) generates file with a unique name inside the system temporary directory.</p> <p>Does not overwrite existing files in case of a name collision, throws <code>std::runtime_error</code> if new file would replace an existing one.</p> <pre><code>static TemporaryHandle overwrite(std::filesystem::path filepath); // (1)\nstatic TemporaryHandle overwrite(                              ); // (2)\n</code></pre> <p>Overload (1) generates temporary file with a given <code>filepath</code>.</p> <p>Overload (2) generates file with a unique name inside the system temporary directory.</p> <p>Overwrites existing files in case of a name collision.</p> <pre><code>std::ifstream ifstream(std::ios::openmode mode = std::ios::in ) const;\nstd::ofstream ofstream(std::ios::openmode mode = std::ios::out) const;\n</code></pre> <p>Returns <code>std::ifstream</code> / <code>std::ofstream</code> associated with the temporary file.</p> <p>Throws <code>std::runtime_error</code> in case of an IO failure.</p> <pre><code>const std::filesystem::path&amp; path() const noexcept;\nconst std::string          &amp;  str() const noexcept;\n</code></pre> <p>Returns <code>std::filesystem::path</code> / <code>std::string</code> associated with the temporary file.</p>"},{"location":"module_shell.html#shell-commands","title":"Shell commands","text":"<pre><code>struct CommandResult {\n    int         status;\n    std::string out;\n    std::string err;\n};\n\nCommandResult run_command(std::string_view command);\n</code></pre> <p>Runs command using a default system shell (<code>cmd</code> for Windows, <code>bash</code> for Linux, <code>zsh</code> for MacOS and some Linux distros).</p> <p>Return <code>status</code>, <code>stdout</code> and <code>stderr</code> (see standard streams) piped from the shell.</p> <p>Note: It is assumed that <code>command</code> does not redirect it's own streams. In case stream redirection is necessary, <code>command</code> can usually be wrapped in a subshell, for example in <code>bash</code> command <code>echo HELLO &gt;&amp;2</code> can be rewritten as<code>(echo HELLO &gt;&amp;2)</code> to add a subshell.</p>"},{"location":"module_shell.html#examples","title":"Examples","text":""},{"location":"module_shell.html#working-with-temporary-files","title":"Working with temporary files","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>const auto handle = utl::shell::TemporaryHandle::overwrite(\"temporary.txt\");\n\n// Write to temporary file\nhandle.ofstream() &lt;&lt; \"TEXT\";\n\n// Read from temporary file\nstd::string          text;\nhandle.ifstream() &gt;&gt; text;\n\nassert(text == \"TEXT\");\n\n// Append some more text\nhandle.ofstream(std::ios::app) &lt;&lt; \"MORE TEXT\";\n\n// Temp. file is deleted once handle is destroyed\n</code></pre>"},{"location":"module_shell.html#running-shell-commands","title":"Running shell commands","text":"<p>Warning</p> <p>Online compiler explorer does not support <code>std::system</code>, failing the <code>[ Run this code ]</code> is expected.</p> <p>[ Run this code ] [ Open source file ]</p> <pre><code>#ifdef __linux__\n\nconst auto res = utl::shell::run_command(\"echo TEXT\");\n// usually used to invoke scripts and other executables\n\nassert(res.status ==      0);\nassert(res.out    == \"TEXT\");\nassert(res.err    ==     \"\");\n\n#endif\n</code></pre>"},{"location":"module_sleep.html","title":"utl::sleep","text":""},{"location":"module_sleep.html#utlsleep","title":"utl::sleep","text":"<p>&lt;- to README.md</p> <p>&lt;- to implementation.hpp</p> <p>utl::sleep is a header implementing precise sleep functions.</p> <p>The main feature is a hybrid sleep function that uses a combination of system sleep, busy-waiting and some statistics to wait with an accuracy close to that of a spinlock, while keeping the thread free most of the time.</p> <p>The idea is largely based on this excellent blogpost, which introduces the approach and presents a strong case for its robustness on most modern systems.</p>"},{"location":"module_sleep.html#definitions","title":"Definitions","text":"<pre><code>template &lt;class Rep, class Period&gt; void system  (std::chrono::duration&lt;Rep, Period&gt; duration);\ntemplate &lt;class Rep, class Period&gt; void spinlock(std::chrono::duration&lt;Rep, Period&gt; duration);\ntemplate &lt;class Rep, class Period&gt; void hybrid  (std::chrono::duration&lt;Rep, Period&gt; duration);\n</code></pre>"},{"location":"module_sleep.html#methods","title":"Methods","text":"<pre><code>template &lt;class Rep, class Period&gt; void system  (std::chrono::duration&lt;Rep, Period&gt; duration);\ntemplate &lt;class Rep, class Period&gt; void spinlock(std::chrono::duration&lt;Rep, Period&gt; duration);\ntemplate &lt;class Rep, class Period&gt; void hybrid  (std::chrono::duration&lt;Rep, Period&gt; duration);\n</code></pre> <p>3 sleep implementations functionally similar to <code>std::this_thread::sleep_for()</code>, with different precision / CPU time tradeoffs:</p> Sleep Precision CPU usage Description <code>system()</code> Imprecise ~0% Alias for <code>std::this_thread::sleep_for()</code> <code>spinlock()</code> Very precise 100% Busy-waiting loop <code>hybrid()</code> Precise ~5% Hybrid approach that loops short system sleep, statistically estimates its error on the fly and uses spinlock to finish the last few %"},{"location":"module_sleep.html#examples","title":"Examples","text":""},{"location":"module_sleep.html#comparing-sleep-precision","title":"Comparing sleep precision","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using ms = std::chrono::duration&lt;double, std::milli&gt;;\n\nconstexpr int repeats        = 6;\nconstexpr ms  sleep_duration = ms(16.67);\n\nconst auto measure_time = [&amp;](auto sleep_function) {\n    for (int i = 0; i &lt; repeats; ++i) {\n        const auto start = std::chrono::steady_clock::now();\n        sleep_function(sleep_duration);\n        const auto end   = std::chrono::steady_clock::now();\n        std::cout &lt;&lt; ms(end - start).count() &lt;&lt; \" ms\\n\";\n    }\n};\n\nstd::cout &lt;&lt; \"Sleeping for 16.67 ms.\\n\";\n\nstd::cout &lt;&lt; \"\\n--- sleep::system()   ---\\n\";\nmeasure_time(utl::sleep::system&lt;double, std::milli&gt;);\n\nstd::cout &lt;&lt; \"\\n--- sleep::spinlock() ---\\n\";\nmeasure_time(utl::sleep::spinlock&lt;double, std::milli&gt;);\n\nstd::cout &lt;&lt; \"\\n--- sleep::hybrid()   ---\\n\";\nmeasure_time(utl::sleep::hybrid&lt;double, std::milli&gt;);\n</code></pre> <p>Output: <pre><code>Sleeping for 16.67 ms.\n\n--- sleep::system()   ---\n16.7649 ms\n16.7411 ms\n16.7406 ms\n16.7338 ms\n16.7308 ms\n16.7338 ms\n\n--- sleep::spinlock() ---\n16.6703 ms\n16.6702 ms\n16.6704 ms\n16.6703 ms\n16.6703 ms\n16.6701 ms\n\n--- sleep::hybrid()   ---\n16.6723 ms\n16.6723 ms\n16.6725 ms\n16.6723 ms\n16.6721 ms\n16.6721 ms\n</code></pre></p>"},{"location":"module_stre.html","title":"utl::stre","text":""},{"location":"module_stre.html#utlstre","title":"utl::stre","text":"<p>&lt;- to README.md</p> <p>&lt;- to implementation.hpp</p> <p>utl::stre (aka string expansions) header contains implementations of most commonly used string utils.</p> <p>Motivation: Despite the seeming triviality of the topic a lot of implementations found online are either horribly inefficient or contain straight up bugs in some edge cases. Here, the goal is to \"get it right\" once so no time would be spent reinventing the wheel in the future.</p>"},{"location":"module_stre.html#definitions","title":"Definitions","text":"<pre><code>// Character classification\nconstexpr bool is_digit       (char ch) noexcept;\nconstexpr bool is_lowercase   (char ch) noexcept;\nconstexpr bool is_uppercase   (char ch) noexcept;\nconstexpr bool is_punctuation (char ch) noexcept;\nconstexpr bool is_hexadecimal (char ch) noexcept;\nconstexpr bool is_control     (char ch) noexcept;\nconstexpr bool is_alphabetic  (char ch) noexcept;\nconstexpr bool is_alphanumeric(char ch) noexcept;\nconstexpr bool is_graphical   (char ch) noexcept;\nconstexpr bool is_printable   (char ch) noexcept;\nconstexpr bool is_space       (char ch) noexcept;\nconstexpr bool is_blank       (char ch) noexcept;\n\n// Case conversion\nconstexpr char to_lower(char ch) noexcept;\nconstexpr char to_upper(char ch) noexcept;\n\nstd::string to_lower(std::string str);\nstd::string to_upper(std::string str);\n\n// Trimming\nconstexpr std::string_view trim_left (std::string_view str, char trimmed_char = ' ') noexcept;\nconstexpr std::string_view trim_right(std::string_view str, char trimmed_char = ' ') noexcept;\nconstexpr std::string_view trim      (std::string_view str, char trimmed_char = ' ') noexcept;\n\nconstexpr std::string_view trim_left (const char* str, char trimmed_char = ' ') noexcept;\nconstexpr std::string_view trim_right(const char* str, char trimmed_char = ' ') noexcept;\nconstexpr std::string_view trim      (const char* str, char trimmed_char = ' ') noexcept;\n\nstd::string trim_left (std::string str, char trimmed_char = ' ');\nstd::string trim_right(std::string str, char trimmed_char = ' ');\nstd::string trim      (std::string str, char trimmed_char = ' ');\n\n// Padding\nstd::string pad_left (std::string_view str, std::size_t length, char padding_char = ' ');\nstd::string pad_right(std::string_view str, std::size_t length, char padding_char = ' ');\nstd::string pad      (std::string_view str, std::size_t length, char padding_char = ' ');\n\n// Substring checks\nconstexpr bool starts_with(std::string_view str, std::string_view substr) noexcept;\nconstexpr bool ends_with  (std::string_view str, std::string_view substr) noexcept;\nconstexpr bool contains   (std::string_view str, std::string_view substr) noexcept;\n\n// Substring replacement\nstd::string replace_all   (std::string str, std::string_view from, std::string_view to);\nstd::string replace_first (std::string str, std::string_view from, std::string_view to);\nstd::string replace_last  (std::string str, std::string_view from, std::string_view to);\nstd::string replace_prefix(std::string str, std::string_view from, std::string_view to);\nstd::string replace_suffix(std::string str, std::string_view from, std::string_view to);\n\n// Tokenization\nstd::vector&lt;std::string&gt; tokenize(std::string_view str, std::string_view delimiter);\nstd::vector&lt;std::string&gt; split   (std::string_view str, std::string_view delimiter);\n\n// Repeating\nstd::string repeat(            char  ch, std::size_t repeats);\nstd::string repeat(std::string_view str, std::size_t repeats);\n\n// Escaping\nstd::string escape(            char ch );\nstd::string escape(std::string_view str);\n\n// Difference measurement\nconstexpr std::size_t first_difference(std::string_view lhs, std::string_view rhs) noexcept;\nconstexpr std::size_t count_difference(std::string_view lhs, std::string_view rhs) noexcept;\n</code></pre> <p>Note</p> <p>Functions that can utilize mutable input string for a more efficient implementation take <code>std::string</code> by value. This means r-value arguments are moved &amp; reused, while l-values are copied.</p>"},{"location":"module_stre.html#methods","title":"Methods","text":""},{"location":"module_stre.html#character-classification","title":"Character classification","text":"<pre><code>constexpr bool is_digit       (char ch) noexcept;\nconstexpr bool is_lowercase   (char ch) noexcept;\nconstexpr bool is_uppercase   (char ch) noexcept;\nconstexpr bool is_punctuation (char ch) noexcept;\nconstexpr bool is_hexadecimal (char ch) noexcept;\nconstexpr bool is_control     (char ch) noexcept;\nconstexpr bool is_alphabetic  (char ch) noexcept;\nconstexpr bool is_alphanumeric(char ch) noexcept;\nconstexpr bool is_graphical   (char ch) noexcept;\nconstexpr bool is_printable   (char ch) noexcept;\nconstexpr bool is_space       (char ch) noexcept;\nconstexpr bool is_blank       (char ch) noexcept;\n</code></pre> <p>A safer <code>constexpr</code> reimplementation of character classification functions from <code>&lt;cctype&gt;</code>.</p> <p>Standard <code>&lt;cctype&gt;</code> functions don't operate on <code>char</code> parameters as would be intuitive, instead they accept <code>int</code> parameters which should be representable as <code>unsigned char</code> and invoke UB otherwise, which makes them extremely error-prone for common use cases. In addition, <code>&lt;cctype&gt;</code> functions return booleans as <code>int</code>, which can be evaluated to any non-zero value, thus breaking some common assumptions.</p> <code>stre::</code> function <code>&lt;cctype&gt;</code> equivalent Description <code>is_digit()</code> <code>std::isdigit()</code> <code>true</code> for digits <code>0...9</code> <code>is_lowercase()</code> <code>std::islower()</code> <code>true</code> for lowercase letters <code>a...z</code> <code>is_uppercase()</code> <code>std::isupper()</code> <code>true</code> for uppercase letters <code>A...Z</code> <code>is_punctuation()</code> <code>std::ispunct()</code> <code>true</code> for punctuation characters <code>is_hexadecimal()</code> <code>std::isxdigit()</code> <code>true</code> for hex digits <code>0...9</code>, <code>A..F</code>, <code>a..f</code> <code>is_control()</code> <code>std::iscntrl()</code> <code>true</code> for control characters <code>0x00...0x1F</code>, <code>0x7F</code> <code>is_alphabetic()</code> <code>std::isalpha()</code> <code>true</code> for letters <code>a...z</code>, <code>A...Z</code> <code>is_alphanumeric()</code> <code>std::isalnum()</code> <code>true</code> for letters and digits <code>is_graphical()</code> <code>std::isgraph()</code> <code>true</code> for letters, digits and punctuation <code>is_printable()</code> <code>std::isprint()</code> <code>true</code> for graphical characters and spaces <code>is_space()</code> <code>std::isspace()</code> <code>true</code> for spaces, tabs, line feeds and etc. <code>is_blank()</code> <code>std::isblank()</code> <code>true</code> for spaces and tabs"},{"location":"module_stre.html#case-conversions","title":"Case conversions","text":"<pre><code>std::string to_lower(       char ch );\nstd::string to_lower(std::string str);\n</code></pre> <p>Replaces all uppercase letters <code>A...Z</code> in the string <code>str</code> (or character <code>ch</code>) with corresponding lowercase letters <code>a...z</code>.</p> <pre><code>std::string to_upper(       char ch );\nstd::string to_upper(std::string str);\n</code></pre> <p>Replaces all lowercase letters <code>a...z</code> in the string <code>str</code> (or character <code>ch</code>) with corresponding uppercase letters <code>A...Z</code>.</p>"},{"location":"module_stre.html#trimming","title":"Trimming","text":"<pre><code>constexpr std::string_view trim_left (std::string_view str, char trimmed_char = ' ') noexcept;\nconstexpr std::string_view trim_right(std::string_view str, char trimmed_char = ' ') noexcept;\nconstexpr std::string_view trim      (std::string_view str, char trimmed_char = ' ') noexcept;\n\nconstexpr std::string_view trim_left (const char* str, char trimmed_char = ' ') noexcept;\nconstexpr std::string_view trim_right(const char* str, char trimmed_char = ' ') noexcept;\nconstexpr std::string_view trim      (const char* str, char trimmed_char = ' ') noexcept;\n\nstd::string trim_left (std::string str, char trimmed_char = ' ');\nstd::string trim_right(std::string str, char trimmed_char = ' ');\nstd::string trim      (std::string str, char trimmed_char = ' ');\n</code></pre> <p>Trims characters equal to <code>trimmed_char</code> from the left / right / both sides of the string <code>str</code>.</p>"},{"location":"module_stre.html#padding","title":"Padding","text":"<pre><code>std::string pad_left (std::string_view str, std::size_t length, char padding_char = ' ');\nstd::string pad_right(std::string_view str, std::size_t length, char padding_char = ' ');\nstd::string pad      (std::string_view str, std::size_t length, char padding_char = ' ');\n</code></pre> <p>Pads string <code>str</code> with character <code>padding_char</code> from left / right / both sides until it reaches given <code>length</code>.</p> <p>Note: If <code>str.size() &gt;= length</code> the string is left unchanged.</p>"},{"location":"module_stre.html#substring-checks","title":"Substring checks","text":"<pre><code>bool starts_with(std::string_view str, std::string_view substr);\nbool ends_with  (std::string_view str, std::string_view substr);\nbool contains   (std::string_view str, std::string_view substr);\n</code></pre> <p>Returns <code>true</code> if string <code>str</code> starts with / ends with / contains the substring <code>substr</code>.</p>"},{"location":"module_stre.html#substring-replacement","title":"Substring replacement","text":"<pre><code>std::string replace_all   (std::string str, std::string_view from, std::string_view to);\n</code></pre> <p>Replaces all occurrences of substring <code>from</code> in the string <code>str</code> with <code>to</code>.</p> <pre><code>std::string replace_first (std::string str, std::string_view from, std::string_view to);\n</code></pre> <p>Replaces the first occurrence of substring <code>from</code> in the string <code>str</code> with <code>to</code>.</p> <pre><code>std::string replace_last  (std::string str, std::string_view from, std::string_view to);\n</code></pre> <p>Replaces the last occurrence of substring <code>from</code> in the string <code>str</code> with <code>to</code>.</p> <pre><code>std::string replace_prefix(std::string str, std::string_view from, std::string_view to);\n</code></pre> <p>If <code>str</code> starts with a substring <code>from</code>, replaces it with <code>to</code>.</p> <pre><code>std::string replace_suffix(std::string str, std::string_view from, std::string_view to);\n</code></pre> <p>If <code>str</code> ends with a substring <code>from</code>, replaces it with <code>to</code>.</p>"},{"location":"module_stre.html#tokenization","title":"Tokenization","text":"<pre><code>std::vector&lt;std::string&gt; tokenize(std::string_view str, std::string_view delimiter);\nstd::vector&lt;std::string&gt; split   (std::string_view str, std::string_view delimiter);\n</code></pre> <p>Splits string <code>str</code> into a vector of <code>std::string</code> tokens based on <code>delimiter</code>.</p> <p>In the case of leading / trailing / repeated delimiters, <code>tokenize()</code> will omit empty the resulting empty tokens, while <code>split()</code> preserves them.</p>"},{"location":"module_stre.html#repeating","title":"Repeating","text":"<pre><code>std::string repeat_char  (            char  ch, std::size_t repeats);\nstd::string repeat_string(std::string_view str, std::size_t repeats);\n</code></pre> <p>Repeats given character or string a given number of times and returns the resulting string.</p>"},{"location":"module_stre.html#escaping","title":"Escaping","text":"<pre><code>std::string escape(            char ch );\nstd::string escape(std::string_view str);\n</code></pre> <p>Escapes all control &amp; non-printable characters in <code>ch</code> / <code>str</code> using standard C++ notation. See the corresponding example.</p> <p>Useful for viewing string contents and serialization without special characters getting in the way.</p>"},{"location":"module_stre.html#difference-measurement","title":"Difference measurement","text":"<pre><code>constexpr std::size_t first_difference(std::string_view lhs, std::string_view rhs) noexcept;\n</code></pre> <p>Returns the index of the first character that is different between strings <code>lhs</code> and <code>rhs</code>.</p> <p>Differently sized strings are allowed. Should both strings be the same, returns <code>std::string_view::npos</code>.</p> <pre><code>constexpr std::size_t count_difference(std::string_view lhs, std::string_view rhs) noexcept;\n</code></pre> <p>Returns the number of characters that is different between strings <code>lhs</code> and <code>rhs</code>.</p> <p>Differently sized strings are allowed.</p>"},{"location":"module_stre.html#examples","title":"Examples","text":""},{"location":"module_stre.html#character-classification_1","title":"Character classification","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\nstatic_assert(!stre::is_control( '5'));\nstatic_assert( stre::is_control('\\f'));\nstatic_assert( stre::is_control('\\n'));\n\nstatic_assert(!stre::is_graphical(' '));\nstatic_assert( stre::is_graphical('X'));\n</code></pre>"},{"location":"module_stre.html#case-conversions_1","title":"Case conversions","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\nassert(stre::to_lower(\"Lorem Ipsum\") == \"lorem ipsum\");\nassert(stre::to_upper(\"lorem ipsum\") == \"LOREM IPSUM\");\n</code></pre>"},{"location":"module_stre.html#trimming_1","title":"Trimming","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\nstatic_assert(stre::trim_left (\"   lorem ipsum   \") ==    \"lorem ipsum   \");\nstatic_assert(stre::trim_right(\"   lorem ipsum   \") == \"   lorem ipsum\"   );\nstatic_assert(stre::trim      (\"   lorem ipsum   \") ==    \"lorem ipsum\"   );\n\nstatic_assert(stre::trim(\"__ASSERT__\", '_') == \"ASSERT\");\n</code></pre>"},{"location":"module_stre.html#padding_1","title":"Padding","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\nassert(stre::pad_left (\"value\", 9) == \"    value\" );\nassert(stre::pad_right(\"value\", 9) == \"value    \" );\nassert(stre::pad      (\"value\", 9) == \"  value  \" );\n\nassert(stre::pad(\" label \", 15, '-') == \"---- label ----\");\n</code></pre>"},{"location":"module_stre.html#substring-checks_1","title":"Substring checks","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\nstatic_assert(stre::starts_with(\"lorem ipsum\", \"lorem\"));\nstatic_assert(stre::ends_with  (\"lorem ipsum\", \"ipsum\"));\nstatic_assert(stre::contains   (\"lorem ipsum\", \"em ip\"));\n</code></pre>"},{"location":"module_stre.html#substring-replacement_1","title":"Substring replacement","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\nassert(stre::replace_all  (\"__xx__xx__\", \"xx\", \"yy\") == \"__yy__yy__\");\nassert(stre::replace_first(\"__xx__xx__\", \"xx\", \"yy\") == \"__yy__xx__\");\nassert(stre::replace_last (\"__xx__xx__\", \"xx\", \"yy\") == \"__xx__yy__\");\n\nassert(stre::replace_prefix(\"__xx__xx__\", \"__xx\", \"--yy\") == \"--yy__xx__\");\nassert(stre::replace_suffix(\"__xx__xx__\", \"xx__\", \"yy--\") == \"__xx__yy--\");\n</code></pre>"},{"location":"module_stre.html#tokenization_1","title":"Tokenization","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\nauto tokens = stre::tokenize(\"aaa,bbb,,ccc,\", \",\"); // empty tokens are discarded\nassert(tokens.size() == 3);\nassert(tokens[0] == \"aaa\");\nassert(tokens[1] == \"bbb\");\nassert(tokens[2] == \"ccc\");\n\ntokens = stre::split(\"(---)lorem(---)ipsum\", \"(---)\"); // empty tokens are preserved\nassert(tokens.size() == 3  );\nassert(tokens[0] == \"\"     );\nassert(tokens[1] == \"lorem\");\nassert(tokens[2] == \"ipsum\");\n</code></pre>"},{"location":"module_stre.html#repeating_1","title":"Repeating","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\nassert(stre::repeat(  'h', 7) == \"hhhhhhh\"        );\nassert(stre::repeat(\"xo-\", 5) == \"xo-xo-xo-xo-xo-\");\n</code></pre>"},{"location":"module_stre.html#escaping_1","title":"Escaping","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\nconst std::string text = \"this text\\r will get messed up due to\\r carriage returns.\";\n\nstd::cout\n    &lt;&lt; \"Original string prints like this:\\n\" &lt;&lt;              text  &lt;&lt; \"\\n\\n\"\n    &lt;&lt; \"Escaped  string prints like this:\\n\" &lt;&lt; stre::escape(text) &lt;&lt; \"\\n\\n\";\n</code></pre> <p>Output: <pre><code>Original string prints like this:\n carriage returns.p due to\n\nEscaped  string prints like this:\nthis text\\r will get messed up due to\\r carriage returns.\n</code></pre></p>"},{"location":"module_stre.html#difference-measurement_1","title":"Difference measurement","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\nstatic_assert(stre::first_difference(\"xxxxYx\", \"xxxxXx\") == 4);\nstatic_assert(stre::first_difference(\"xxx\"   , \"xxxxxx\") == 3);\n\nstatic_assert(stre::count_difference(\"xxxxYx\", \"xxxxXx\") == 1);\nstatic_assert(stre::count_difference(\"yyy\"   , \"xxxxxx\") == 6);\n</code></pre>"},{"location":"module_strong_type.html","title":"utl::strong_type","text":""},{"location":"module_strong_type.html#utlstrong_type","title":"utl::strong_type","text":"<p>&lt;- to README.md</p> <p>&lt;- to implementation.hpp</p> <p>utl::strong_type is a header providing templates for creating strong typedefs.</p> <p>By default, typedefs in <code>C</code> and <code>C++</code> are weak, which means separate typedefs don't count as distinct types:</p> <pre><code>using Offset = std::size_t;\nusing Size   = std::size_t;\n\nstatic_assert(std::is_same_v&lt;Offset, Size&gt;); // types are the same\n</code></pre> <p>Strong typedefs can be used to mark types as distinct:</p> <pre><code>using Offset = strong_type::Arithmetic&lt;std::size_t, class OffsetTag&gt;;\nusing Size   = strong_type::Arithmetic&lt;std::size_t, class   SizeTag&gt;;\n\nstatic_assert(!std::is_same_v&lt;Offset, Size&gt;); // types are different\n</code></pre> <p>This is useful for improving type safety. Arithmetic strong types act like thin wrappers around the underlying value and support all of the usual operations, but preserve type and disallow unwanted implicit conversions at no runtime cost.</p> <p>Strong types are often used in physical modeling together with <code>&lt;chrono&gt;</code>-like ratio conversions to ensure dimensional correctness of the expressions. In a more general case they can protect against mixing up conceptually different values (such as IDs, offsets, sizes and etc.) which would otherwise be implicitly convertible to each other.</p> <p>In addition, strong types are exceedingly useful for wrapping <code>C</code> APIs which tend to use regular integers and type-erased pointers for distinctly different values (whereas <code>C++</code> would usually use classes and strongly typed <code>enum class</code>). This is particularly common for various system handles, which is why this header also provides <code>strong_type::Unique&lt;&gt;</code> that can wrap arbitrary handles into RAII semantics with a custom deleter (see OpenGL example).</p>"},{"location":"module_strong_type.html#definitions","title":"Definitions","text":"<pre><code>// Function binding\ntemplate &lt;auto function&gt;\nstruct Bind {\n    template &lt;class... Args&gt; constexpr auto operator()(Args&amp;&amp;... args) const;\n};\n\n// Strongly typed move-only wrapper around 'T'\ntemplate &lt;class T, class Tag, class Deleter = void&gt;\nclass Unique {\n    // Member types\n    using   value_type = T;\n    using     tag_type = Tag;\n    using deleter_type = Deleter;\n\n    // Move-only semantics\n    constexpr Unique           (const Unique&amp; ) =  delete;\n    constexpr Unique&amp; operator=(const Unique&amp; ) =  delete;\n    constexpr Unique           (      Unique&amp;&amp;);\n    constexpr Unique&amp; operator=(      Unique&amp;&amp;);\n\n    // Conversion\n    constexpr Unique           (T&amp;&amp; value) noexcept;\n    constexpr Unique&amp; operator=(T&amp;&amp; value) noexcept;\n\n    // Accessing the underlying value\n    constexpr const T&amp; get() const noexcept;\n    constexpr       T&amp; get()       noexcept;\n};\n\n// Strongly typed arithmetic wrapper around 'T'\ntemplate &lt;class T, class Tag&gt;\nstruct Arithmetic {\n    // Member types\n    using value_type = T;\n    using   tag_type = Tag;\n\n    // Conversion\n    constexpr Arithmetic           (T value) noexcept;\n    constexpr Arithmetic&amp; operator=(T value) noexcept;\n\n    // Accessing the underlying value\n    constexpr const T&amp; get() const noexcept;\n    constexpr       T&amp; get()       noexcept;\n\n    // Explicit cast\n    template &lt;class To&gt; constexpr explicit operator To() const noexcept;\n\n    // + all arithmetic operators supported by 'T'\n    // + std::swap() support\n};\n</code></pre> <p>Note</p> <p>Strictly speaking, some of the <code>noexcept</code> modifiers listed here are inferred from <code>std::is_nothrow_move_constructible_v&lt;T&gt;</code> and other traits. In practice types that can throw during a move are extremely rare for our use case, so it usually holds true.</p>"},{"location":"module_strong_type.html#methods","title":"Methods","text":""},{"location":"module_strong_type.html#function-binding","title":"Function binding","text":"<pre><code>template &lt;auto function&gt;\nstruct Bind {\n    template &lt;class... Args&gt; constexpr auto operator()(Args&amp;&amp;... args) const;\n};\n</code></pre> <p>Binds <code>function</code> to a stateless class so it can be passed as a template parameter.</p> <p>Useful for passing functions pointers as custom deleters to <code>std::unique_ptr&lt;&gt;</code> and <code>strong_type::Unique&lt;&gt;</code>.</p> <p>Note: Calling <code>Bind&lt;function&gt;{}(args...)</code> is equivalent to calling <code>function(args...)</code>.</p>"},{"location":"module_strong_type.html#unique","title":"Unique","text":""},{"location":"module_strong_type.html#member-types","title":"Member types","text":"<pre><code>using   value_type = T;\nusing     tag_type = Tag;\nusing deleter_type = Deleter;\n</code></pre> <p>Member types reflecting the template parameters.</p> <p><code>T</code> can be an instance of any movable type. Default constructor is optional.</p> <p><code>Tag</code> is an arbitrary class used to discriminate this type from the others.</p> <p><code>Deleter</code> should either be <code>void</code> or a stateless class invocable for <code>T&amp;&amp;</code>.</p>"},{"location":"module_strong_type.html#move-only-semantics","title":"Move-only semantics","text":"<pre><code>constexpr Unique           (const Unique&amp; ) =  delete;\nconstexpr Unique&amp; operator=(const Unique&amp; ) =  delete;\nconstexpr Unique           (      Unique&amp;&amp;);\nconstexpr Unique&amp; operator=(      Unique&amp;&amp;);\n</code></pre> <p><code>Unique&lt;&gt;</code> is a move-only type that behaves similarly to <code>std::unique_ptr&lt;&gt;</code>, but can hold an arbitrary internal value.</p>"},{"location":"module_strong_type.html#conversion","title":"Conversion","text":"<pre><code>constexpr Unique           (T&amp;&amp; value) noexcept;\nconstexpr Unique&amp; operator=(T&amp;&amp; value) noexcept;\n</code></pre> <p>Constructor / assignment that takes an ownership of the <code>value</code>.</p> <p>Note: Previous value (if present) will be destroyed according to the <code>Deleter</code> (if present).</p>"},{"location":"module_strong_type.html#accessing-the-underlying-value","title":"Accessing the underlying value","text":"<pre><code>constexpr const T&amp; get() const noexcept;\nconstexpr       T&amp; get()       noexcept;\n</code></pre> <p>Returns a constant or mutable reference to the managed object.</p> <p>Important: Moving the underlying object out or deleting it can break class invariants. This is impossible to protect against similarly to how  <code>std::unique_ptr&lt;&gt;</code> would cause a double-delete should the user call <code>delete ptr.get()</code> manually.</p>"},{"location":"module_strong_type.html#arithmetic","title":"Arithmetic","text":""},{"location":"module_strong_type.html#member-types_1","title":"Member types","text":"<pre><code>using value_type = T;\nusing   tag_type = Tag;\n</code></pre> <p>Member types reflecting the template parameters.</p> <p><code>T</code> can be an instance of any arithmetic type (aka integer or float).</p> <p><code>Tag</code> is an arbitrary class used to discriminate this type from the others.</p>"},{"location":"module_strong_type.html#conversion_1","title":"Conversion","text":"<pre><code>constexpr Arithmetic           (T value) noexcept;\nconstexpr Arithmetic&amp; operator=(T value) noexcept;\n</code></pre> <p>Constructor / assignment that assigns the underlying <code>value</code>.</p>"},{"location":"module_strong_type.html#accessing-the-underlying-value_1","title":"Accessing the underlying value","text":"<pre><code>constexpr const T&amp; get() const noexcept;\nconstexpr       T&amp; get()       noexcept;\n</code></pre> <p>Returns a constant or mutable reference to the underlying value.</p>"},{"location":"module_strong_type.html#explicit-cast","title":"Explicit cast","text":"<pre><code>template &lt;class To&gt; constexpr explicit operator To() const noexcept;\n</code></pre> <p>Explicitly casting <code>Arithmetic&lt;T&gt;</code> is equivalent to performing the cast on its underlying value.</p> <p>Implicit casts are intentionally prohibited.</p>"},{"location":"module_strong_type.html#operators","title":"Operators","text":"<p><code>Arithmetic&lt;T&gt;</code> supports the same set of binary / unary operators as its underlying <code>value_type</code>.</p> <p>The only exception to this rule is <code>operator!()</code> which is intentionally prohibited similarly to implicit casts.</p> <p><code>std::swap()</code> support is also provided.</p>"},{"location":"module_strong_type.html#examples","title":"Examples","text":""},{"location":"module_strong_type.html#wrapping-cstdio-file-handle","title":"Wrapping <code>&lt;cstdio&gt;</code> file handle","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\n// Create strongly typed wrapper around &lt;cstdio&gt; file handle\n// (aka 'FILE*') with move-only semantics and RAII cleanup\nusing FileHandle = strong_type::Unique&lt;std::FILE*, class FileTag, strong_type::Bind&lt;&amp;std::fclose&gt;&gt;;\n\nFileHandle file = std::fopen(\"temp.txt\", \"w\");\n\n// upon destruction invokes 'fclose()' on the internal pointer,\n// same principle works for most handles produced by 'C' APIs\n</code></pre>"},{"location":"module_strong_type.html#wrapping-opengl-shader-handle","title":"Wrapping OpenGL shader handle","text":"<p>Note</p> <p>OpenGL is a graphics API written in <code>C</code>. It uses <code>unsigned int</code> IDs as handles to the objects living in a GPU memory (buffers, shaders, pipelines and etc.). This is a perfect example of an API which greatly benefits from the stronger type safety and automatic cleanup of <code>strong_type::Unique&lt;&gt;</code>.</p> <p>[ Run this code ] [ Open source file ]</p> <pre><code>// Mock of an OpenGL API\nusing GLuint = unsigned int;\nusing GLenum = unsigned int;\n\nGLuint glCreateShader ([[maybe_unused]] GLenum shader_type) { return 0; }\nvoid   glCompileShader([[maybe_unused]] GLuint shader_id  ) {           }\nvoid   glDeleteShader ([[maybe_unused]] GLuint shader_id  ) {           }\n\n#define GL_VERTEX_SHADER 1\n\n// ...\n\nusing namespace utl;\n\n// Create strongly typed wrapper around OpenGL shader handle \n// (aka 'unsigned int') with move-only semantics and RAII cleanup\nusing ShaderHandle = strong_type::Unique&lt;GLuint, class ShaderTag, strong_type::Bind&lt;&amp;glDeleteShader&gt;&gt;;\n\nShaderHandle shader = glCreateShader(GL_VERTEX_SHADER);\n\n// &lt;real OpenGL would also have some boilerplate here&gt;\n\n// Retrieve the underlying value and pass it to a 'C' API\nglCompileShader(shader.get());\n</code></pre>"},{"location":"module_strong_type.html#strongly-typed-integer-unit","title":"Strongly typed integer unit","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using ByteOffset = utl::strong_type::Arithmetic&lt;int, struct OffsetTag&gt;;\n\nconstexpr ByteOffset buffer_start  = 0;\nconstexpr ByteOffset buffer_stride = 3;\n\n// Perform arithmetics\nstatic_assert(buffer_start + buffer_stride == ByteOffset{3});\nstatic_assert(           2 * buffer_stride == ByteOffset{6});\n\n// Extract value\nstatic_assert(buffer_stride.get() == 3);\n\n// Explicit cast\nstatic_assert(static_cast&lt;int&gt;(buffer_stride) == 3);\n\n// Compile time protection\nconstexpr int        element_count = 70;\nconstexpr ByteOffset buffer_end    = buffer_start + element_count * buffer_stride;\n\n// &gt; constexpr ByteOffset buffer_end = buffer_start + element_count;\n//   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n//   forgot to multiply by stride, will not compile\n\nstatic_assert(buffer_end == ByteOffset{0 + 3 * 70});\n</code></pre>"},{"location":"module_struct_reflect.html","title":"utl::struct_reflect","text":""},{"location":"module_struct_reflect.html#utlstruct_reflect","title":"utl::struct_reflect","text":"<p>&lt;- to README.md</p> <p>&lt;- to implementation.hpp</p> <p>utl::struct_reflect is a lean <code>struct</code> reflection library based around the map-macro.</p> <p>Important</p> <p>When compiling with MSVC use <code>/Zc:preprocessor</code> to enable standard-compliant preprocessor. Default MSVC preprocessor is notoriously non-compliant due to legacy reasons and might not handle macro expansion properly.</p>"},{"location":"module_struct_reflect.html#definitions","title":"Definitions","text":"<pre><code>// Macros\n#define UTL_STRUCT_REFLECT(struct_name, ...)\n\n// Reflection\ntemplate &lt;class S&gt; constexpr std::string_view type_name;\ntemplate &lt;class S&gt; constexpr std::size_t      size;\n\ntemplate &lt;class S&gt; constexpr std::array&lt;std::string_view, size&lt;E&gt;&gt; names;\ntemplate &lt;class S&gt; constexpr auto field_view(S&amp;&amp; value) noexcept;\ntemplate &lt;class S&gt; constexpr auto entry_view(S&amp;&amp; value) noexcept;\n\ntemplate &lt;std::size_t I, class S&gt; constexpr auto get(S&amp;&amp; value) noexcept;\n\ntemplate &lt;class S, class Func&gt;\nconstexpr void for_each(S&amp;&amp; value, Func&amp;&amp; func);\n\ntemplate &lt;class S1, class S2, class Func&gt;\nconstexpr void for_each(S1&amp;&amp; value_1, S2&amp;&amp; value_2, Func&amp;&amp; func);\n\ntemplate &lt;class S, class Pred&gt;\nconstexpr bool true_for_all(const S&amp; value, Pred&amp;&amp; pred);\n\ntemplate &lt;class S1, class S2, class Pred&gt;\nconstexpr bool true_for_all(const S1&amp; value_1, const S2&amp; value_2, Pred&amp;&amp; pred);\n\n// Other utils\ntemplate &lt;class T, class Func&gt;\nvoid tuple_for_each(T&amp;&amp; tuple, Func&amp;&amp; func);\n\ntemplate &lt;class T1, class T2, class Func&gt;\nvoid tuple_for_each(T1&amp;&amp; tuple_1, T2&amp;&amp; tuple_2, Func&amp;&amp; func);\n</code></pre>"},{"location":"module_struct_reflect.html#methods","title":"Methods","text":""},{"location":"module_struct_reflect.html#macros","title":"Macros","text":"<pre><code>#define UTL_STRUCT_REFLECT(struct_name, ...)\n</code></pre> <p>Registers reflection for the <code>struct</code> / <code>class</code> type <code>struct_name</code> with member variables <code>...</code>.</p>"},{"location":"module_struct_reflect.html#reflection","title":"Reflection","text":"<pre><code>template &lt;class S&gt; constexpr std::string_view type_name;\n</code></pre> <p>Evaluates to a stringified name of struct <code>S</code>.</p> <pre><code>template &lt;class S&gt; constexpr std::size_t size;\n</code></pre> <p>Evaluates to a number of fields in the struct <code>S</code> .</p> <pre><code>template &lt;class S&gt; constexpr std::array&lt;std::string_view, size&lt;E&gt;&gt; names;\n</code></pre> <p>Evaluates to an array of stringified field names corresponding to struct <code>S</code>.</p> <pre><code>template &lt;class S&gt; constexpr auto field_view(S&amp;&amp; value) noexcept;\n</code></pre> <p>Returns a tuple with perfectly-forwarded references corresponding to the fields of <code>value</code>.</p> <p>Below is an example table for the reflection of <code>struct Struct { int x; };</code>:</p> Value category Forwarded reference <code>field_view</code> return type <code>value</code> is a const reference to a struct <code>S&amp;&amp;</code> corresponds to <code>const Struct&amp;</code> <code>std:tuple&lt;const int&amp;&gt;</code> <code>value</code> is an l-value reference to a struct <code>S&amp;&amp;</code> corresponds to <code>Struct&amp;</code> <code>std:tuple&lt;int&amp;&gt;</code> <code>value</code> is an r-value reference to a struct <code>S&amp;&amp;</code> corresponds to <code>Struct&amp;&amp;</code> <code>std:tuple&lt;int&amp;&amp;&gt;</code> <p>Tip</p> <p>This effectively means that <code>field_view</code> allows struct members to be accessed exactly as one would expect when working with struct members directly, except using a tuple API. See the examples.</p> <pre><code>template &lt;class S&gt; constexpr auto entry_view(S&amp;&amp; value) noexcept;\n</code></pre> <p>Returns a tuple with pairs of names and perfectly-forwarded references corresponding to the fields of <code>value</code>.</p> <p>Reference forwarding logic is exactly the same as it is in <code>field_view()</code>. Below is an example table for the reflection of <code>struct Struct { int x; };</code>:</p> Value category Forwarded reference <code>entry_view()</code> return type <code>value</code> is a const reference to a struct <code>S&amp;&amp;</code> corresponds to <code>const Struct&amp;</code> <code>std:tuple&lt;std::pair&lt;std::string_view, const int&amp;&gt;&gt;</code> <code>value</code> is an l-value reference to a struct <code>S&amp;&amp;</code> corresponds to <code>Struct&amp;</code> <code>std:tuple&lt;std::pair&lt;std::string_view, int&amp;&gt;&gt;</code> <code>value</code> is an r-value reference to a struct <code>S&amp;&amp;</code> corresponds to <code>Struct&amp;&amp;</code> <code>std:tuple&lt;std::pair&lt;std::string_view, int&amp;&amp;&gt;&gt;</code> <pre><code>template &lt;std::size_t I, class S&gt; constexpr auto get(S&amp;&amp; value) noexcept;\n</code></pre> <p>Returns perfectly-forwarded reference to the field number <code>I</code> in <code>value</code>.</p> <pre><code>template &lt;class S, class Func&gt;\nconstexpr void for_each(S&amp;&amp; value, Func&amp;&amp; func);\n</code></pre> <p>Applies function <code>func</code> to all fields of the struct <code>value</code>.</p> <p>Note: <code>func</code> must be callable for all field types, either through overloads or templating.</p> <pre><code>template &lt;class S1, class S2, class Func&gt;\nconstexpr void for_each(S1&amp;&amp; value_1, S2&amp;&amp; value_2, Func&amp;&amp; func);\n</code></pre> <p>Applies function <code>func</code> to all fields of a struct pair <code>value_1</code>, <code>value_2</code>.</p> <p>Note: This is useful for defining binary functions over custom types, see the examples.</p> <pre><code>template &lt;class S, class Pred&gt;\nconstexpr bool true_for_all(const S&amp; value, Pred&amp;&amp; pred);\n</code></pre> <p>Returns whether unary predicate <code>pred</code> is satisfied for all fields of the <code>value</code>.</p> <p>Note: Predicate checks cannot be efficiently implemented in terms of <code>for_each()</code> due to potential short-circuiting of logical AND. Use this function instead.</p> <pre><code>template &lt;class S1, class S2, class Pred&gt;\nconstexpr bool true_for_all(const S1&amp; value_1, const S2&amp; value_2, Pred&amp;&amp; pred);\n</code></pre> <p>Returns whether binary predicate <code>pred</code> is satisfied for all fields of a struct pair <code>value_1</code>, <code>value_2</code>.</p>"},{"location":"module_struct_reflect.html#other-utils","title":"Other utils","text":"<pre><code>template &lt;class T, class Func&gt;\nconstexpr void tuple_for_each(T&amp;&amp; tuple, Func&amp;&amp; func)\n</code></pre> <p>Applies unary function <code>func</code> to all elements of the tuple <code>tuple</code>.</p> <p>Note: This is not a part reflection, the function is provided for convenience when working with tuples in general.</p> <pre><code>template &lt;class T1, class T2, class Func&gt;\nconstexpr void tuple_for_each(T1&amp;&amp; tuple_1, T2&amp;&amp; tuple_2, Func&amp;&amp; func)\n</code></pre> <p>Applies binary function <code>func</code> to all elements of the tuple pair <code>tuple_1</code>, <code>tuple_2</code>.</p> <p>Note: This is not a part reflection, the function is provided for convenience when working with tuples in general.</p>"},{"location":"module_struct_reflect.html#examples","title":"Examples","text":""},{"location":"module_struct_reflect.html#basic-reflection","title":"Basic reflection","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>// Define struct &amp; reflection\nstruct Quaternion { double r, i, j, k; }; // could be any struct with a lot of fields\n\nUTL_STRUCT_REFLECT(Quaternion, r, i, j, k);\n\n// Test basic reflection\nusing namespace utl;\n\nstatic_assert( struct_reflect::type_name&lt;Quaternion&gt; == \"Quaternion\" );\n\nstatic_assert( struct_reflect::size&lt;Quaternion&gt; == 4 );\n\nstatic_assert( struct_reflect::names&lt;Quaternion&gt;[0] == \"r\" );\nstatic_assert( struct_reflect::names&lt;Quaternion&gt;[1] == \"i\" );\nstatic_assert( struct_reflect::names&lt;Quaternion&gt;[2] == \"j\" );\nstatic_assert( struct_reflect::names&lt;Quaternion&gt;[3] == \"k\" );\n\nconstexpr Quaternion q = { 5., 6., 7., 8. };\n\nstatic_assert( struct_reflect::get&lt;0&gt;(q) == 5. );\nstatic_assert( struct_reflect::get&lt;1&gt;(q) == 6. );\nstatic_assert( struct_reflect::get&lt;2&gt;(q) == 7. );\nstatic_assert( struct_reflect::get&lt;3&gt;(q) == 8. );\n</code></pre>"},{"location":"module_struct_reflect.html#field-entry-views","title":"Field &amp; entry views","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>// Define struct &amp; reflection\nstruct Quaternion { double r, i, j, k; }; // could be any struct with a lot of fields\n\nUTL_STRUCT_REFLECT(Quaternion, r, i, j, k);\n\n// Test field &amp; entry views\nusing namespace utl;\n\nconstexpr Quaternion q = { 5., 6., 7., 8. };\n\nstatic_assert( struct_reflect::field_view(q) == std::tuple{ 5., 6., 7., 8. } );\n\nstatic_assert( std::get&lt;0&gt;(struct_reflect::entry_view(q)).first  == \"r\" );\nstatic_assert( std::get&lt;0&gt;(struct_reflect::entry_view(q)).second == 5.  );\nstatic_assert( std::get&lt;1&gt;(struct_reflect::entry_view(q)).first  == \"i\" );\nstatic_assert( std::get&lt;1&gt;(struct_reflect::entry_view(q)).second == 6.  );\nstatic_assert( std::get&lt;2&gt;(struct_reflect::entry_view(q)).first  == \"j\" );\nstatic_assert( std::get&lt;2&gt;(struct_reflect::entry_view(q)).second == 7.  );\nstatic_assert( std::get&lt;3&gt;(struct_reflect::entry_view(q)).first  == \"k\" );\nstatic_assert( std::get&lt;3&gt;(struct_reflect::entry_view(q)).second == 8.  );\n</code></pre>"},{"location":"module_struct_reflect.html#using-reflection-to-define-binary-operations","title":"Using reflection to define binary operations","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>// Define struct &amp; reflection\nstruct Quaternion { double r, i, j, k; }; // could be any struct with a lot of fields\n\nUTL_STRUCT_REFLECT(Quaternion, r, i, j, k);\n\n// Define binary operation (member-wise addition)\nconstexpr Quaternion operator+(const Quaternion&amp; lhs, const Quaternion &amp;rhs) noexcept {\n    Quaternion res = lhs;\n    utl::struct_reflect::for_each(res, rhs, [&amp;](auto&amp; l, const auto&amp; r){ l += r; });\n    return res;\n}\n\n// Define binary operation with predicates (member-wise equality)\nconstexpr bool operator==(const Quaternion&amp; lhs, const Quaternion &amp;rhs) noexcept {\n    return utl::struct_reflect::true_for_all(lhs, rhs, [&amp;](const auto&amp; l, const auto&amp; r){ return l == r; });\n}\n\n// Test operations\nstatic_assert( Quaternion{1, 2, 3, 4} + Quaternion{5, 6, 7, 8} == Quaternion{6, 8, 10, 12} );\n</code></pre>"},{"location":"module_struct_reflect.html#iterating-over-a-generic-tuple","title":"Iterating over a generic tuple","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\nstd::tuple&lt;std::string, int   &gt; tuple_1{ \"lorem\", 2 };\nstd::tuple&lt;const char*, double&gt; tuple_2{ \"ipsum\", 3 };\n\n// Print tuple\nstruct_reflect::tuple_for_each(tuple_1, [&amp;](auto&amp;&amp; x){ std::cout &lt;&lt; x &lt;&lt; '\\n'; });\n\n// Print tuple sum\nstruct_reflect::tuple_for_each(tuple_1, tuple_2, [&amp;](auto&amp;&amp; x, auto&amp;&amp; y){ std::cout &lt;&lt; x + y &lt;&lt; '\\n'; });\n\n// notice that tuples don't have to be homogenous,\n// what matters is that binary function can be called on all corresponding pairs\n</code></pre> <p>Output:</p> <pre><code>lorem\n2\nloremipsum\n5\n</code></pre>"},{"location":"module_struct_reflect.html#debug-printing-with-utllog","title":"Debug printing with <code>utl::log</code>","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>// Define struct &amp; reflection\nstruct Quaternion { double r, i, j, k; }; // could be any struct with a lot of fields\n\nUTL_STRUCT_REFLECT(Quaternion, r, i, j, k);\n\n// ...\n\n// Print struct\nusing namespace utl;\n\nconstexpr Quaternion q = { 0.5, 1.5, 2.5, 3.5 };\n\nlog::println(\"q = \", struct_reflect::entry_view(q));\n\n// Note: there is no tight coupling between the modules, \n//       'utl::log' just knows how to expand tuples,\n//       other loggers that do this will also work\n</code></pre> <p>Output:</p> <pre><code>q = &lt; &lt; r, 0.5 &gt;, &lt; i, 1.5 &gt;, &lt; j, 2.5 &gt;, &lt; k, 3.5 &gt; &gt;\n</code></pre>"},{"location":"module_table.html","title":"utl::table","text":""},{"location":"module_table.html#utltable","title":"utl::table","text":"<p>&lt;- to README.md</p> <p>&lt;- to implementation.hpp</p> <p>utl::table is a small header for exporting data to various tabular formats, it supports:</p> <ul> <li>ASCII</li> <li>Markdown</li> <li>LaTeX</li> <li>Mathematica</li> <li>CSV</li> </ul> <p>Useful numerical work with visualization and reports. Main design goals:</p> <ul> <li>Concise API</li> <li>Good performance</li> <li>Locale-independent</li> </ul> <p>Below is a quick usage showcase:</p> Code Formats to"},{"location":"module_table.html#definitions","title":"Definitions","text":"<pre><code>// Table formats\nstruct ASCII {\n    explicit ASCII(std::size_t cols);\n\n    template &lt;class... T&gt;\n    void cell(T&amp;&amp;... args);\n\n    void hline();\n\n    std::string format() const;\n};\n\nstruct Markdown {\n    explicit Markdown(std::vector&lt;std::string&gt; title);\n\n    template &lt;class... T&gt;\n    void cell(T&amp;&amp;... args);\n\n    std::string format();\n};\n\nstruct LaTeX {\n    explicit LaTeX(std::size_t cols);\n\n    template &lt;class... T&gt;\n    void cell(T&amp;&amp;... args);\n\n    void hline();\n\n    std::string format();\n};\n\nstruct Mathematica {\n    explicit Mathematica(std::size_t cols);\n\n    template &lt;class... T&gt;\n    void cell(T&amp;&amp;... args);\n\n    void hline();\n\n    std::string format();\n};\n\nstruct CSV {\n    explicit CSV(std::size_t cols) : matrix(cols);\n\n    template &lt;class... T&gt;\n    void cell(T&amp;&amp;... args);\n\n    std::string format();\n};\n\n// Number formatting\ntemplate &lt;class T&gt;\nstruct Number {\n    constexpr explicit Number(\n        T                 value,\n        std::chars_format format    = std::chars_format::general,\n        int               precision = 3\n    ) noexcept;\n};\n</code></pre>"},{"location":"module_table.html#methods","title":"Methods","text":""},{"location":"module_table.html#table-formats-ascii","title":"Table formats: ASCII","text":"<pre><code>explicit ASCII(std::size_t cols);\n</code></pre> <p>Constructs ASCII table with <code>cols</code> columns.</p> <pre><code>template &lt;class... T&gt;\nvoid cell(T&amp;&amp;... args);\n</code></pre> <p>Adds one or several cells to the table with <code>args</code> as their contents.</p> <p><code>T</code> can be an instance of any numeric, boolean, or string-convertible type.</p> <p>Note: The table will automatically escape any control chars in the string (such as <code>\\r</code>, <code>\\n</code> and etc.) so it can be properly rendered in the terminal.</p> <pre><code>void hline();\n</code></pre> <p>Adds horizontal line to the table.</p> <pre><code>std::string format();\n</code></pre> <p>Formats table into a string.</p> <p>Note: In case last row of the table \"wasn't finished\", it automatically gets completed with empty cells. This behavior holds true for every format.</p>"},{"location":"module_table.html#table-formats-markdown","title":"Table formats: Markdown","text":"<pre><code>explicit Markdown(std::vector&lt;std::string&gt; title);\n</code></pre> <p>Constructs Markdown table with given <code>title</code>. This results in <code>title.size()</code> columns.</p> <pre><code>template &lt;class... T&gt;\nvoid cell(T&amp;&amp;... args);\n</code></pre> <p>Adds one or several cells to the table with <code>args</code> as their contents.</p> <p><code>T</code> can be an instance of any numeric, boolean, or string-convertible type.</p> <p>Note: Since Markdown is implementation-defined, there are no specific restrictions imposed on the strings in the table. For example, some markdown flavors might want to export HTML cells, while other would consider such syntax to be invalid.</p> <pre><code>std::string format();\n</code></pre> <p>Formats table into a string.</p>"},{"location":"module_table.html#table-formats-latex","title":"Table formats: LaTeX","text":"<pre><code>explicit LaTeX(std::size_t cols);\n</code></pre> <p>Constructs LaTeX table with <code>cols</code> columns.</p> <pre><code>template &lt;class... T&gt;\nvoid cell(T&amp;&amp;... args);\n</code></pre> <p>Adds one or several cells to the table with <code>args</code> as their contents.</p> <p><code>T</code> can be an instance of any numeric, boolean, or string-convertible type.</p> <p>Note 1: To allow export of hand-written LaTeX expressions, there are no specific restrictions on imposed strings in the table.</p> <p>Note 2: Integer and floating point numbers will be formatted as proper LaTeX formulas. This includes numbers in scientific and hex notation.</p> <pre><code>void hline();\n</code></pre> <p>Adds horizontal line to the table.</p> <pre><code>std::string format();\n</code></pre> <p>Formats table into a string.</p>"},{"location":"module_table.html#table-formats-mathematica","title":"Table formats: Mathematica","text":"<pre><code>explicit Mathematica(std::size_t cols);\n</code></pre> <p>Constructs Mathematica table with <code>cols</code> columns.</p> <pre><code>template &lt;class... T&gt;\nvoid cell(T&amp;&amp;... args);\n</code></pre> <p>Adds one or several cells to the table with <code>args</code> as their contents.</p> <p><code>T</code> can be an instance of any numeric, boolean, or string-convertible type.</p> <p>Note 1: Mathematica strings can include almost any Unicode character. Double-quotes in the string are automatically escaped.</p> <p>Note 2: Floating point numbers in scientific notation are formatted according to the Mathematica specification.</p> <pre><code>void hline();\n</code></pre> <p>Adds horizontal line to the table.</p> <pre><code>std::string format();\n</code></pre> <p>Formats table into a string.</p>"},{"location":"module_table.html#table-formats-csv","title":"Table formats: CSV","text":"<pre><code>explicit CSV(std::size_t cols);\n</code></pre> <p>Constructs CSV table with <code>cols</code> columns.</p> <pre><code>template &lt;class... T&gt;\nvoid cell(T&amp;&amp;... args);\n</code></pre> <p>Adds one or several cells to the table with <code>args</code> as their contents.</p> <p><code>T</code> can be an instance of any numeric, boolean, or string-convertible type.</p> <p>Note: CSV is a format without standardized specification. This library refers to commonly supported RFC-4180 guidelines for format and special character handling.</p> <pre><code>void hline();\n</code></pre> <p>Adds horizontal line to the table.</p> <pre><code>std::string format();\n</code></pre> <p>Formats table into a string.</p>"},{"location":"module_table.html#number-formatting","title":"Number formatting","text":"<pre><code>template &lt;class T&gt;\nstruct Number {\n    constexpr explicit Number(\n        T                 value,\n        std::chars_format format    = std::chars_format::general,\n        int               precision = 3\n    ) noexcept;\n};\n</code></pre> <p>A thin wrapper around the floating-point <code>value</code> used to specify its format. See corresponding example.</p>"},{"location":"module_table.html#examples","title":"Examples","text":""},{"location":"module_table.html#ascii-table","title":"ASCII table","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>utl::table::ASCII tb(4);\n\ntb.hline();\ntb.cell(\"Task\", \"Time\", \"Error\", \"Done\");\ntb.hline();\ntb.cell(\"Work 1\", 1.35, 3.7e-5, true );\ntb.cell(\"Work 2\", 1.35, 2.5e-8, false);\ntb.hline();\n\nstd::cout &lt;&lt; tb.format();\n</code></pre> <p>Output:</p> <pre><code>|--------|------|---------|-------|\n| Task   | Time | Error   | Done  |\n|--------|------|---------|-------|\n| Work 1 | 1.35 | 3.7e-05 | true  |\n| Work 2 | 1.35 | 2.5e-08 | false |\n|--------|------|---------|-------|\n</code></pre>"},{"location":"module_table.html#markdown-table","title":"Markdown table","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>utl::table::Markdown tb({\"Task\", \"Time\", \"Error\", \"Done\"});\n\ntb.cell(\"Work 1\", 1.35, 3.7e-5, true );\ntb.cell(\"Work 2\", 1.35, 2.5e-8, false);\n\nstd::cout &lt;&lt; tb.format();\n</code></pre> <p>Output:</p> <pre><code>| Task   | Time | Error   | Done    |\n| ------ | ---- | ------- | ------- |\n| Work 1 | 1.35 | 3.7e-05 | `true`  |\n| Work 2 | 1.35 | 2.5e-08 | `false` |\n</code></pre>"},{"location":"module_table.html#latex-table","title":"LaTeX table","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>utl::table::LaTeX tb(4);\n\ntb.hline();\ntb.cell(\"Task\", \"Time\", \"Error\", \"Done\");\ntb.hline();\ntb.cell(\"Work 1\", 1.35, 3.7e-5, true );\ntb.cell(\"Work 2\", 1.35, 2.5e-8, false);\ntb.hline();\n\nstd::cout &lt;&lt; tb.format();\n</code></pre> <p>Output:</p> <pre><code>\\begin{tabular}{|c|c|c|c|}\n\\hline\n    Task   &amp; Time   &amp; Error               &amp; Done  \\\\\n\\hline\n    Work 1 &amp; $1.35$ &amp; $3.7 \\cdot 10^{-5}$ &amp; true  \\\\\n    Work 2 &amp; $1.35$ &amp; $2.5 \\cdot 10^{-8}$ &amp; false \\\\\n\\hline\n\\end{tabular}\n</code></pre>"},{"location":"module_table.html#mathematica-table","title":"Mathematica table","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>utl::table::Mathematica tb(4);\n\ntb.hline();\ntb.cell(\"Task\", \"Time\", \"Error\", \"Done\");\ntb.hline();\ntb.cell(\"Work 1\", 1.35, 3.7e-5, true );\ntb.cell(\"Work 2\", 1.35, 2.5e-8, false);\ntb.hline();\n\nstd::cout &lt;&lt; tb.format();\n</code></pre> <p>Output:</p> <pre><code>Grid[{\n    { \"Task\"  , \"Time\", \"Error\" , \"Done\" },\n    { \"Work 1\", 1.35  , 3.7*^-05, True   },\n    { \"Work 2\", 1.35  , 2.5*^-08, False  }\n}, Dividers -&gt; {All, {True, True, False, True}}]\n</code></pre>"},{"location":"module_table.html#csv-table","title":"CSV table","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>utl::table::CSV tb(4);\n\ntb.cell(\"Task\", \"Time\", \"Error\", \"Done\");\ntb.cell(\"Work 1\", 1.35, 3.7e-5, true );\ntb.cell(\"Work 2\", 1.35, 2.5e-8, false);\n\nstd::cout &lt;&lt; tb.format();\n</code></pre> <p>Output:</p> <pre><code>\"Task\",\"Time\",\"Error\",\"Done\"\n\"Work 1\",1.35,3.7e-05,true\n\"Work 2\",1.35,2.5e-08,false\n</code></pre>"},{"location":"module_table.html#floating-point-formatting","title":"Floating-point formatting","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\nconst auto format_number = [](double x) { return table::Number{x, std::chars_format::scientific, 1}; };\n\ntable::Markdown tb({\"Method\", \"Error\"});\n\ntb.cell(\"Jacobi\", format_number(3.475e-4));\ntb.cell(\"Seidel\", format_number(6.732e-6));\n\nstd::cout &lt;&lt; tb.format();\n</code></pre> <p>Output:</p> <pre><code>| Method | Error   |\n| ------ | ------- |\n| Jacobi | 3.5e-04 |\n| Seidel | 6.7e-06 |\n</code></pre>"},{"location":"module_table.html#building-tables-cell-by-cell","title":"Building tables cell-by-cell","text":"<p>[ Run this code ] [ Open source file ] </p> <pre><code>utl::table::Markdown tb({\"Method\", \"Error\", \"Converged\"});\n\n// 1 call to 'cell()' doesn't necessarily have to fill the entire row at once\ntb.cell(\"Jacobi\");\ntb.cell(3.475e-4);\ntb.cell(false);\n\ntb.cell(\"Seidel\");\ntb.cell(6.732e-6, true);\n\nstd::cout &lt;&lt; tb.format();\n</code></pre> <p>Output:</p> <pre><code>| Method | Error     | Converged |\n| ------ | --------- | --------- |\n| Jacobi | 0.0003475 | `false`   |\n| Seidel | 6.732e-06 | `true`    |\n</code></pre>"},{"location":"module_time.html","title":"utl::time","text":""},{"location":"module_time.html#utltime","title":"utl::time","text":"<p>&lt;- to README.md</p> <p>&lt;- to implementation.hpp</p> <p>utl::time is a header implementing some simple additions to make <code>&lt;chrono&gt;</code>  less verbose for some common use cases.</p> <p>Feature summary:</p> <ul> <li>Split time into hours / minutes / seconds / milliseconds</li> <li>Time string formatting</li> <li>Floating-point <code>&lt;chrono&gt;</code> time units</li> <li><code>&lt;chrono&gt;</code>-compatible timers &amp; stopwatches</li> <li>C++ wrappers for <code>&lt;ctime&gt;</code> date-time functionality</li> </ul> <p>Note</p> <p>With C++20 <code>&lt;chrono&gt;</code> gets a native way of handling date-time.</p>"},{"location":"module_time.html#definitions","title":"Definitions","text":"<pre><code>// Unit split\nstruct SplitDuration {\n    std::chrono::hours        hours;\n    std::chrono::minutes      min;\n    std::chrono::seconds      sec;\n    std::chrono::milliseconds ms;\n    std::chrono::microseconds us;\n    std::chrono::nanoseconds  ns;\n};\n\ntemplate &lt;class Rep, class Period&gt;\nconstexpr SplitDuration unit_split(std::chrono::duration&lt;Rep, Period&gt; value);\n\ntemplate &lt;class Rep, class Period&gt;\nstd::string to_string(std::chrono::duration&lt;Rep, Period&gt; value, std::size_t relevant_units = 3);\n\n// Floating-point time\ntemplate &lt;class T&gt; using float_duration;\n\nusing ns    = float_duration&lt;std::chrono::nanoseconds &gt;;\nusing us    = float_duration&lt;std::chrono::microseconds&gt;;\nusing ms    = float_duration&lt;std::chrono::milliseconds&gt;;\nusing sec   = float_duration&lt;std::chrono::seconds     &gt;;\nusing min   = float_duration&lt;std::chrono::minutes     &gt;;\nusing hours = float_duration&lt;std::chrono::hours       &gt;;\n\n// Stopwatch\ntemplate &lt;class Clock = std::chrono::steady_clock&gt;\nstruct Stopwatch {\n    using clock      = Clock;\n    using time_point = typename clock::time_point;\n    using duration   = typename clock::duration;\n\n    Stopwatch();\n    void start();\n\n    duration    elapsed()        const;\n    ns          elapsed_ns()     const;\n    us          elapsed_us()     const;\n    ms          elapsed_ms()     const;\n    sec         elapsed_sec()    const;\n    min         elapsed_min()    const;\n    hours       elapsed_hours()  const;\n\n    std::string elapsed_string(std::size_t relevant_units = 3) const;\n};\n\n// Timer\ntemplate &lt;class Clock = std::chrono::steady_clock&gt;\nstruct Timer {\n    using clock      = Clock;\n    using time_point = typename clock::time_point;\n    using duration   = typename clock::duration;\n\n    Timer();\n\n    template &lt;class Rep, class Period&gt;\n    explicit Timer(std::chrono::duration&lt;Rep, Period&gt; length);\n\n    template &lt;class Rep, class Period&gt;\n    void start(std::chrono::duration&lt;Rep, Period&gt; length);\n\n    void stop() noexcept;\n\n    duration    elapsed()        const;\n    ns          elapsed_ns()     const;\n    us          elapsed_us()     const;\n    ms          elapsed_ms()     const;\n    sec         elapsed_sec()    const;\n    min         elapsed_min()    const;\n    hours       elapsed_hours()  const;\n\n    std::string elapsed_string(std::size_t relevant_units = 3) const;\n\n    bool     finished() const;\n    bool      running() const noexcept;\n    duration   length() const noexcept;\n};\n\n// Local datetime\nstd::tm to_localtime(const std::time_t&amp; time);\n\nstd::string datetime_string(const char* format = \"%Y-%m-%d %H:%M:%S\");\n</code></pre>"},{"location":"module_time.html#methods","title":"Methods","text":""},{"location":"module_time.html#unit-split","title":"Unit split","text":"<pre><code>struct SplitDuration {\n    std::chrono::hours        hours;\n    std::chrono::minutes      min;\n    std::chrono::seconds      sec;\n    std::chrono::milliseconds ms;\n    std::chrono::microseconds us;\n    std::chrono::nanoseconds  ns;\n};\n</code></pre> <p>POD struct representing duration split into individual units.</p> <p><code>cpp template &lt;class Rep, class Period&gt; constexpr SplitDuration unit_split(std::chrono::duration&lt;Rep, Period&gt; value);</code></p> <p>Splits given duration into distinct units.</p> <p>For example, <code>73432</code> milliseconds will be split into <code>1</code> minute, <code>13</code> seconds and <code>432</code> milliseconds.</p> <pre><code>template &lt;class Rep, class Period&gt;\nstd::string to_string(std::chrono::duration&lt;Rep, Period&gt; value, std::size_t relevant_units = 3);\n</code></pre> <p>Converts given duration to a string, showing counts only for the highest <code>relevant_units</code>.</p> <p>See table below for an example:</p> Duration <code>relevant_units</code> Resulting string <code>73432</code> milliseconds 4 <code>1 min 13 sec 432 ms 0 us</code> <code>73432</code> milliseconds Default (3) <code>1 min 13 sec 432 ms</code> <code>73432</code> milliseconds 2 <code>1 min 13 sec</code> <code>73432</code> milliseconds 1 <code>1 min</code> <code>73432</code> milliseconds 0 Empty string"},{"location":"module_time.html#floating-point-time","title":"Floating-point time","text":"<p>Note</p> <p>While all <code>std</code> clocks return time with integer representation, <code>&lt;chrono&gt;</code> has native support for all arithmetic types, floating-point-represented time can be used seamlessly with all of the standard functionality.</p> <pre><code>template &lt;class T&gt; using float_duration;\n</code></pre> <p>Returns a floating-point time type corresponding to a given standard time type <code>T</code>. Floating-point time uses <code>double</code> representation.</p> <pre><code>using ns    = float_duration&lt;std::chrono::nanoseconds &gt;;\nusing us    = float_duration&lt;std::chrono::microseconds&gt;;\nusing ms    = float_duration&lt;std::chrono::milliseconds&gt;;\nusing sec   = float_duration&lt;std::chrono::seconds     &gt;;\nusing min   = float_duration&lt;std::chrono::minutes     &gt;;\nusing hours = float_duration&lt;std::chrono::hours       &gt;;\n</code></pre> <p>Typedefs for floating-point-represented time units.</p>"},{"location":"module_time.html#stopwatch","title":"Stopwatch","text":"<pre><code>Stopwatch();\nvoid start();\n</code></pre> <p>Starts the time measurement.</p> <pre><code>duration    elapsed()        const;\n</code></pre> <p>Returns time elapsed since last <code>start()</code> (or <code>Stopwatch</code> construction) as a <code>Clock::duration</code>.</p> <pre><code>ns          elapsed_ns()     const;\nus          elapsed_us()     const;\nms          elapsed_ms()     const;\nsec         elapsed_sec()    const;\nmin         elapsed_min()    const;\nhours       elapsed_hours()  const;\n</code></pre> <p>Returns time elapsed since last <code>start()</code> (or <code>Stopwatch</code> construction) as a floating-point duration.</p> <pre><code>std::string elapsed_string() const;\n</code></pre> <p>Returns time elapsed since last <code>start()</code> (or <code>Stopwatch</code> construction) as a formatted <code>std::string</code>.</p> <p>Note: See <code>time::to_string()</code> for an example of output string format.</p>"},{"location":"module_time.html#timer","title":"Timer","text":"<pre><code>Timer();\n</code></pre> <p>Creates timer with a default state. Does not start time measurement.</p> <pre><code>template &lt;class Rep, class Period&gt; explicit Timer(std::chrono::duration&lt;Rep, Period&gt; length);\ntemplate &lt;class Rep, class Period&gt; void     start(std::chrono::duration&lt;Rep, Period&gt; length);\n</code></pre> <p>Starts timer with duration <code>length</code>.</p> <pre><code> void stop() noexcept;\n</code></pre> <p>Stops the timer, returning it to a default state.</p> <pre><code>duration    elapsed()        const;\n</code></pre> <p>Returns time elapsed since last <code>start()</code> as a <code>Clock::duration</code>.</p> <pre><code>ns          elapsed_ns()     const;\nus          elapsed_us()     const;\nms          elapsed_ms()     const;\nsec         elapsed_sec()    const;\nmin         elapsed_min()    const;\nhours       elapsed_hours()  const;\n</code></pre> <p>Returns time elapsed since last <code>start()</code> as a floating-point duration.</p> <pre><code>std::string elapsed_string() const;\n</code></pre> <p>Returns time elapsed since last <code>start()</code> as a formatted <code>std::string</code>.</p> <p>Note: See <code>time::to_string()</code> for an example of output string format.</p> <pre><code>bool finished() const;\n</code></pre> <p>Returns <code>true</code> if elapsed time is larger than the timer length, <code>false</code> otherwise.</p> <pre><code>bool running() const noexcept;\n</code></pre> <p>Returns <code>true</code> if the timer is currently running, <code>false</code> if it's in a default state (either because it wasn't started or because it was explicitly reset with <code>.stop()</code>).</p> <pre><code>duration length() const noexcept;\n</code></pre> <p>Return timer length.</p>"},{"location":"module_time.html#local-datetime","title":"Local datetime","text":"<pre><code>std::tm to_localtime(const std::time_t&amp; time);\n</code></pre> <p>Thread-safe replacement for <code>std::localtime()</code>.</p> <p>There are 3 ways of getting local time in C-stdlib: 1. <code>std::localtime()</code> \u2014 isn't thread-safe and will be marked as \"deprecated\" by MSVC 2. <code>localtime_r()</code>  \u2014 isn't a part of C++, it's a part of C11, in reality provided by POSIX 3. <code>localtime_s()</code>   \u2014 isn't a part of C++, it's a part of C23, in reality provided by Windows with reversed order of arguments</p> <p>Usually working around this will requires some <code>#ifdef</code>'s and non-portable code, however it is possible to exploit some side effects of <code>std::mktime()</code> to emulate this function in a thread-safe manner that works on every compiler.</p> <pre><code>std::string datetime_string(const char* format = \"%Y-%m-%d %H:%M:%S\");\n</code></pre> <p>Returns current date as a string of a given format. Format strings follow <code>std::strftime()</code> specification.</p> <p>Thread-safe just like the previous function.</p>"},{"location":"module_time.html#examples","title":"Examples","text":""},{"location":"module_time.html#get-elapsed-time","title":"Get elapsed time","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\nconst auto some_work = []{ std::this_thread::sleep_for(time::sec(1.7)); };\n\n// Elapsed time as string\ntime::Stopwatch watch;\nsome_work();\nstd::cout &lt;&lt; time::to_string(watch.elapsed()) &lt;&lt; '\\n';\n\n// Elapsed time as double\nwatch.start();\nsome_work();\nstd::cout &lt;&lt; watch.elapsed_ms().count()       &lt;&lt; '\\n';\n</code></pre> <p>Output: <pre><code>1 sec 700 ms 67 us\n1700.48\n</code></pre></p>"},{"location":"module_time.html#accumulate-time","title":"Accumulate time","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\nconst auto some_work = [] { std::this_thread::sleep_for(time::sec(0.05)); };\n\n// Accumulate time on 'some_work()' in a loop\ntime::Stopwatch watch;\ntime::ms        total{};\n\nfor (std::size_t i = 0; i &lt; 20; ++i) {\n    watch.start();\n    some_work();\n    total += watch.elapsed();\n}\n\nstd::cout &lt;&lt; time::to_string(total, 2) &lt;&lt; '\\n';\n</code></pre> <p>Output: <pre><code>1 sec 4 ms\n</code></pre></p>"},{"location":"module_time.html#set-timers","title":"Set timers","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\ntime::Timer   timer;\nstd::uint64_t count = 0;\n\ntimer.start(time::sec(1));\nwhile (!timer.finished()) ++count;\nstd::cout &lt;&lt; \"Counted to \" &lt;&lt; count &lt;&lt; \" while looping for \" &lt;&lt; time::to_string(timer.length()) &lt;&lt; '\\n';\n</code></pre> <p>Output: <pre><code>Counted to 42286547 while looping for 1 sec 0 ms 0 us\n</code></pre></p>"},{"location":"module_time.html#get-local-date-time","title":"Get local date &amp; time","text":"<p>[ Run this code ] [ Open source file ]</p> <pre><code>using namespace utl;\n\nstd::cout\n    &lt;&lt; \"Current date:     \" &lt;&lt; time::datetime_string(\"%y-%m-%d\") &lt;&lt; '\\n'\n    &lt;&lt; \"Current time:     \" &lt;&lt; time::datetime_string(\"%H:%M:%S\") &lt;&lt; '\\n'\n    &lt;&lt; \"Current datetime: \" &lt;&lt; time::datetime_string()           &lt;&lt; '\\n';\n</code></pre> <p>Output: <pre><code>Current date:     25-03-18\nCurrent time:     04:14:13\nCurrent datetime: 2025-03-18 04:14:13\n</code></pre></p>"},{"location":"module_time.html#motivation","title":"Motivation","text":"<p>Most of the things implemented in this module are quite simple to do using a native <code>&lt;chrono&gt;</code> API, however a lot of the time simple and common use cases require a rather hefty amount of boilerplate or tend to be implemented incorrectly by most examples found online.</p> <p>Below are some of the \"motivating examples\" showcasing that problem:</p>"},{"location":"module_time.html#get-elapsed-time-as-double","title":"Get elapsed time as <code>double</code>","text":"<p><code>std</code>:</p> <pre><code>const auto start = std::chrono::steady_clock::now();\nstd::this_thread::sleep_for(std::chrono::milliseconds(1700)); // wait 1.7 sec\nconst auto   end = std::chrono::steady_clock::now();\nconst double  ms = std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(end - start).count() / 1e6;\n\n// this is how it's usually done, however a truly correct way would be to use\n// floating-point 'duration_cast()' which ends up being even more verbose:\n// const double ms = std::chrono::duration_cast&lt;std::chrono::duration&lt;double, \n//                                              std::chrono::milliseconds::period&gt;&gt;(end - start).count();\n</code></pre> <p><code>utl::time</code>:</p> <pre><code>const time::Stopwatch watch;\nstd::this_thread::sleep_for(time::sec(1.7));  // wait 1.7 sec\nconst double ms = watch.elapsed_ms().count();\n</code></pre>"},{"location":"module_time.html#convert-duration-to-different-units","title":"Convert duration to different units","text":"<p><code>std</code>:</p> <pre><code>const auto time_ms = std::chrono::milliseconds(1700);\n\nconst auto time_sec = std::chrono::duration_cast&lt;std::chrono::seconds&gt;(time_ms);\n\n// conversion to rougher units is a loss of information (700 ms),\n// due to that it requires an explicit 'duration_cast()'\n\nconst auto time_ns = std::chrono::nanoseconds(time_ms);\n\n// conversion to finer units happens seamlessly\n</code></pre> <p><code>utl::time</code>:</p> <pre><code>const auto time_ms  = time::ms(1700);\n\nconst auto time_sec = time::sec(time_ms);\nconst auto time_ns  = time::ns (time_ms);\n\n// no loss of precision regardless of units, all conversions happen seamlessly\n</code></pre>"},{"location":"module_time.html#get-current-date-time","title":"Get current date &amp; time","text":"<p><code>std</code>:</p> <pre><code>const auto now    = std::chrono::system_clock::now();\nconst auto c_time = std::chrono::system_clock::to_time_t(now);\nconst auto c_tm   = *std::localtime(&amp;c_time);;\n\nstd::array&lt;char, 256&gt; buffer;\nstd::strftime(buffer.data(), buffer.size(), \"%Y-%m-%d %H:%M:%S\", &amp;c_tm);\n\nconst auto result = std::string(buffer.data());\n\n// not thread-safe, will give a warning in MSVC, we need '#ifdef's to specify 'localtime_r()'\n// for POSIX, 'localtime_s()' for Windows and mutex-protected 'std::localtime()' otherwise\n\n// doesn't include error handling, if format string was larger that in this example 'std::strftime()'\n// will mess up the formatting and return '0' which usually goes unchecked in examples found online\n\n// in C++20 this gets much easier due to a new &lt;chrono&gt; API\n</code></pre> <p><code>utl::time</code>:</p> <pre><code>const auto result = time::datetime_string();\n\n// thread-safe, compiles everywhere, handles possible format errors\n</code></pre>"},{"location":"blog/cpp_performance_issues.html","title":"What separates C++ from being a \"perfect\" performance-oriented language","text":"<p>What this is: A subjective collection of various \"performance issues\" of C++.</p> <p>What constitutes a \"performance issue\": Any quirk of the language and its ecosystem that inclines / forces developers to implement things in a suboptimal (in regards to performance) way.</p> <p>The \"issues\" are listed in no particular order and were initially compiled as a personal note to summarize a bunch of curios quirks, however after a bit of revision it seems good enough to make for a rather interesting read.</p> <p>Every \"issue\" comes with an attached cause and a short explanation.</p> <p>Note</p> <p>This does not intend to be a language critique or necessarily make an argument for the practicality of all listed points. Many of the present points are largely presented as \"what if\" without concerning their pragmatic importance.</p>"},{"location":"blog/cpp_performance_issues.html#performance-issues","title":"Performance issues","text":""},{"location":"blog/cpp_performance_issues.html#no-destructive-move","title":"No destructive move","text":"<p>Cause: Language design.</p> <p>In C++ any moved-from object is required to stay in some kind of a \"valid\" moved-from state. This often requires additional logic in the move-constructor and in certain cases can prevent move from being <code>noexcept</code> (which can affect performance of standard containers, mainly <code>std::vector&lt;&gt;</code>). A good overview of the topic can be found in this blogpost by Jonathan M\u00fcller.</p>"},{"location":"blog/cpp_performance_issues.html#implicit-copy","title":"Implicit copy","text":"<p>Cause: Language design.</p> <p>C++ is a copy-by-default rather than move-by-default language. This makes it easy to accidentally perform a heavyweight copy, which in some cases can hide behind a very innocuous syntax, such as returning a local variable created by a structured binding from a function:</p> <pre><code>SomeHeavyClass f() {\n    auto [res, err] = compute();\n    // ...\n    return res; // this is a copy, no copy elision takes place\n}\n</code></pre>"},{"location":"blog/cpp_performance_issues.html#no-constexpr-priority","title":"No <code>constexpr</code> priority","text":"<p>Cause: Practical concerns.</p> <p>While <code>constexpr</code> functions can be evaluated both at runtime &amp; compile-time, there are no guarantees to which of the options will be chosen unless we manually force the <code>constexpr</code> context:</p> <pre><code>constexpr heavy_function() {\n    // ...\n}\n\nstd::cout &lt;&lt; heavy_function();\n// 'heavy_function()' might be evaluated at runtime unless we force constexpr by assigning it to a constexpr variable first\n</code></pre> <p>From the idealistic perspective, we always want to pre-compute as much as possible at compile time and having to manually \"force\" <code>constexpr</code> evaluation puts additional burden on the programmer. From a more pragmatic perspective forcing <code>constexpr</code> evaluation on everything can have a very significant impact on compilation times due to being significantly slower than a runtime evaluation of the same function.</p>"},{"location":"blog/cpp_performance_issues.html#manual-struct-packing","title":"Manual struct packing","text":"<p>Cause: ABI compatibility, C legacy</p> <p>In C++ member variables are guaranteed to be stored in the order of their declaration. This can often waste space due to alignment requirements, especially when working with large classes where \"performance-optimal\" order and \"readability-optimal\" order might differ:</p> <pre><code>struct Large {\n    std::uint32_t a;\n    std::uint64_t b;\n    std::uint32_t c;\n};\n\nstruct Small {\n    std::uint64_t b;\n    std::uint32_t a;\n    std::uint32_t c;\n};\n\nstatic_assert(sizeof(Large) == 24);\nstatic_assert(sizeof(Small) == 16);\n</code></pre> <p>Some languages that prefer static linking leave this ordering to the compiler, in case of C++ the choice was made in favor of compatibility.</p>"},{"location":"blog/cpp_performance_issues.html#no-way-to-tell-when-a-critical-optimization-has-failed","title":"No way to tell when a critical optimization has failed","text":"<p>Cause: Compiler QoL</p> <p>In some scenarios, performance IS correctness. This mainly concerns vectorization, which can fail due to seemingly minor changes and cause a  sudden x2-x4 performance degradation (and degrading, for example, a game from 60 FPS to 15 FPS makes it effectively non-functional).</p> <p>Unfortunately this is a very complex issue with no easy solution for the problem, most of the time such matters are handled by making a comprehensive benchmark suite with mandated performance degradation tests. An interesting effort was made by the Unity C# compiler which provides a way to declare data-independence and error should these rules be violated.</p>"},{"location":"blog/cpp_performance_issues.html#stdunordered_map-pointer-stability","title":"<code>std::unordered_map</code> pointer stability","text":"<p>Cause: API design</p> <p>Almost every method of <code>std::unordered_map</code> is significantly slower than it could be due to the requirement of pointer stability, which dictates a node-based implementation that does not reallocate any elements.</p> <p>Whether pointer stability is worth the performance cost is frequently debated. An excellent overview of existing map implementations and their performance trade-offs can be found on Martin Ankerl's website.</p> <p>As of 2025 it seems that densely stored designs with open addressing &amp; linear probing (such as <code>boost::unordered_flat_map</code> and <code>ankerl::unordered_dense::map</code>) are a good general go-to.</p>"},{"location":"blog/cpp_performance_issues.html#cmath-error-handling","title":"<code>&lt;cmath&gt;</code> error handling","text":"<p>Cause: C legacy</p> <p><code>&lt;cmath&gt;</code> uses a rather questionable error handling strategy which relies on modifying a global <code>errno</code> object. In many cases this global access prevents compiler from being more aggressive with optimizations, with prevented vectorization being the biggest issue in terms of impact. For this reason many compilers have an option to disable <code>errno</code> reporting (such as <code>-fno-math-errno</code> on GCC &amp; clang).</p> <p>In addition to that, modifying a global variable prevented <code>&lt;cmath&gt;</code> functions from being <code>constexpr</code> up until C++26, which affects a lot of generic code that could also be compile-time evaluated otherwise.</p>"},{"location":"blog/cpp_performance_issues.html#random-algorithms","title":"<code>&lt;random&gt;</code> algorithms","text":"<p>Cause: Outdated algorithms</p> <p>While the core design of <code>&lt;random&gt;</code> is incredibly flexible, its performance suffers from outdated PRNGs and strict algorithmic requirements for distributions. Switching to a more modern set of algorithms can frequently lead to a 2x-6x speedup with no loss of statistical quality.</p> <p>A rather comprehensive overview of this topic can be found in the docs of utl::random. </p>"},{"location":"blog/cpp_performance_issues.html#regex-performance","title":"<code>&lt;regex&gt;</code> performance","text":"<p>Cause: ABI stability</p> <p>Standard library <code>&lt;regex&gt;</code> is known for its downright horrific performance caused by a suboptimal implementation back in the day. At the moment standard library regex tends to be dozens or even hundreds of times slower than modern regex engines of other languages.</p> <p>At the API level there is nothing preventing <code>&lt;regex&gt;</code> from achieving reasonable performance, however it fell victim to the requirement of ABI stability which set in stone its initial implementation, thus preventing any meaningful improvements in the future.</p>"},{"location":"blog/cpp_performance_issues.html#no-standard-128-bit-types","title":"No standard 128-bit types","text":"<p>Cause: Library support</p> <p>A lot of bleeding-edge algorithms for hashing, RNG, serialization and etc. rely on wider type arithmetics which are often natively supported by the architecture (most use cases only need \\(64 \\times 64 \\rightarrow 128\\) bit arithmetic instructions which are common on modern hardware).</p> <p>Since every major compiler supports them through extensions (GCC &amp; clang <code>__uint128</code>, MSVC <code>_umul128()</code> and etc.), this is usually worked around with a bunch of compiler-specific <code>#ifdef</code> blocks with an emulated fallback.</p> <p>Such algorithms would be significantly easier and less error-prone to implement if <code>uint128_t</code> &amp; <code>int128_t</code> were standardized across compilers. Doing so through <code>&lt;cstdint&gt;</code> however might prove challenging due to the concerns of old code compatibility.</p>"},{"location":"blog/cpp_performance_issues.html#no-bit-operations","title":"No bit operations","text":"<p>Cause: Library support</p> <p>[!] Fixed with: C++20</p> <p>Many performant algorithms tend to be written in terms of bit operations present in practically all modern hardware (such as <code>rotl()</code>, <code>popcount()</code>, <code>bit_width()</code>, <code>countl_zero()</code>, <code>bit_cast()</code> and etc.). Up until C++20 <code>&lt;bit&gt;</code> there was no portable way to call such instructions, they were usually written in terns of branches &amp; regular shifts and hopefully optimized down to the intended asm by a compiler.</p>"},{"location":"blog/cpp_performance_issues.html#floating-point-parsing-serialization","title":"Floating point parsing &amp; serialization","text":"<p>Cause: Library support</p> <p>[!] Fixed with: C++17</p> <p>Quickly &amp; correctly parsing / serializing floating point numbers is a task of significant complexity, which saw major improvements with the advancement of Ryu / Grisu / Schubfach / Dragonbox family of algorithms (speedup of several times with better round-trip guarantees).</p> <p>Old serialization methods (such as streams and <code>std::snprintf()</code>) are unable to benefit from such advancements due to their legacy requirements. In C++17 <code>&lt;charconv&gt;</code> was standardized as a performant low-level way of float serialization which should be more flexible in case of future algorithmic improvements.</p>"},{"location":"blog/cpp_performance_issues.html#stream-based-formatting","title":"Stream-based formatting","text":"<p>Cause: API design</p> <p>[!] Fixed with: C++20, C++23 (partially due to incomplete adoption)</p> <p>The \"classic\" way to parse / serialize / format values is based around rather heavyweight polymorphic stream objects that  conflate formatting, I/O and locale manipulation (which in many cases is largely detrimental).</p> <p>This approach is significantly outperformed by the design of <code>fmtlib</code> which was partially standardized in C++20 and C++23.</p>"},{"location":"blog/cpp_performance_issues.html#no-zero-size-member-optimization","title":"No zero-size member optimization","text":"<p>Cause: Language design</p> <p>[!] Fixed with: C++20 (partially due to ABI stability concerns)</p> <p>In C++ all member variables are required to have a valid non-overlapping address. This can pointlessly bloat the object size when working with potentially stateless members (such as allocators, comparators and etc.) whose address is never taken:</p> <pre><code>template &lt;class T, class Allocator = std::allocator&lt;T&gt;, class Comparator = std::less&lt;&gt;&gt;\nstruct Map {\n    Allocator  alloc; // will take space even if stateless\n    Comparator comp;  //\n\n    // ...\n}\n</code></pre> <p>This inefficiency used to be worked-around through inheritance hacks and empty base class optimization, however now with C++20 we have a proper attribute <code>[[no_unique_address]]</code>  to mark those potentially stateless members. Unfortunately, MSVC still ignores it and uses a custom attribute instead.</p>"},{"location":"blog/cpp_performance_issues.html#no-parallel-execution-guarantees","title":"No parallel execution guarantees","text":"<p>Cause: Library support</p> <p>While C++17 added parallel execution modes to much of the <code>&lt;algorithm&gt;</code>, the standard does not mandate that implementations actually have to respect them. For example, GCC will ignore parallel execution modes unless linked against Intel TBB, which goes against the intuitive assumption that parallel algorithms should work out of the box.</p>"},{"location":"blog/cpp_performance_issues.html#limited-reallocation","title":"Limited reallocation","text":"<p>Category: C legacy, complexity</p> <p>Contiguous arrays such as <code>std::vector&lt;&gt;</code> (and other similar classes) should logically be able to grow in-place should the memory allow it, however due to a combination of C <code>realloc()</code> design flaws, <code>std::allocator&lt;&gt;</code> lack of reallocation mechanism and RAII requirements such ability never made it into the standard (or most of the existing libraries for that matter).</p> <p>In fact, even further gains could be made if containers had an ability to intrusively ingrate with specific allocators to account for various implementation details, such as, for example <code>folly::fbvector</code> which accounts for the jemalloc fixed-size quanta. Providing such mechanisms in a general case however proved to be a task of significant complexity.</p>"},{"location":"blog/cpp_performance_issues.html#pointer-aliasing","title":"Pointer aliasing","text":"<p>Cause: Language design</p> <p>In many scenarios potential pointer aliasing can prevent compiler from being more aggressive with optimization, in C we can use <code>restrict</code> to signal a lack of aliasing, in C++ however there is no general solution for the problem.</p> <p>Many compilers provide extensions such as GCC <code>__restrict__</code>, however those qualifiers are only applicable to raw pointers and cannot, for example, specify that two instances of <code>std::span&lt;&gt;</code> are non-aliasing:</p> <pre><code>void vector_sum(std::span&lt;double&gt; res, std::span&lt;double&gt; lhs, std::span&lt;double&gt; rhs) {\n    assert(res.size() == lhs.size());\n    assert(res.size() == rhs.size());\n\n    for (std::size_t i = 0; i &lt; res.size(); ++i) res[i] = lhs[i] + rhs[i];\n    // vectorization would be incorrect in a general case due to the potential aliasing\n    // when 'res' / lhs' / 'rhs' point to the intersecting chunks of the same array\n}\n</code></pre> <p>For a simple loop like this one many compilers will be able to figure out a special case and use vectorized version when all pointers are proven to be non-aliasing (with a non-vectorized fallback for a general case). In real applications however dependency chains are frequently too complex to be resolved by a compiler, which leads to a significant performance loss relatively to a manually annotated version.</p>"},{"location":"blog/cpp_performance_issues.html#final-notes","title":"Final notes","text":"<p>The list above was initially made as a personal note to summarize a bunch of curios quirks and as such it does not intend to be a critique of language designers &amp; implementers. Every passing standard makes significant strides in resolving &amp; improving a lot of these points and with C++26 bringing <code>std::simd</code> and reflection we are likely to see some excellent changes in the ecosystem.</p> <p>Publication date: 2025.08.30</p> <p>Last revision: 2025.09.03</p>"},{"location":"blog/map_macro_reflection.html","title":"Map-macro: emulating reflection","text":"<p>Recently I've come across a very curios macro, let's call it <code>MAP</code>: <pre><code>#define MAP(f, ...) /* &lt;some preprocessor magic&gt; */\n</code></pre> Let's also say we have a macro <code>F</code> that takes one argument: <pre><code>#define F(arg) /* &lt;some logic&gt; */\n</code></pre> A map-macro allows us to map this function-like macro to a variadic list of arguments, for example <pre><code>MAP(F, a, b, c, d)\n</code></pre> will be evaluate to <pre><code>F(a)\nF(b)\nF(c)\nF(d)\n</code></pre> Using a similar principle, it is also possible to make a <code>MAP_LIST</code> macro which adds commas between the results, which means <code>MAP_LIST(F, a, b, c, d)</code> will evaluate to</p> <pre><code>F(a), F(b), F(c), F(d)\n</code></pre> <p>The implementation of this macro is attached at the end, a rather nice explanation of how it works can be found in this repo.</p> <p>Now, one could spend plenty of time figuring out all the preprocessor magic behind the macro, but what I believe is a more important question is: \"What does this give us?\". From my perspective \u2014 an almost perfect tool to implement codegen macros for reflection.</p> <p>Note</p> <p>Strictly speaking, we will be dealing with a way of providing types with non-intrusive introspection metadata, rather than a proper reflection. A battle-tested implementation of this mechanism is provided Boost.Describe, since the end goals are the same the term \"reflection\" will be used for conciseness.</p> <p>Note</p> <p>Ultimately, proper reflection can only be supported at the language level, everything we do before C++26 is trying to bolt-in a language feature using various workarounds.</p>"},{"location":"blog/map_macro_reflection.html#enum-reflection","title":"<code>enum</code> reflection","text":"<p>Let's first establish what do we even want from an <code>enum</code> reflection. The main things people usually wish for are:</p> <ul> <li>Enum &lt;-&gt; string conversion</li> <li>Ability to access enumeration elements like an array</li> </ul> <p>This means that minimally we want to achieve an API like this: <pre><code>enum class Side { LEFT, RIGHT };\n\n// ...\n\nstatic_assert( to_string(Side::LEFT) == \"LEFT\" );\nstatic_assert( from_string&lt;Side&gt;(\"LEFT\") == Side::LEFT );\nstatic_assert( size&lt;Side&gt; == 2 );\nstatic_assert( values&lt;Side&gt;[0] == Side::LEFT );\nstatic_assert( values&lt;Side&gt;[1] == Side::RIGHT );\n</code></pre> A map macro makes this almost trivial! All we need is to register enum with a macro: <pre><code>REFLECT_ENUM(Side, LEFT, RIGHT)\n</code></pre> and have that macro forward our stringified <code>__VA_ARGS__</code> into arrays of names and values. While we're at it let's also create array of name-value pairs \u2014 this will make iteration more convenient.</p> <p>Using template specialization as a mechanism for registering types we can do following: <pre><code>// Declare base template that cannot be instantiated\ntemplate &lt;class Enum&gt;\nstruct meta {\n    static_assert(always_false_v&lt;Enum&gt;, \"Enum has no reflection\");\n}\n\n// Define macros that we're gonna apply with MAP\n#define MAKE_NAME( arg) std::string_view(#arg)\n#define MAKE_VALUE(arg) type::arg\n#define MAKE_ENTRY(arg) std::pair{ std::string_view(#arg), type::arg }\n\n// Declare specialized template with enum metadata\n#define REFLECT_ENUM(enum_name, ...)                                          \\\ntemplate &lt;&gt;                                                                   \\\nstruct meta&lt;enum_name&gt; {                                                      \\\n    using type             = enum_name;                                       \\\n    constexpr auto names   = std::array{ MAP_LIST(MAKE_NAME,  __VA_ARGS__) }; \\\n    constexpr auto values  = std::array{ MAP_LIST(MAKE_VALUE, __VA_ARGS__) }; \\\n    constexpr auto entries = std::array{ MAP_LIST(MAKE_VALUE, __VA_ARGS__) }; \\\n}\n</code></pre> At this point the trickiest part of the task is basically done \u2014 string conversion is just a matter of doing an array lookup for a corresponding type: <pre><code>template&lt;class Enum&gt;\nconstexpr to_string(Enum e) {\n    for (const auto&amp; [name, val] : meta&lt;Enum&gt;::entries) if (e == val) return name;\n    throw std::out_of_range(\"Value is not a part of enum.\")\n}\n\ntemplate&lt;class Enum&gt;\nconstexpr from_string(std::string_view str) {\n    for (const auto&amp; [name, val] : meta&lt;Enum&gt;::entries) if (str == name) return val;\n    throw std::out_of_range(\"String does not correspond to a value in enum.\")\n}\n</code></pre></p> <p>while the rest can be just trivially wrapped in a public API:</p> <pre><code>template &lt;class Enum&gt; constexpr auto names   = meta&lt;Enum&gt;::names;\ntemplate &lt;class Enum&gt; constexpr auto values  = meta&lt;Enum&gt;::values;\ntemplate &lt;class Enum&gt; constexpr auto entries = meta&lt;Enum&gt;::entries;\n</code></pre> <p>Note</p> <p>A more performant option for large enums would be to build a static map in addition to arrays and use it to perform <code>O(1)</code> lookup during string conversion, however that falls under \"implementation details\". Using a map also makes it more difficult to provide functions as <code>constexpr</code>.</p> <p>A \"clean\" implementation including all of this and some other convenient functions is provided by utl::enum_reflect header which can be found here.</p>"},{"location":"blog/map_macro_reflection.html#struct-reflection","title":"<code>struct</code> reflection","text":"<p>Same as before, let's first identify the basic goals we want to achieve, usually people wish to:</p> <ul> <li>Treat structures like tuples</li> <li>\"Iterate\" over struct members</li> <li>Use the above to implement generic ways to serialize / parse / compare structs.</li> </ul> <p>In short, we want to achieve something like this:</p> <pre><code>struct Config {\n    std::string date;\n    std::size_t size;\n    double      coef;\n};\n\nREFLECT_STRUCT(Config, date, size, coef);\n\n// Name reflection\nstatic_assert( size&lt;Config&gt; == 3 );\n\nstatic_assert( names&lt;Config&gt;[0] == \"date\" );\nstatic_assert( names&lt;Config&gt;[1] == \"size\" );\nstatic_assert( names&lt;Config&gt;[2] == \"coef\" );\n\n// Iterate members with a visitor function\nConfig cfg = { \"2025.03.21\", 127, 0.5 };\n\nstd::cout &lt;&lt; \"struct contents = \\n\";\nfor_each(cfg, [](const auto&amp; field){ std::cout &lt;&lt; field &lt;&lt; '\\n'; });\n\n// Access struct like a tuple\nassert( get&lt;0&gt;(cfg) == \"2025.03.21\" );\n\n// Treat whole struct as a tuple\nauto tuple = field_view(cfg);\nassert( std::get&lt;0&gt;(tuple) == \"2025.03.21\" );\n</code></pre> <p>Note</p> <p>The are obliviously some other convenient things we would want such as <code>entry_view()</code> for name-value pairs, ability to use <code>for_each()</code> to define binary operators, predicates and etc. All of this will be provided in the implementation linked at the end.</p> <p>Same as with <code>enum</code>, we can forward stringified <code>__VA_ARGS__</code> from register macro and use them to build up a partial specialization with some metadata:</p> <pre><code>// Declare base template that cannot be instantiated\ntemplate &lt;class Struct&gt;\nstruct meta {\n    static_assert(_always_false_v&lt;Struct&gt;, \"Struct has no reflection.\");\n};\n\n// Define macros that we're gonna apply with MAP\n#define MAKE_NAME( arg) std::string_view(arg)\n#define MAKE_VALUE(arg) std::forward&lt;Struct&gt;(value).arg\n#define CALL_FUNC( arg) func(std::forward&lt;Struct&gt;(value).arg);\n\n// Declare specialized template with struct metadata\n#define REFLECT_STRUCT(struct_name, ...)                                   \\\ntemplate &lt;&gt;                                                                \\\nstruct meta&lt;struct_name&gt; {                                                 \\\n    constexpr auto names = std::array{ MAP_LIST(MAKE_NAME, __VA_ARGS__) }; \\\n                                                                           \\\n    template &lt;class Struct&gt;                                                \\\n    constexpr static auto field_view(Struct&amp;&amp; value) noexcept {            \\\n        return std::forward_as_tuple(MAP_LIST(MAKE_VALUE, __VA_ARGS__));   \\\n    }                                                                      \\\n                                                                           \\\n    template &lt;class Struct, class Func&gt;                                    \\\n    constexpr static void for_each(Struct&amp;&amp; value, Func&amp;&amp; func) {          \\\n        MAP(CALL_FUNC, __VA_ARGS__)                                        \\\n    }                                                                      \\\n}\n</code></pre> <p>After this a public API can trivially wrap the calls to metadata:</p> <pre><code>template &lt;class Struct&gt; constexpr auto names = meta&lt;Struct&gt;::names;\n\ntemplate &lt;class Struct&gt;\nconstexpr auto field_view(Struct&amp;&amp; value) noexcept {\n    using struct_type = typename std::decay_t&lt;Struct&gt;;\n    return meta&lt;struct_type&gt;::field_view(std::forward&lt;Struct&gt;(value));\n}\n\ntemplate &lt;class Struct, class Func&gt;\nconstexpr void for_each(Struct&amp;&amp; value, Func&amp;&amp; func) {\n    using struct_type = typename std::decay_t&lt;Struct&gt;;\n    meta&lt;struct_type&gt;::for_each(std::forward&lt;Struct&gt;(value), std::forward&lt;Func&gt;(func));\n}\n\ntemplate &lt;std::size_t I, class Struct&gt;\nconstexpr auto get(Struct&amp;&amp; value) noexcept {\n    return std::get&lt;I&gt;(field_view(std::forward&lt;Struct&gt;(value)));\n}\n</code></pre> <p>An there it is, we have all the basic building blocks of a proper reflection!</p> <p>A \"clean\" implementation including all of this and some other convenient functions is provided by utl::struct_reflect header which can be found here.</p>"},{"location":"blog/map_macro_reflection.html#some-examples","title":"Some examples","text":"<p>Below are a few small examples showcasing how such reflection can be used.</p>"},{"location":"blog/map_macro_reflection.html#debug-printing","title":"Debug printing","text":"<p>Assuming we have a logger than knows how to print tuples, the task of serializing structs for debug purposes becomes almost trivial:</p> <pre><code>// Define struct &amp; reflection\nstruct Quaternion { double r, i, j, k; }; // could be any struct with a lot of fields\n\nUTL_STRUCT_REFLECT(Quaternion, r, i, j, k);\n\n// ...\n\n// Print struct\nusing namespace utl;\n\nconstexpr Quaternion q = { 0.5, 1.5, 2.5, 3.5 };\n\nlog::println(\"q = \", struct_reflect::entry_view(q));\n</code></pre> <p>will output:</p> <pre><code>q = &lt; &lt; r, 0.5 &gt;, &lt; i, 1.5 &gt;, &lt; j, 2.5 &gt;, &lt; k, 3.5 &gt; &gt;\n</code></pre>"},{"location":"blog/map_macro_reflection.html#binary-operators","title":"Binary operators","text":"<p>A binary version of <code>for_each()</code> can be used to implement generic logic for functions &amp; operators:</p> <pre><code>// Define struct &amp; reflection\nstruct Quaternion { double r, i, j, k; }; // could be any struct with a lot of fields\n\nUTL_STRUCT_REFLECT(Quaternion, r, i, j, k);\n\n// Define binary operation (member-wise addition)\nconstexpr Quaternion operator+(const Quaternion&amp; lhs, const Quaternion &amp;rhs) noexcept {\n    Quaternion res = lhs;\n    utl::struct_reflect::for_each(res, rhs, [&amp;](auto&amp; l, const auto&amp; r){ l += r; });\n    return res;\n}\n\n// Define binary operation with predicates (member-wise equality)\nconstexpr bool operator==(const Quaternion&amp; lhs, const Quaternion &amp;rhs) noexcept {\n    return utl::struct_reflect::true_for_all(lhs, rhs, [&amp;](const auto&amp; l, const auto&amp; r){ return l == r; });\n}\n\n// Test operations\nstatic_assert( Quaternion{1, 2, 3, 4} + Quaternion{5, 6, 7, 8} == Quaternion{6, 8, 10, 12} );\n</code></pre>"},{"location":"blog/map_macro_reflection.html#generic-functions-that-operate-on-struct-members","title":"Generic functions that operate on struct members","text":"<pre><code>// Define structs &amp; reflection\nstruct Vec2 { double x, y; };\nstruct Vec3 { double x, y, z; };\nstruct Vec4 { double x, y, z, w; };\n\nUTL_STRUCT_REFLECT(Vec2, x, y);\nUTL_STRUCT_REFLECT(Vec3, x, y, z);\nUTL_STRUCT_REFLECT(Vec4, x, y, z, w);\n\n// Generic function\ntemplate&lt;class T&gt;\nconstexpr double squared_vector_norm(const T &amp;vec) noexcept {\n    double res = 0;\n    utl::struct_reflect::for_each(vec, [&amp;](const auto&amp; coord){ res += coord * coord; });\n    return res;\n}\n\n// Test the function\nstatic_assert( squared_vector_norm(Vec2{1, 2})       ==  5 );\nstatic_assert( squared_vector_norm(Vec3{1, 2, 3})    == 14 );\nstatic_assert( squared_vector_norm(Vec4{1, 2, 3, 4}) == 30 );\n</code></pre>"},{"location":"blog/map_macro_reflection.html#advanced-examples","title":"Advanced examples","text":"<p>Real-world applications, of course, extend far beyond the toy problems listed above and would be too verbose to fully present here, for example, this exact principle was used to implement reflection for a utl::json parser which knows both how to parse and how to serialize reflected structs with any level of nesting (which means reflected structs can include other reflected structs, nested containers with them and etc.). </p>"},{"location":"blog/map_macro_reflection.html#why-use-this-over-boostpfr-or-boostdescribe","title":"Why use this over <code>Boost.PFR</code> or <code>Boost.Describe</code>","text":"<ul> <li>Simpler API</li> <li>Supports up to 256 enum elements, <code>Boost.Describe</code> is limited to 50</li> <li>Everything is <code>constexpr</code>, <code>boost::pfr::for_each_field()</code> is not</li> <li>Single headers (1 for enums, 1 for structs), no dependencies</li> </ul>"},{"location":"blog/map_macro_reflection.html#why-use-boostpfr-or-boostdescribe-over-this","title":"Why use <code>Boost.PFR</code> or <code>Boost.Describe</code> over this","text":"<ul> <li>More features</li> <li>Mature libraries</li> <li>Works with C++14, <code>utl</code> is a C++17 library</li> <li><code>Boost.PFR</code> doesn't require registration macros</li> </ul>"},{"location":"blog/map_macro_reflection.html#map-macro-implementation","title":"Map-macro implementation","text":"<pre><code>// Implementation\n#define EVAL0(...) __VA_ARGS__\n#define EVAL1(...) EVAL0(EVAL0(EVAL0(__VA_ARGS__)))\n#define EVAL2(...) EVAL1(EVAL1(EVAL1(__VA_ARGS__)))\n#define EVAL3(...) EVAL2(EVAL2(EVAL2(__VA_ARGS__)))\n#define EVAL4(...) EVAL3(EVAL3(EVAL3(__VA_ARGS__)))\n#define EVAL(...)  EVAL4(EVAL4(EVAL4(__VA_ARGS__)))\n\n#define MAP_END(...)\n#define MAP_OUT\n#define MAP_COMMA ,\n\n#define MAP_GET_END2() 0, MAP_END\n#define MAP_GET_END1(...) MAP_GET_END2\n#define MAP_GET_END(...) MAP_GET_END1\n#define MAP_NEXT0(test, next, ...) next MAP_OUT\n#define MAP_NEXT1(test, next) MAP_NEXT0(test, next, 0)\n#define MAP_NEXT(test, next)  MAP_NEXT1(MAP_GET_END test, next)\n\n#define MAP0(f, x, peek, ...) f(x) MAP_NEXT(peek, MAP1)(f, peek, __VA_ARGS__)\n#define MAP1(f, x, peek, ...) f(x) MAP_NEXT(peek, MAP0)(f, peek, __VA_ARGS__)\n\n#define MAP_LIST_NEXT1(test, next) MAP_NEXT0(test, MAP_COMMA next, 0)\n#define MAP_LIST_NEXT(test, next)  MAP_LIST_NEXT1(MAP_GET_END test, next)\n\n#define MAP_LIST0(f, x, peek, ...) f(x) MAP_LIST_NEXT(peek, MAP_LIST1)(f, peek, __VA_ARGS__)\n#define MAP_LIST1(f, x, peek, ...) f(x) MAP_LIST_NEXT(peek, MAP_LIST0)(f, peek, __VA_ARGS__)\n\n// Applies function-macro 'F' to all '__VA_ARGS___'\n#define MAP(f, ...) EVAL(MAP1(f, __VA_ARGS__, ()()(), ()()(), ()()(), 0))\n\n// Applies function-macro 'F' to all '__VA_ARGS___' and add separator commas\n#define MAP_LIST(f, ...) EVAL(MAP_LIST1(f, __VA_ARGS__, ()()(), ()()(), ()()(), 0))\n</code></pre> <p>Note</p> <p>The macro supports up to 364 arguments, in practice this is gonna be limited by compiler evaluation depth which usually caps out at 256.</p>"},{"location":"blog/map_macro_reflection.html#alternative-approaches-for-enum-reflection","title":"Alternative approaches for <code>enum</code> reflection","text":"<p>An alternative approach is taken by magic_enum and some other libraries, it involves compile-time parsing of strings returned by compiler intrinsics <code>__PRETTY_FUNCTION__</code>, <code>__FUNCSIG__</code> and C++20 std::source_location. As a result it is possible to extract enum names without requiring a registration macro, which is quite convenient. This, however, comes at a price of relying on implementation-dependent behavior and introduces some limitations on reflected enums. Compile times also tend suffer through there are some ways to reduce that impact. This approach has its footguns, but is completely viable as showcased by a multitude of libraries implementing it properly.</p>"},{"location":"blog/map_macro_reflection.html#alternative-approaches-for-struct-reflection","title":"Alternative approaches for <code>struct</code> reflection","text":"<p>Some other libraries implement reflection using template metadata fields, inheritance and manual declaration of template specializations. Such approach has a benefit of relying more on the language semantics rather than a preprocessor, however it often comes with additional boilerplate and introduces intrusive semantics, making it difficult to use with types provided by 3rd party libraries and other modules.</p>"},{"location":"blog/map_macro_reflection.html#related-libraries","title":"Related libraries","text":"Library Description Reflection method magic_enum C++17 feature-rich enum reflection \"Pretty function\" parsing static_enum C++17 minimalistic enum reflection \"Pretty function\" parsing utl::enum_reflect C++17 minimalistic enum reflection Map-macro visit_struct C++11 minimalistic structure reflection Map-macro selfaware C++11 minimalistic structure reflection Macros &amp; template meta utl::struct_reflect C++17 minimalistic structure reflection Map-macro Glaze C++23 serialization library that also includes reflection \"Pretty function\" parsing reflectcpp C++20 serialization library that also includes reflection \"Pretty function\" parsing Boost.Hana C++14 metaprogramming library that also includes reflection Macros &amp; template meta Boost.Describe C++14 reflection library providing very similar API to the one described here Map-macro Boost.PFR C++14 structure reflection library that doesn't require registration macros Custom Library Description map-macro A clean implementation of the map-macro that inspired this post in the first place <p>Publication date: 2025.02.23</p> <p>Last revision: 2025.09.03</p>"}]}