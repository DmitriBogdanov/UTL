
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://dmitribogdanov.github.io/UTL/module_mvl.html">
      
      
        <link rel="prev" href="module_math.html">
      
      
        <link rel="next" href="module_parallel.html">
      
      
      <link rel="icon" href="images/icon_site_logo.ico">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.22">
    
    
      
        <title>utl::mvl - UTL</title>
      
    
    
      <link rel="stylesheet" href="assets/stylesheets/main.84d31ad4.min.css">
      
        
        <link rel="stylesheet" href="assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
        <script src="https://unpkg.com/iframe-worker/shim"></script>
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="mkdocs/callouts.css">
    
      <link rel="stylesheet" href="mkdocs/width.css">
    
    <script>__md_scope=new URL(".",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
      
        <meta  property="og:type"  content="website" >
      
        <meta  property="og:title"  content="utl::mvl - UTL" >
      
        <meta  property="og:description"  content="None" >
      
        <meta  property="og:image"  content="https://dmitribogdanov.github.io/UTL/assets/images/social/module_mvl.png" >
      
        <meta  property="og:image:type"  content="image/png" >
      
        <meta  property="og:image:width"  content="1200" >
      
        <meta  property="og:image:height"  content="630" >
      
        <meta  property="og:url"  content="https://dmitribogdanov.github.io/UTL/module_mvl.html" >
      
        <meta  name="twitter:card"  content="summary_large_image" >
      
        <meta  name="twitter:title"  content="utl::mvl - UTL" >
      
        <meta  name="twitter:description"  content="None" >
      
        <meta  name="twitter:image"  content="https://dmitribogdanov.github.io/UTL/assets/images/social/module_mvl.png" >
      
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="slate" data-md-color-primary="black" data-md-color-accent="light-blue">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#utlmvl-experimental" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="index.html" title="UTL" class="md-header__button md-logo" aria-label="UTL" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m21.71 20.29-1.42 1.42a1 1 0 0 1-1.41 0L7 9.85A3.8 3.8 0 0 1 6 10a4 4 0 0 1-3.78-5.3l2.54 2.54.53-.53 1.42-1.42.53-.53L4.7 2.22A4 4 0 0 1 10 6a3.8 3.8 0 0 1-.15 1l11.86 11.88a1 1 0 0 1 0 1.41M2.29 18.88a1 1 0 0 0 0 1.41l1.42 1.42a1 1 0 0 0 1.41 0l5.47-5.46-2.83-2.83M20 2l-4 2v2l-2.17 2.17 2 2L18 8h2l2-4Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            UTL
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              utl::mvl
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="black" data-md-color-accent="light-blue"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5M7 15a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="deep-purple" data-md-color-accent="purple"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5m0 8a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
      <div class="md-header__source">
        <a href="https://github.com/DmitriBogdanov/UTL" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    DmitriBogdanov/UTL
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="index.html" title="UTL" class="md-nav__button md-logo" aria-label="UTL" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m21.71 20.29-1.42 1.42a1 1 0 0 1-1.41 0L7 9.85A3.8 3.8 0 0 1 6 10a4 4 0 0 1-3.78-5.3l2.54 2.54.53-.53 1.42-1.42.53-.53L4.7 2.22A4 4 0 0 1 10 6a3.8 3.8 0 0 1-.15 1l11.86 11.88a1 1 0 0 1 0 1.41M2.29 18.88a1 1 0 0 0 0 1.41l1.42 1.42a1 1 0 0 0 1.41 0l5.47-5.46-2.83-2.83M20 2l-4 2v2l-2.17 2.17 2 2L18 8h2l2-4Z"/></svg>

    </a>
    UTL
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/DmitriBogdanov/UTL" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    DmitriBogdanov/UTL
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="index.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Home
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" checked>
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Modules
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Modules
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="module_assertion.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utl::assertion
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="module_bit.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utl::bit
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="module_enum_reflect.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utl::enum_reflect
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="module_integral.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utl::integral
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="module_json.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utl::json
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="module_log.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utl::log
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="module_math.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utl::math
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    utl::mvl
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="module_mvl.html" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    utl::mvl
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#class-structure" class="md-nav__link">
    <span class="md-ellipsis">
      Class structure
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#performance-linear-algebra-operations" class="md-nav__link">
    <span class="md-ellipsis">
      Performance &amp; linear algebra operations
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#definitions" class="md-nav__link">
    <span class="md-ellipsis">
      Definitions
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#methods" class="md-nav__link">
    <span class="md-ellipsis">
      Methods
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Methods">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#parameter-reflection" class="md-nav__link">
    <span class="md-ellipsis">
      Parameter reflection
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#member-types" class="md-nav__link">
    <span class="md-ellipsis">
      Member types
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iterators" class="md-nav__link">
    <span class="md-ellipsis">
      Iterators
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#basic-getters" class="md-nav__link">
    <span class="md-ellipsis">
      Basic getters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#advanced-getters" class="md-nav__link">
    <span class="md-ellipsis">
      Advanced getters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#indexation" class="md-nav__link">
    <span class="md-ellipsis">
      Indexation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#index-conversions" class="md-nav__link">
    <span class="md-ellipsis">
      Index conversions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#reductions" class="md-nav__link">
    <span class="md-ellipsis">
      Reductions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#predicate-operations" class="md-nav__link">
    <span class="md-ellipsis">
      Predicate operations
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#const-algorithms" class="md-nav__link">
    <span class="md-ellipsis">
      Const algorithms
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mutating-algorithms" class="md-nav__link">
    <span class="md-ellipsis">
      Mutating algorithms
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#block-subviews" class="md-nav__link">
    <span class="md-ellipsis">
      Block subviews
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sparse-subviews" class="md-nav__link">
    <span class="md-ellipsis">
      Sparse subviews
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sparse-operations" class="md-nav__link">
    <span class="md-ellipsis">
      Sparse operations
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linear-algebra-operators" class="md-nav__link">
    <span class="md-ellipsis">
      Linear algebra operators
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Linear algebra operators">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#unary-operators" class="md-nav__link">
    <span class="md-ellipsis">
      Unary operators
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#binary-operators" class="md-nav__link">
    <span class="md-ellipsis">
      Binary operators
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#augmented-assignment-operators" class="md-nav__link">
    <span class="md-ellipsis">
      Augmented assignment operators
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tensor-io-formats" class="md-nav__link">
    <span class="md-ellipsis">
      Tensor IO formats
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#constructors" class="md-nav__link">
    <span class="md-ellipsis">
      Constructors
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Constructors">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#generic-constructors" class="md-nav__link">
    <span class="md-ellipsis">
      Generic constructors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#matrix-constructors" class="md-nav__link">
    <span class="md-ellipsis">
      Matrix constructors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#matrixview-constructors" class="md-nav__link">
    <span class="md-ellipsis">
      MatrixView constructors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#constmatrixview-constructors" class="md-nav__link">
    <span class="md-ellipsis">
      ConstMatrixView constructors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stridedmatrix-constructors" class="md-nav__link">
    <span class="md-ellipsis">
      StridedMatrix constructors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stridedmatrixview-constructors" class="md-nav__link">
    <span class="md-ellipsis">
      StridedMatrixView constructors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#conststridedmatrixview-constructors" class="md-nav__link">
    <span class="md-ellipsis">
      ConstStridedMatrixView constructors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sparsematrix-constructors" class="md-nav__link">
    <span class="md-ellipsis">
      SparseMatrix constructors
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#examples" class="md-nav__link">
    <span class="md-ellipsis">
      Examples
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Examples">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#declaring-and-indexing-a-matrix" class="md-nav__link">
    <span class="md-ellipsis">
      Declaring and indexing a matrix
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#io-formats" class="md-nav__link">
    <span class="md-ellipsis">
      IO formats
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#initializing-a-matrix-by-chaining-operations" class="md-nav__link">
    <span class="md-ellipsis">
      Initializing a matrix by chaining operations
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#wrapping-external-data-into-views" class="md-nav__link">
    <span class="md-ellipsis">
      Wrapping external data into views
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#usage-with-utlmath" class="md-nav__link">
    <span class="md-ellipsis">
      Usage with utl::math
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#working-with-images" class="md-nav__link">
    <span class="md-ellipsis">
      Working with images
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#working-with-sparse-matrices" class="md-nav__link">
    <span class="md-ellipsis">
      Working with sparse matrices
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#roadmap-for-v100-release" class="md-nav__link">
    <span class="md-ellipsis">
      Roadmap for v1.0.0 release
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="module_parallel.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utl::parallel
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="module_predef.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utl::predef
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="module_profiler.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utl::profiler
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="module_progressbar.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utl::progressbar
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="module_random.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utl::random
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="module_shell.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utl::shell
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="module_sleep.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utl::sleep
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="module_stre.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utl::stre
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="module_strong_type.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utl::strong_type
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="module_struct_reflect.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utl::struct_reflect
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="module_table.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utl::table
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="module_time.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utl::time
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Guides
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            Guides
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="guide_selecting_modules.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Selecting modules
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="guide_fetching_library.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Fetching the library
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="guide_reserved_names.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Reserved names
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="guide_building_project.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Building the repo
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="guide_building_docs.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Building documentation
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="guide_versioning.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Semantic versioning
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="guide_reproducing_figures.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Reproducing figures
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Blog
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            Blog
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="blog/cpp_performance_issues.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    What separates C++ from being a "perfect" performance-oriented language
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="blog/map_macro_reflection.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Map-macro: Emulating reflection
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="guide_license.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    License
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#class-structure" class="md-nav__link">
    <span class="md-ellipsis">
      Class structure
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#performance-linear-algebra-operations" class="md-nav__link">
    <span class="md-ellipsis">
      Performance &amp; linear algebra operations
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#definitions" class="md-nav__link">
    <span class="md-ellipsis">
      Definitions
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#methods" class="md-nav__link">
    <span class="md-ellipsis">
      Methods
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Methods">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#parameter-reflection" class="md-nav__link">
    <span class="md-ellipsis">
      Parameter reflection
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#member-types" class="md-nav__link">
    <span class="md-ellipsis">
      Member types
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iterators" class="md-nav__link">
    <span class="md-ellipsis">
      Iterators
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#basic-getters" class="md-nav__link">
    <span class="md-ellipsis">
      Basic getters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#advanced-getters" class="md-nav__link">
    <span class="md-ellipsis">
      Advanced getters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#indexation" class="md-nav__link">
    <span class="md-ellipsis">
      Indexation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#index-conversions" class="md-nav__link">
    <span class="md-ellipsis">
      Index conversions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#reductions" class="md-nav__link">
    <span class="md-ellipsis">
      Reductions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#predicate-operations" class="md-nav__link">
    <span class="md-ellipsis">
      Predicate operations
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#const-algorithms" class="md-nav__link">
    <span class="md-ellipsis">
      Const algorithms
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mutating-algorithms" class="md-nav__link">
    <span class="md-ellipsis">
      Mutating algorithms
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#block-subviews" class="md-nav__link">
    <span class="md-ellipsis">
      Block subviews
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sparse-subviews" class="md-nav__link">
    <span class="md-ellipsis">
      Sparse subviews
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sparse-operations" class="md-nav__link">
    <span class="md-ellipsis">
      Sparse operations
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linear-algebra-operators" class="md-nav__link">
    <span class="md-ellipsis">
      Linear algebra operators
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Linear algebra operators">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#unary-operators" class="md-nav__link">
    <span class="md-ellipsis">
      Unary operators
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#binary-operators" class="md-nav__link">
    <span class="md-ellipsis">
      Binary operators
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#augmented-assignment-operators" class="md-nav__link">
    <span class="md-ellipsis">
      Augmented assignment operators
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tensor-io-formats" class="md-nav__link">
    <span class="md-ellipsis">
      Tensor IO formats
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#constructors" class="md-nav__link">
    <span class="md-ellipsis">
      Constructors
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Constructors">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#generic-constructors" class="md-nav__link">
    <span class="md-ellipsis">
      Generic constructors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#matrix-constructors" class="md-nav__link">
    <span class="md-ellipsis">
      Matrix constructors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#matrixview-constructors" class="md-nav__link">
    <span class="md-ellipsis">
      MatrixView constructors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#constmatrixview-constructors" class="md-nav__link">
    <span class="md-ellipsis">
      ConstMatrixView constructors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stridedmatrix-constructors" class="md-nav__link">
    <span class="md-ellipsis">
      StridedMatrix constructors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stridedmatrixview-constructors" class="md-nav__link">
    <span class="md-ellipsis">
      StridedMatrixView constructors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#conststridedmatrixview-constructors" class="md-nav__link">
    <span class="md-ellipsis">
      ConstStridedMatrixView constructors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sparsematrix-constructors" class="md-nav__link">
    <span class="md-ellipsis">
      SparseMatrix constructors
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#examples" class="md-nav__link">
    <span class="md-ellipsis">
      Examples
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Examples">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#declaring-and-indexing-a-matrix" class="md-nav__link">
    <span class="md-ellipsis">
      Declaring and indexing a matrix
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#io-formats" class="md-nav__link">
    <span class="md-ellipsis">
      IO formats
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#initializing-a-matrix-by-chaining-operations" class="md-nav__link">
    <span class="md-ellipsis">
      Initializing a matrix by chaining operations
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#wrapping-external-data-into-views" class="md-nav__link">
    <span class="md-ellipsis">
      Wrapping external data into views
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#usage-with-utlmath" class="md-nav__link">
    <span class="md-ellipsis">
      Usage with utl::math
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#working-with-images" class="md-nav__link">
    <span class="md-ellipsis">
      Working with images
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#working-with-sparse-matrices" class="md-nav__link">
    <span class="md-ellipsis">
      Working with sparse matrices
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#roadmap-for-v100-release" class="md-nav__link">
    <span class="md-ellipsis">
      Roadmap for v1.0.0 release
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  
  


<p><a href="https://en.cppreference.com/w/cpp/17.html"><img src ="images/badge_language_cpp_17.svg"></a>
<a href="LICENSE.md"><img src ="images/badge_license_mit.svg"></a>
<a href="guide_versioning.html"><img src ="images/badge_semver.svg"></a>
<a href="https://dmitribogdanov.github.io/UTL/"><img src ="images/badge_docs.svg"></a>
<a href="https://en.wikipedia.org/wiki/Header-only"><img src ="images/badge_header_only.svg"></a>
<a href="https://github.com/DmitriBogdanov/UTL/tree/master/include/UTL"><img src ="images/badge_no_dependencies.svg"></a></p>
<p><a href="https://github.com/DmitriBogdanov/UTL/actions/workflows/windows.yml"><img src ="images/badge_workflow_windows.svg"></a>
<a href="https://github.com/DmitriBogdanov/UTL/actions/workflows/ubuntu.yml"><img src ="images/badge_workflow_ubuntu.svg"></a>
<a href="https://github.com/DmitriBogdanov/UTL/actions/workflows/macos.yml"><img src ="images/badge_workflow_macos.svg"></a>
<a href="https://github.com/DmitriBogdanov/UTL/actions/workflows/freebsd.yml"><img src ="images/badge_workflow_freebsd.svg"></a></p>
<h1 id="utlmvl-experimental">utl::mvl <strong>(experimental)</strong><a class="headerlink" href="#utlmvl-experimental" title="Permanent link">&para;</a></h1>
<p><a href="..">&lt;- to README.md</a></p>
<p><a href="../include/UTL/mvl.hpp">&lt;- to implementation.hpp</a></p>
<p><strong>utl::mvl</strong> (aka <strong>M</strong>atrix <strong>V</strong>iew <strong>L</strong>ibrary) implements generic classes for dense/strided/sparse vectors, matrices and views.</p>
<p>Unlike most existing matrix implementations, <strong>mvl</strong> focuses on data-oriented matrices that support arbitrary element types and can be used similarly to <a href="https://en.cppreference.com/w/cpp/container/vector">std::vector</a>. It's main goal is the simplicity of API and interoperability with most existing implementations.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Due to rather extensive API, seeing <a href="#declaring-and-indexing-a-matrix">usage examples</a> first might be helpful.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This module is currently <strong>experimental</strong>. It is generally functional, however there are no guarantees about its API, stability and documentation coverage.</p>
</div>
<h2 id="class-structure">Class structure<a class="headerlink" href="#class-structure" title="Permanent link">&para;</a></h2>
<p>All vectors, matrices and views in <strong>mvl</strong> stem from a single generic template class, that can be specialized into any available behavior through its template parameters:
<div class="highlight"><pre><span></span><code><span class="c1">// Generic template</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span>
<span class="w">    </span><span class="k">class</span><span class="w">       </span><span class="nc">T</span><span class="p">,</span>
<span class="w">    </span><span class="n">Dimension</span><span class="w">   </span><span class="n">dimension</span><span class="p">,</span>
<span class="w">    </span><span class="n">Type</span><span class="w">        </span><span class="n">type</span><span class="p">,</span>
<span class="w">    </span><span class="n">Ownership</span><span class="w">   </span><span class="n">ownership</span><span class="p">,</span>
<span class="w">    </span><span class="n">Checking</span><span class="w">    </span><span class="n">checking</span><span class="p">,</span>
<span class="w">    </span><span class="n">Layout</span><span class="w">      </span><span class="n">layout</span>
<span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">GenericTensor</span><span class="p">;</span>

<span class="c1">// Example of manual specialization</span>
<span class="k">using</span><span class="w"> </span><span class="n">IntegerMatrix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GenericTensor</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">Dimension</span><span class="o">::</span><span class="n">MATRIX</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">DENSE</span><span class="p">,</span><span class="w"> </span><span class="n">Ownership</span><span class="o">::</span><span class="n">CONTAINER</span><span class="p">,</span><span class="w"> </span><span class="n">Checking</span><span class="o">::</span><span class="n">NONE</span><span class="p">,</span><span class="w"> </span><span class="n">Layout</span><span class="o">::</span><span class="n">RC</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Here <strong>tensor</strong> will be used to refer to arbitrary vectors, matrices and views, not necessarily in a <a href="https://en.wikipedia.org/wiki/Tensor">mathematical sense</a>.</p>
</div>
<p>This approach provides a generic way of working with matrices that is mostly agnostic to underlying layout and implementation. In practical usage manual specialization is rarely needed due to provided typedefs, however it is a powerful tool for implementing generic APIs.</p>
<p><strong>Below in an overview of all available arguments, typedefs and defaults:</strong></p>
<p><img src ="images/mvl_diagram.svg"></p>
<h2 id="performance-linear-algebra-operations">Performance &amp; linear algebra operations<a class="headerlink" href="#performance-linear-algebra-operations" title="Permanent link">&para;</a></h2>
<p><strong>mvl</strong> classes are intended to be lightweight wrappers that allow convenient data manipulation without any performance tradeoffs on basic operations (loops, indexing, standard algorithms, etc.), this is achieved through conditional compilation and compile-time resolution of all indexing formulas. See <a href="TODO:">benchmarks</a> for details.</p>
<p>Due to its arbitrary-data approach, linear algebra operations are intentionally <strong>NOT</strong> implemented by <strong>mvl</strong>. Numeric computation is a separate field and is much better handled by existing libraries like <a href="https://xtensor.readthedocs.io">XTensor</a>, <a href="https://eigen.tuxfamily.org">Eigen</a> and <a href="https://bitbucket.org/blaze-lib/blaze">Blaze</a>. In cases where matrix computation is needed, it's heavily recommended to use matrices provided by those libraries as a main implementation, and whenever <strong>mvl</strong> functions are needed, those can be wrapped in <strong>mvl</strong> view. For example:</p>
<div class="highlight"><pre><span></span><code><span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span><span class="w"> </span><span class="n">A</span><span class="p">;</span><span class="w"> </span><span class="c1">// in Eigen col-major by default</span>

<span class="c1">// Do some computation with &#39;A&#39;</span>

<span class="n">mvl</span><span class="o">::</span><span class="n">MatrixView</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="n">Checking</span><span class="o">::</span><span class="n">NONE</span><span class="p">,</span><span class="w"> </span><span class="n">Layout</span><span class="o">::</span><span class="n">CR</span><span class="o">&gt;</span><span class="w"> </span><span class="n">view</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">rows</span><span class="p">(),</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">cols</span><span class="p">(),</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>

<span class="c1">// Use &#39;view&#39; like any other MVL matrix</span>
</code></pre></div>
<h2 id="definitions">Definitions<a class="headerlink" href="#definitions" title="Permanent link">&para;</a></h2>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p><code>requires</code> tag specifies methods that get conditionally compiled by some specializations.</p>
</div>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p><code>Callable&lt;Args...&gt;</code> is a shortcut for a template parameter, restricted to callable objects with specific signature.</p>
</div>
<div class="highlight"><pre><span></span><code><span class="c1">// Generic template</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span>
<span class="w">    </span><span class="k">class</span><span class="w">       </span><span class="nc">T</span><span class="p">,</span>
<span class="w">    </span><span class="n">Dimension</span><span class="w">   </span><span class="n">dimension</span><span class="p">,</span>
<span class="w">    </span><span class="n">Type</span><span class="w">        </span><span class="n">type</span><span class="p">,</span>
<span class="w">    </span><span class="n">Ownership</span><span class="w">   </span><span class="n">ownership</span><span class="p">,</span>
<span class="w">    </span><span class="n">Checking</span><span class="w">    </span><span class="n">checking</span><span class="p">,</span>
<span class="w">    </span><span class="n">Layout</span><span class="w">      </span><span class="n">layout</span>
<span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">GenericTensor</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// - Parameter reflection -</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">params</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">constexpr</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">Dimension</span><span class="w">   </span><span class="n">dimension</span>
<span class="w">        </span><span class="k">constexpr</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">Type</span><span class="w">        </span><span class="n">type</span><span class="p">;</span>
<span class="w">        </span><span class="k">constexpr</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">Ownership</span><span class="w">   </span><span class="n">ownership</span><span class="p">;</span>
<span class="w">        </span><span class="k">constexpr</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">Checking</span><span class="w">    </span><span class="n">checking</span><span class="p">;</span>
<span class="w">        </span><span class="k">constexpr</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">Layout</span><span class="w">      </span><span class="n">layout</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="c1">// - Member types -</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">self</span><span class="w">            </span><span class="o">=</span><span class="w"> </span><span class="n">GenericTensor</span><span class="p">;</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">value_type</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">;</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">size_type</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">;</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">difference_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">ptrdiff_t</span><span class="p">;</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">reference</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="p">;</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">const_reference</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="p">;</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">pointer</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="p">;</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">const_pointer</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="p">;</span>

<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">owning_reflection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GenericTensor</span><span class="o">&lt;</span><span class="n">value_type</span><span class="p">,</span><span class="w"> </span><span class="n">params</span><span class="o">::</span><span class="n">dimension</span><span class="p">,</span><span class="w"> </span><span class="n">params</span><span class="o">::</span><span class="n">type</span><span class="p">,</span>
<span class="w">                                            </span><span class="n">Ownership</span><span class="o">::</span><span class="n">CONTAINER</span><span class="p">,</span><span class="w"> </span><span class="n">params</span><span class="o">::</span><span class="n">checking</span><span class="p">,</span><span class="w"> </span><span class="n">params</span><span class="o">::</span><span class="n">layout</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// - Iterators -</span>
<span class="w">    </span><span class="k">using</span><span class="w">               </span><span class="n">iterator</span><span class="p">;</span>
<span class="w">    </span><span class="k">using</span><span class="w">       </span><span class="n">reverse_iterator</span><span class="p">;</span>
<span class="w">    </span><span class="k">using</span><span class="w">         </span><span class="n">const_iterator</span><span class="p">;</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">const_reverse_iterator</span><span class="p">;</span>

<span class="w">    </span><span class="n">iterator</span><span class="w"> </span><span class="nf">begin</span><span class="p">();</span>
<span class="w">    </span><span class="n">iterator</span><span class="w">   </span><span class="nf">end</span><span class="p">();</span>

<span class="w">    </span><span class="n">reverse_iterator</span><span class="w"> </span><span class="nf">rbegin</span><span class="p">();</span>
<span class="w">    </span><span class="n">reverse_iterator</span><span class="w">   </span><span class="nf">rend</span><span class="p">();</span>

<span class="w">    </span><span class="n">const_iterator</span><span class="w">  </span><span class="nf">begin</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="n">const_iterator</span><span class="w">    </span><span class="nf">end</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="n">const_iterator</span><span class="w"> </span><span class="nf">cbegin</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="n">const_iterator</span><span class="w">   </span><span class="nf">cend</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="n">const_reverse_iterator</span><span class="w">  </span><span class="nf">rbegin</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="n">const_reverse_iterator</span><span class="w">    </span><span class="nf">rend</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="n">const_reverse_iterator</span><span class="w"> </span><span class="nf">crbegin</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="n">const_reverse_iterator</span><span class="w">   </span><span class="nf">crend</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w">   </span>

<span class="w">    </span><span class="c1">// - Basic getters -</span>
<span class="w">    </span><span class="n">size_type</span><span class="w">       </span><span class="nf">size</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="n">size_type</span><span class="w">       </span><span class="nf">rows</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires MATRIX</span>
<span class="w">    </span><span class="n">size_type</span><span class="w">       </span><span class="nf">cols</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires MATRIX</span>
<span class="w">    </span><span class="n">size_type</span><span class="w"> </span><span class="nf">row_stride</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires MATRIX &amp;&amp; (DENSE || STRIDED)</span>
<span class="w">    </span><span class="n">size_type</span><span class="w"> </span><span class="nf">col_stride</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires MATRIX &amp;&amp; (DENSE || STRIDED)</span>

<span class="w">    </span><span class="n">const_pointer</span><span class="w">  </span><span class="nf">data</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires DENSE || STRIDED</span>
<span class="w">    </span><span class="n">pointer</span><span class="w">        </span><span class="nf">data</span><span class="p">();</span><span class="w">       </span><span class="c1">// requires DENSE || STRIDED</span>
<span class="w">    </span><span class="kt">bool</span><span class="w">          </span><span class="nf">empty</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// - Advanced getters -</span>
<span class="w">    </span><span class="kt">bool</span><span class="w">      </span><span class="nf">contains</span><span class="p">(</span><span class="n">const_reference</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires value_type::operator==()</span>
<span class="w">    </span><span class="n">size_type</span><span class="w">    </span><span class="nf">count</span><span class="p">(</span><span class="n">const_reference</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires value_type::operator==()</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_sorted</span><span class="p">()</span><span class="w">                                                     </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires value_type::operator&lt;()</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_sorted</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">const_reference</span><span class="p">,</span><span class="w"> </span><span class="n">const_reference</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cmp</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span><span class="w"> </span><span class="n">to_std_vector</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="n">self</span><span class="w"> </span><span class="nf">transposed</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires MATRIX &amp;&amp; DENSE</span>

<span class="w">    </span><span class="n">self</span><span class="w"> </span><span class="nf">clone</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires CONTAINER</span>
<span class="w">    </span><span class="n">self</span><span class="w"> </span><span class="nf">move</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires CONTAINER</span>

<span class="w">    </span><span class="c1">// - Indexation -</span>
<span class="w">    </span><span class="n">const_reference</span><span class="w"> </span><span class="nf">front</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="n">const_reference</span><span class="w">  </span><span class="nf">back</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="n">reference</span><span class="w">       </span><span class="nf">front</span><span class="p">();</span>
<span class="w">    </span><span class="n">reference</span><span class="w">        </span><span class="nf">back</span><span class="p">();</span>

<span class="w">    </span><span class="n">reference</span><span class="w">       </span><span class="k">operator</span><span class="p">[](</span><span class="n">size_type</span><span class="w"> </span><span class="n">idx</span><span class="p">);</span>
<span class="w">    </span><span class="n">reference</span><span class="w">       </span><span class="nf">operator</span><span class="p">()(</span><span class="n">size_type</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w">                    </span><span class="c1">// [TODO:] requires VECTOR</span>
<span class="w">    </span><span class="n">reference</span><span class="w">       </span><span class="nf">operator</span><span class="p">()(</span><span class="n">size_type</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">j</span><span class="p">);</span><span class="w">       </span><span class="c1">// requires MATRIX</span>
<span class="w">    </span><span class="n">const_reference</span><span class="w"> </span><span class="k">operator</span><span class="p">[](</span><span class="n">size_type</span><span class="w"> </span><span class="n">idx</span><span class="p">)</span><span class="w">            </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="n">const_reference</span><span class="w"> </span><span class="nf">operator</span><span class="p">()(</span><span class="n">size_type</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w">              </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// [TODO:] requires VECTOR</span>
<span class="w">    </span><span class="n">const_reference</span><span class="w"> </span><span class="nf">operator</span><span class="p">()(</span><span class="n">size_type</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires MATRIX</span>

<span class="w">    </span><span class="c1">// - Index conversions -</span>
<span class="w">    </span><span class="n">size_type</span><span class="w"> </span><span class="nf">get_idx_of_ij</span><span class="p">(</span><span class="n">size_type</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires MATRIX</span>
<span class="w">    </span><span class="n">Index2D</span><span class="w">   </span><span class="nf">get_ij_of_idx</span><span class="p">(</span><span class="n">size_type</span><span class="w"> </span><span class="n">idx</span><span class="p">)</span><span class="w">            </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires MATRIX</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">contains_index</span><span class="p">(</span><span class="n">size_type</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires MATRIX &amp;&amp; SPARSE</span>

<span class="w">    </span><span class="n">size_type</span><span class="w"> </span><span class="nf">extent_major</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires MATRIX &amp;&amp; (DENSE || STRIDED)</span>
<span class="w">    </span><span class="n">size_type</span><span class="w"> </span><span class="nf">extent_minor</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires MATRIX &amp;&amp; (DENSE || STRIDED)</span>

<span class="w">    </span><span class="c1">// - Reductions -</span>
<span class="w">    </span><span class="n">value_type</span><span class="w">     </span><span class="nf">sum</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires value_type::operator+()</span>
<span class="w">    </span><span class="n">value_type</span><span class="w"> </span><span class="nf">product</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires value_type::operator*()</span>
<span class="w">    </span><span class="n">value_type</span><span class="w">     </span><span class="nf">min</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires value_type::operator&lt;()</span>
<span class="w">    </span><span class="n">value_type</span><span class="w">     </span><span class="nf">max</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires value_type::operator&lt;()</span>

<span class="w">    </span><span class="c1">// - Predicate operations -</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">true_for_any</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">const_reference</span><span class="p">)</span><span class="o">&gt;</span><span class="w">                       </span><span class="n">predicate</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">true_for_any</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">const_reference</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">)</span><span class="o">&gt;</span><span class="w">            </span><span class="n">predicate</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// [TODO:] requires VECTOR</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">true_for_any</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">const_reference</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">predicate</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires MATRIX</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">true_for_all</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">const_reference</span><span class="p">)</span><span class="o">&gt;</span><span class="w">                       </span><span class="n">predicate</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">true_for_all</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">const_reference</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">)</span><span class="o">&gt;</span><span class="w">            </span><span class="n">predicate</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// [TODO:] requires VECTOR</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">true_for_all</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">const_reference</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">predicate</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires MATRIX</span>

<span class="w">    </span><span class="c1">// - Const algorithms -</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">for_each</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">const_reference</span><span class="p">)</span><span class="o">&gt;</span><span class="w">                       </span><span class="n">func</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">for_each</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">const_reference</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">)</span><span class="o">&gt;</span><span class="w">            </span><span class="n">func</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// [TODO:] requires VECTOR</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">for_each</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">const_reference</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">func</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires MATRIX</span>

<span class="w">    </span><span class="c1">// - Mutating algorithms -</span>
<span class="w">    </span><span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">for_each</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">reference</span><span class="p">)</span><span class="o">&gt;</span><span class="w">                       </span><span class="n">func</span><span class="p">);</span>
<span class="w">    </span><span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">for_each</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">)</span><span class="o">&gt;</span><span class="w">            </span><span class="n">func</span><span class="p">);</span><span class="w"> </span><span class="c1">// [TODO:] requires VECTOR</span>
<span class="w">    </span><span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">for_each</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">func</span><span class="p">);</span><span class="w"> </span><span class="c1">// requires MATRIX</span>

<span class="w">    </span><span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">transform</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="n">value_type</span><span class="p">(</span><span class="n">const_reference</span><span class="p">)</span><span class="o">&gt;</span><span class="w">                       </span><span class="n">func</span><span class="p">);</span>
<span class="w">    </span><span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">transform</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="n">value_type</span><span class="p">(</span><span class="n">const_reference</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">)</span><span class="o">&gt;</span><span class="w">            </span><span class="n">func</span><span class="p">);</span><span class="w"> </span><span class="c1">// [TODO:] requires VECTOR</span>
<span class="w">    </span><span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">transform</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="n">value_type</span><span class="p">(</span><span class="n">const_reference</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">func</span><span class="p">);</span><span class="w"> </span><span class="c1">// requires MATRIX</span>

<span class="w">    </span><span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">fill</span><span class="p">(</span><span class="n">const_reference</span><span class="w"> </span><span class="n">value</span><span class="p">);</span>

<span class="w">    </span><span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">fill</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="n">value_type</span><span class="p">()</span><span class="o">&gt;</span><span class="w">                       </span><span class="n">func</span><span class="p">);</span>
<span class="w">    </span><span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">fill</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="n">value_type</span><span class="p">(),</span><span class="w"> </span><span class="n">size_type</span><span class="o">&gt;</span><span class="w">            </span><span class="n">func</span><span class="p">);</span><span class="w"> </span><span class="c1">// [TODO:] requires VECTOR</span>
<span class="w">    </span><span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">fill</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="n">value_type</span><span class="p">(),</span><span class="w"> </span><span class="n">size_type</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="o">&gt;</span><span class="w"> </span><span class="n">func</span><span class="p">);</span><span class="w"> </span><span class="c1">// requires MATRIX</span>

<span class="w">    </span><span class="n">self</span><span class="o">&amp;</span><span class="w">        </span><span class="nf">sort</span><span class="p">();</span><span class="w"> </span><span class="c1">// requires value_type::operator&lt;()</span>
<span class="w">    </span><span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">stable_sort</span><span class="p">();</span><span class="w"> </span><span class="c1">// requires value_type::operator&lt;()</span>
<span class="w">    </span><span class="n">self</span><span class="o">&amp;</span><span class="w">        </span><span class="nf">sort</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">const_reference</span><span class="p">,</span><span class="w"> </span><span class="n">const_reference</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cmp</span><span class="p">);</span>
<span class="w">    </span><span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">stable_sort</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">const_reference</span><span class="p">,</span><span class="w"> </span><span class="n">const_reference</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cmp</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// - Block Subviews -</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">block_view_type</span><span class="p">;</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">block_const_view_type</span><span class="p">;</span>

<span class="w">    </span><span class="n">block_view_type</span><span class="w">       </span><span class="nf">block</span><span class="p">(</span><span class="n">size_type</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">cols</span><span class="p">);</span><span class="w">       </span><span class="c1">// requires MATRIX</span>
<span class="w">    </span><span class="n">block_const_view_type</span><span class="w"> </span><span class="nf">block</span><span class="p">(</span><span class="n">size_type</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires MATRIX</span>

<span class="w">    </span><span class="n">block_view_type</span><span class="w">       </span><span class="nf">row</span><span class="p">();</span><span class="w">       </span><span class="c1">// requires MATRIX</span>
<span class="w">    </span><span class="n">block_const_view_type</span><span class="w"> </span><span class="nf">row</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires MATRIX</span>

<span class="w">    </span><span class="n">block_view_type</span><span class="w">       </span><span class="nf">col</span><span class="p">();</span><span class="w">       </span><span class="c1">// requires MATRIX</span>
<span class="w">    </span><span class="n">block_const_view_type</span><span class="w"> </span><span class="nf">col</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires MATRIX</span>

<span class="w">    </span><span class="c1">// - Sparse Subviews -</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">sparse_view_type</span><span class="p">;</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">sparse_const_view_type</span><span class="p">;</span>

<span class="w">    </span><span class="n">sparse_view_type</span><span class="w"> </span><span class="nf">filter</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">const_reference</span><span class="p">)</span><span class="o">&gt;</span><span class="w">                       </span><span class="n">predicate</span><span class="p">);</span>
<span class="w">    </span><span class="n">sparse_view_type</span><span class="w"> </span><span class="nf">filter</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">const_reference</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">)</span><span class="o">&gt;</span><span class="w">            </span><span class="n">predicate</span><span class="p">);</span><span class="w"> </span><span class="c1">// [TODO:] requires VECTOR</span>
<span class="w">    </span><span class="n">sparse_view_type</span><span class="w"> </span><span class="nf">filter</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">const_reference</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">predicate</span><span class="p">);</span><span class="w"> </span><span class="c1">// requires MATRIX</span>

<span class="w">    </span><span class="n">sparse_const_view_type</span><span class="w"> </span><span class="nf">filter</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">const_reference</span><span class="p">)</span><span class="o">&gt;</span><span class="w">                       </span><span class="n">predicate</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="n">sparse_const_view_type</span><span class="w"> </span><span class="nf">filter</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">const_reference</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">)</span><span class="o">&gt;</span><span class="w">            </span><span class="n">predicate</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// [TODO:] requires VECTOR</span>
<span class="w">    </span><span class="n">sparse_const_view_type</span><span class="w"> </span><span class="nf">filter</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">const_reference</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">predicate</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires MATRIX</span>

<span class="w">    </span><span class="n">sparse_view_type</span><span class="w">       </span><span class="nf">diagonal</span><span class="p">();</span><span class="w">       </span><span class="c1">// requires MATRIX</span>
<span class="w">    </span><span class="n">sparse_const_view_type</span><span class="w"> </span><span class="nf">diagonal</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires MATRIX</span>

<span class="w">    </span><span class="c1">// - Sparse operations - (requires SPARSE)</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">sparse_entry_type</span><span class="p">;</span>

<span class="w">    </span><span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">rewrite_triplets</span><span class="p">(</span><span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">triplet_type</span><span class="o">&gt;&amp;&amp;</span><span class="w"> </span><span class="n">triplets</span><span class="p">);</span><span class="w"> </span><span class="c1">// requires MATRIX</span>
<span class="w">    </span><span class="n">self</span><span class="o">&amp;</span><span class="w">  </span><span class="nf">insert_triplets</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">triplet_type</span><span class="o">&gt;&amp;</span><span class="w">  </span><span class="n">triplets</span><span class="p">);</span><span class="w"> </span><span class="c1">// requires MATRIX</span>
<span class="w">    </span><span class="n">self</span><span class="o">&amp;</span><span class="w">   </span><span class="nf">erase_triplets</span><span class="p">(</span><span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Index2D</span><span class="w">     </span><span class="o">&gt;</span><span class="w">   </span><span class="n">indices</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">// requires MATRIX</span>

<span class="w">    </span><span class="c1">// - Constructors -</span>
<span class="w">    </span><span class="c1">// Note: Lots of entries in this section, </span>
<span class="w">    </span><span class="c1">// following full documentation looks more digestible</span>

<span class="w">    </span><span class="c1">// Default</span>
<span class="w">    </span><span class="n">GenericTensor</span><span class="p">();</span><span class="w"> </span><span class="c1">// requires CONTAINER</span>

<span class="w">    </span><span class="c1">// Copy/move</span>
<span class="w">    </span><span class="n">GenericTensor</span><span class="p">(</span><span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">self</span><span class="o">&amp;</span><span class="w">  </span><span class="n">other</span><span class="p">);</span>
<span class="w">    </span><span class="n">GenericTensor</span><span class="p">(</span><span class="w">        </span><span class="n">self</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>
<span class="w">    </span><span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">self</span><span class="o">&amp;</span><span class="w">  </span><span class="n">other</span><span class="p">);</span>
<span class="w">    </span><span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="w">      </span><span class="n">self</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Copy over template parameter boundaries</span>
<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">Type</span><span class="w"> </span><span class="n">other_type</span><span class="p">,</span><span class="w"> </span><span class="n">Ownership</span><span class="w"> </span><span class="n">other_ownership</span><span class="p">,</span><span class="w"> </span><span class="n">Checking</span><span class="w"> </span><span class="n">other_checking</span><span class="p">,</span><span class="w"> </span><span class="n">Layout</span><span class="w"> </span><span class="n">other_layout</span><span class="o">&gt;</span>
<span class="w">    </span><span class="n">GenericTensor</span><span class="p">(</span><span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">GenericTensor</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;&amp;</span><span class="w">  </span><span class="n">other</span><span class="p">);</span>
<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">Type</span><span class="w"> </span><span class="n">other_type</span><span class="p">,</span><span class="w"> </span><span class="n">Ownership</span><span class="w"> </span><span class="n">other_ownership</span><span class="p">,</span><span class="w"> </span><span class="n">Checking</span><span class="w"> </span><span class="n">other_checking</span><span class="p">,</span><span class="w"> </span><span class="n">Layout</span><span class="w"> </span><span class="n">other_layout</span><span class="o">&gt;</span>
<span class="w">    </span><span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">GenericTensor</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;&amp;</span><span class="w">  </span><span class="n">other</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Move over template parameter boundaries</span>
<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">Checking</span><span class="w"> </span><span class="n">other_checking</span><span class="o">&gt;</span>
<span class="w">    </span><span class="n">GenericTensor</span><span class="p">(</span><span class="w">  </span><span class="n">GenericTensor</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;&amp;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>
<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">Checking</span><span class="w"> </span><span class="n">other_checking</span><span class="o">&gt;</span>
<span class="w">    </span><span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">GenericTensor</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;&amp;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// &#39;Matrix&#39; ctors (requires MATRIX &amp;&amp; DENSE &amp;&amp; CONTAINER)</span>
<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">GenericTensor</span><span class="p">(</span><span class="n">size_type</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"> </span><span class="n">const_reference</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value_type</span><span class="p">());</span>
<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">GenericTensor</span><span class="p">(</span><span class="n">size_type</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"> </span><span class="n">Callable</span><span class="o">&lt;</span><span class="n">value_type</span><span class="p">(</span><span class="n">size_type</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">init_func</span><span class="p">);</span>
<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">GenericTensor</span><span class="p">(</span><span class="n">size_type</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="n">data_ptr</span><span class="p">);</span>
<span class="w">    </span><span class="n">GenericTensor</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">init_list</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// &#39;MatrixView&#39; ctors (requires MATRIX &amp;&amp; DENSE &amp;&amp; VIEW)</span>
<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">GenericTensor</span><span class="p">(</span><span class="n">size_type</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="n">data_ptr</span><span class="p">);</span>
<span class="w">    </span><span class="k">template</span><span class="o">&lt;</span><span class="n">Ownership</span><span class="w"> </span><span class="n">other_ownership</span><span class="p">,</span><span class="w"> </span><span class="n">Checking</span><span class="w"> </span><span class="n">other_checking</span><span class="p">,</span><span class="w"> </span><span class="n">Layout</span><span class="w"> </span><span class="n">other_layout</span><span class="o">&gt;</span>
<span class="w">    </span><span class="n">GenericTensor</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">GenericTensor</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// &#39;ConstMatrixView&#39; ctors (requires MATRIX &amp;&amp; DENSE &amp;&amp; CONST_VIEW)</span>
<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">GenericTensor</span><span class="p">(</span><span class="n">size_type</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"> </span><span class="n">const_pointer</span><span class="w"> </span><span class="n">data_ptr</span><span class="p">);</span>
<span class="w">    </span><span class="k">template</span><span class="o">&lt;</span><span class="n">Ownership</span><span class="w"> </span><span class="n">other_ownership</span><span class="p">,</span><span class="w"> </span><span class="n">Checking</span><span class="w"> </span><span class="n">other_checking</span><span class="p">,</span><span class="w"> </span><span class="n">Layout</span><span class="w"> </span><span class="n">other_layout</span><span class="o">&gt;</span>
<span class="w">    </span><span class="n">GenericTensor</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">GenericTensor</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// &#39;StridedMatrix&#39; ctors (requires MATRIX &amp;&amp; DENSE &amp;&amp; CONTAINER)</span>
<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">GenericTensor</span><span class="p">(</span><span class="n">size_type</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">row_stride</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">col_stride</span><span class="p">,</span><span class="n">const_reference</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value_type</span><span class="p">());</span>
<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">GenericTensor</span><span class="p">(</span><span class="n">size_type</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">row_stride</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">col_stride</span><span class="p">,</span><span class="w"> </span><span class="n">Callable</span><span class="o">&lt;</span><span class="n">value_type</span><span class="p">(</span><span class="n">size_type</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">init_func</span><span class="p">);</span>
<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">GenericTensor</span><span class="p">(</span><span class="n">size_type</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">row_stride</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">col_stride</span><span class="p">,</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="n">data_ptr</span><span class="p">);</span>
<span class="w">    </span><span class="n">GenericTensor</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">init_list</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">row_stride</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">col_stride</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// &#39;StridedMatrixView&#39; ctors (requires MATRIX &amp;&amp; DENSE &amp;&amp; VIEW)</span>
<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">GenericTensor</span><span class="p">(</span><span class="n">size_type</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">row_stride</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">col_stride</span><span class="p">,</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="n">data_ptr</span><span class="p">);</span>
<span class="w">    </span><span class="k">template</span><span class="o">&lt;</span><span class="n">Ownership</span><span class="w"> </span><span class="n">other_ownership</span><span class="p">,</span><span class="w"> </span><span class="n">Checking</span><span class="w"> </span><span class="n">other_checking</span><span class="p">,</span><span class="w"> </span><span class="n">Layout</span><span class="w"> </span><span class="n">other_layout</span><span class="o">&gt;</span>
<span class="w">    </span><span class="n">GenericTensor</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">GenericTensor</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// &#39;ConstStridedMatrixView&#39; ctors (requires MATRIX &amp;&amp; DENSE &amp;&amp; CONST_VIEW)</span>
<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">GenericTensor</span><span class="p">(</span><span class="n">size_type</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">row_stride</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">col_stride</span><span class="p">,</span><span class="w"> </span><span class="n">const_pointer</span><span class="w"> </span><span class="n">data_ptr</span><span class="p">);</span>
<span class="w">    </span><span class="k">template</span><span class="o">&lt;</span><span class="n">Ownership</span><span class="w"> </span><span class="n">other_ownership</span><span class="p">,</span><span class="w"> </span><span class="n">Checking</span><span class="w"> </span><span class="n">other_checking</span><span class="p">,</span><span class="w"> </span><span class="n">Layout</span><span class="w"> </span><span class="n">other_layout</span><span class="o">&gt;</span>
<span class="w">    </span><span class="n">GenericTensor</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">GenericTensor</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Sparse ctors (requires MATRIX &amp;&amp; DENSE)</span>
<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">GenericTensor</span><span class="p">(</span><span class="n">size_type</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">triplet_type</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">data</span><span class="p">);</span>
<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">GenericTensor</span><span class="p">(</span><span class="n">size_type</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">triplet_type</span><span class="o">&gt;&amp;&amp;</span><span class="w"> </span><span class="n">data</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">// - Tensor IO formats -</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">format</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Human-readable formats</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">as_vector</span><span class="p">(</span><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">GenericTensor</span><span class="o">&lt;</span><span class="n">Args</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tensor</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">as_matrix</span><span class="p">(</span><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">GenericTensor</span><span class="o">&lt;</span><span class="n">Args</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tensor</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">as_dictionary</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">GenericTensor</span><span class="o">&lt;</span><span class="n">Args</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tensor</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Export formats</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">as_raw_text</span><span class="p">(</span><span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">GenericTensor</span><span class="o">&lt;</span><span class="n">Args</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tensor</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">as_json_array</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">GenericTensor</span><span class="o">&lt;</span><span class="n">Args</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tensor</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// - Linear algebra operators -</span>
<span class="c1">// Note:: In all operators below &#39;owning_reflection&#39; is a shortcut for &#39;typename std::decay&lt;L&gt;::owning_reflection&#39;</span>

<span class="c1">// Unary operators</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">L</span><span class="o">&gt;</span><span class="w"> </span><span class="n">owning_reflection</span><span class="w"> </span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">L</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">left</span><span class="p">);</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">L</span><span class="o">&gt;</span><span class="w"> </span><span class="n">owning_reflection</span><span class="w"> </span><span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="n">L</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">left</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">L</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Op</span><span class="o">&gt;</span><span class="w"> </span><span class="n">owning_reflection</span><span class="w"> </span><span class="n">apply_unary_op</span><span class="p">(</span><span class="n">L</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">Op</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">op</span><span class="p">);</span>

<span class="c1">// Binary operators</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">L</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">R</span><span class="o">&gt;</span><span class="w"> </span><span class="n">owning_reflection</span><span class="w">           </span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">L</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">right</span><span class="p">);</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">L</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">R</span><span class="o">&gt;</span><span class="w"> </span><span class="n">owning_reflection</span><span class="w">           </span><span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="n">L</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">right</span><span class="p">);</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">L</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">R</span><span class="o">&gt;</span><span class="w"> </span><span class="n">owning_reflection</span><span class="w"> </span><span class="n">elementwise_product</span><span class="p">(</span><span class="n">L</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">right</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">L</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">R</span><span class="o">&gt;</span><span class="w"> </span><span class="n">owning_reflection</span><span class="w"> </span><span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">L</span><span class="o">&amp;</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">R</span><span class="o">&amp;</span><span class="w"> </span><span class="n">right</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">L</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">R</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Op</span><span class="o">&gt;</span><span class="w"> </span><span class="n">owning_reflection</span><span class="w"> </span><span class="n">apply_binary_op</span><span class="p">(</span><span class="n">L</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="n">Op</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">op</span><span class="p">);</span>

<span class="c1">// Augmented assignment operators</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">L</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">R</span><span class="o">&gt;</span><span class="w"> </span><span class="n">L</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">L</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">right</span><span class="p">);</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">L</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">R</span><span class="o">&gt;</span><span class="w"> </span><span class="n">L</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">-=</span><span class="p">(</span><span class="n">L</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">right</span><span class="p">);</span>

<span class="c1">// - Typedefs -</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">Checking</span><span class="w"> </span><span class="n">checking</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Checking</span><span class="o">::</span><span class="n">NONE</span><span class="p">,</span><span class="w"> </span><span class="n">Layout</span><span class="w"> </span><span class="n">layout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Layout</span><span class="o">::</span><span class="n">RC</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">Matrix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GenericTensor</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Dimension</span><span class="o">::</span><span class="n">MATRIX</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">DENSE</span><span class="p">,</span><span class="w"> </span><span class="n">Ownership</span><span class="o">::</span><span class="n">CONTAINER</span><span class="p">,</span><span class="w"> </span><span class="n">checking</span><span class="p">,</span><span class="w"> </span><span class="n">layout</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">Checking</span><span class="w"> </span><span class="n">checking</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Checking</span><span class="o">::</span><span class="n">NONE</span><span class="p">,</span><span class="w"> </span><span class="n">Layout</span><span class="w"> </span><span class="n">layout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Layout</span><span class="o">::</span><span class="n">RC</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">MatrixView</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GenericTensor</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Dimension</span><span class="o">::</span><span class="n">MATRIX</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">DENSE</span><span class="p">,</span><span class="w"> </span><span class="n">Ownership</span><span class="o">::</span><span class="n">VIEW</span><span class="p">,</span><span class="w"> </span><span class="n">checking</span><span class="p">,</span><span class="w"> </span><span class="n">layout</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">Checking</span><span class="w"> </span><span class="n">checking</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Checking</span><span class="o">::</span><span class="n">NONE</span><span class="p">,</span><span class="w"> </span><span class="n">Layout</span><span class="w"> </span><span class="n">layout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Layout</span><span class="o">::</span><span class="n">RC</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">ConstMatrixView</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GenericTensor</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Dimension</span><span class="o">::</span><span class="n">MATRIX</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">DENSE</span><span class="p">,</span><span class="w"> </span><span class="n">Ownership</span><span class="o">::</span><span class="n">CONST_VIEW</span><span class="p">,</span><span class="w"> </span><span class="n">checking</span><span class="p">,</span><span class="w"> </span><span class="n">layout</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">Checking</span><span class="w"> </span><span class="n">checking</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Checking</span><span class="o">::</span><span class="n">NONE</span><span class="p">,</span><span class="w"> </span><span class="n">Layout</span><span class="w"> </span><span class="n">layout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Layout</span><span class="o">::</span><span class="n">RC</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">StridedMatrix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GenericTensor</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Dimension</span><span class="o">::</span><span class="n">MATRIX</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">STRIDED</span><span class="p">,</span><span class="w"> </span><span class="n">Ownership</span><span class="o">::</span><span class="n">CONTAINER</span><span class="p">,</span><span class="w"> </span><span class="n">checking</span><span class="p">,</span><span class="w"> </span><span class="n">layout</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">Checking</span><span class="w"> </span><span class="n">checking</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Checking</span><span class="o">::</span><span class="n">NONE</span><span class="p">,</span><span class="w"> </span><span class="n">Layout</span><span class="w"> </span><span class="n">layout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Layout</span><span class="o">::</span><span class="n">RC</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">StridedMatrixView</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GenericTensor</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Dimension</span><span class="o">::</span><span class="n">MATRIX</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">STRIDED</span><span class="p">,</span><span class="w"> </span><span class="n">Ownership</span><span class="o">::</span><span class="n">VIEW</span><span class="p">,</span><span class="w"> </span><span class="n">checking</span><span class="p">,</span><span class="w"> </span><span class="n">layout</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">Checking</span><span class="w"> </span><span class="n">checking</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Checking</span><span class="o">::</span><span class="n">NONE</span><span class="p">,</span><span class="w"> </span><span class="n">Layout</span><span class="w"> </span><span class="n">layout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Layout</span><span class="o">::</span><span class="n">RC</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">ConstStridedMatrixView</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GenericTensor</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Dimension</span><span class="o">::</span><span class="n">MATRIX</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">STRIDED</span><span class="p">,</span><span class="w"> </span><span class="n">Ownership</span><span class="o">::</span><span class="n">CONST_VIEW</span><span class="p">,</span><span class="w"> </span><span class="n">checking</span><span class="p">,</span><span class="w"> </span><span class="n">layout</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">Checking</span><span class="w"> </span><span class="n">checking</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Checking</span><span class="o">::</span><span class="n">NONE</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">SparseMatrix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GenericTensor</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Dimension</span><span class="o">::</span><span class="n">MATRIX</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">SPARSE</span><span class="p">,</span><span class="w"> </span><span class="n">Ownership</span><span class="o">::</span><span class="n">CONTAINER</span><span class="p">,</span><span class="w"> </span><span class="n">checking</span><span class="p">,</span><span class="w"> </span><span class="n">Layout</span><span class="o">::</span><span class="n">SPARSE</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">Checking</span><span class="w"> </span><span class="n">checking</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Checking</span><span class="o">::</span><span class="n">NONE</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">SparseMatrixView</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GenericTensor</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Dimension</span><span class="o">::</span><span class="n">MATRIX</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">SPARSE</span><span class="p">,</span><span class="w"> </span><span class="n">Ownership</span><span class="o">::</span><span class="n">VIEW</span><span class="p">,</span><span class="w"> </span><span class="n">checking</span><span class="p">,</span><span class="w"> </span><span class="n">Layout</span><span class="o">::</span><span class="n">SPARSE</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">Checking</span><span class="w"> </span><span class="n">checking</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Checking</span><span class="o">::</span><span class="n">NONE</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">ConstSparseMatrixView</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GenericTensor</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Dimension</span><span class="o">::</span><span class="n">MATRIX</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">SPARSE</span><span class="p">,</span><span class="w"> </span><span class="n">Ownership</span><span class="o">::</span><span class="n">CONST_VIEW</span><span class="p">,</span><span class="w"> </span><span class="n">checking</span><span class="p">,</span><span class="w"> </span><span class="n">Layout</span><span class="o">::</span><span class="n">SPARSE</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code>noexcept</code> specifiers are omitted in this section to reduce verbosity.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>From now on <code>mvl::GenericTensor::</code> will be omitted for the same reason.</p>
</div>
<h2 id="methods">Methods<a class="headerlink" href="#methods" title="Permanent link">&para;</a></h2>
<h3 id="parameter-reflection">Parameter reflection<a class="headerlink" href="#parameter-reflection" title="Permanent link">&para;</a></h3>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">params</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">constexpr</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">Dimension</span><span class="w">   </span><span class="n">dimension</span>
<span class="w">    </span><span class="k">constexpr</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">Type</span><span class="w">        </span><span class="n">type</span><span class="p">;</span>
<span class="w">    </span><span class="k">constexpr</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">Ownership</span><span class="w">   </span><span class="n">ownership</span><span class="p">;</span>
<span class="w">    </span><span class="k">constexpr</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">Checking</span><span class="w">    </span><span class="n">checking</span><span class="p">;</span>
<span class="w">    </span><span class="k">constexpr</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">Layout</span><span class="w">      </span><span class="n">layout</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
</blockquote>
<p>Compile-time reflection of template parameters defining current <code>GenericTensor</code>.</p>
<p>Useful for implementing templates over tensor types and conditional compilation  (for example, template over <code>TensorType</code> can use <code>if constexpr (TensorType::params::dimension == Dimension::MATRIX) {}</code> to conditionally enable logic for matrices).</p>
<h3 id="member-types">Member types<a class="headerlink" href="#member-types" title="Permanent link">&para;</a></h3>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="k">using</span><span class="w"> </span><span class="n">self</span><span class="w">            </span><span class="o">=</span><span class="w"> </span><span class="n">GenericTensor</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">value_type</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">size_type</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">difference_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">ptrdiff_t</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">reference</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">const_reference</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">pointer</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">const_pointer</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">*</span><span class="p">;</span>
</code></pre></div>
</blockquote>
<p>A set of member types analogous to member types of <a href="https://en.cppreference.com/w/cpp/container/vector">std::vector</a>.</p>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="k">using</span><span class="w"> </span><span class="n">owning_reflection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GenericTensor</span><span class="o">&lt;</span><span class="n">value_type</span><span class="p">,</span><span class="w"> </span><span class="n">params</span><span class="o">::</span><span class="n">dimension</span><span class="p">,</span><span class="w"> </span><span class="n">params</span><span class="o">::</span><span class="n">type</span><span class="p">,</span>
<span class="w">                                           </span><span class="n">Ownership</span><span class="o">::</span><span class="n">CONTAINER</span><span class="p">,</span><span class="w"> </span><span class="n">params</span><span class="o">::</span><span class="n">checking</span><span class="p">,</span><span class="w"> </span><span class="n">params</span><span class="o">::</span><span class="n">layout</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>
</blockquote>
<p>Reflection of the tensor type with <code>ownership</code> set to <code>CONTAINER</code>.</p>
<p>This is a return type of most algebraic operators, for example, addition <code>MatrixView&lt;T&gt; + MatrixView&lt;T&gt;</code> logically produces a <code>Matrix&lt;T&gt;</code>. See the table below for reference:</p>
<table>
<thead>
<tr>
<th><code>GenericTensor</code></th>
<th><code>GenericTensor::owning_reflection</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Matrix&lt;T&gt;</code> or <code>MatrixView&lt;T&gt;</code> or <code>ConstMatrixView&lt;T&gt;</code></td>
<td><code>Matrix&lt;T&gt;</code></td>
</tr>
<tr>
<td><code>StridedMatrix&lt;T&gt;</code> or <code>StridedMatrixView&lt;T&gt;</code> or <code>ConstStridedMatrixView&lt;T&gt;</code></td>
<td><code>StridedMatrix&lt;T&gt;</code></td>
</tr>
<tr>
<td><code>SparseMatrix&lt;T&gt;</code> or <code>SparseMatrixView&lt;T&gt;</code> or <code>ConstSparseMatrixView&lt;T&gt;</code></td>
<td><code>SparseMatrix&lt;T&gt;</code></td>
</tr>
</tbody>
</table>
<h3 id="iterators">Iterators<a class="headerlink" href="#iterators" title="Permanent link">&para;</a></h3>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="k">using</span><span class="w">               </span><span class="n">iterator</span><span class="p">;</span>
<span class="k">using</span><span class="w">       </span><span class="n">reverse_iterator</span><span class="p">;</span>
<span class="k">using</span><span class="w">         </span><span class="n">const_iterator</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">const_reverse_iterator</span><span class="p">;</span>

<span class="n">iterator</span><span class="w"> </span><span class="nf">begin</span><span class="p">();</span>
<span class="n">iterator</span><span class="w">   </span><span class="nf">end</span><span class="p">();</span>

<span class="n">reverse_iterator</span><span class="w"> </span><span class="nf">rbegin</span><span class="p">();</span>
<span class="n">reverse_iterator</span><span class="w">   </span><span class="nf">rend</span><span class="p">();</span>

<span class="n">const_iterator</span><span class="w">  </span><span class="nf">begin</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="n">const_iterator</span><span class="w">    </span><span class="nf">end</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="n">const_iterator</span><span class="w"> </span><span class="nf">cbegin</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="n">const_iterator</span><span class="w">   </span><span class="nf">cend</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="n">const_reverse_iterator</span><span class="w">  </span><span class="nf">rbegin</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="n">const_reverse_iterator</span><span class="w">    </span><span class="nf">rend</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="n">const_reverse_iterator</span><span class="w"> </span><span class="nf">crbegin</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="n">const_reverse_iterator</span><span class="w">   </span><span class="nf">crend</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</code></pre></div>
</blockquote>
<p>Iterators for 1D iteration over the underlying array. API and functionality is exactly the same as the one provided by <code>std::vector</code> iterators.</p>
<h3 id="basic-getters">Basic getters<a class="headerlink" href="#basic-getters" title="Permanent link">&para;</a></h3>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="n">size_type</span><span class="w"> </span><span class="nf">size</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</code></pre></div>
</blockquote>
<p>Returns the number of elements stored by the tensor. Size of the underlying array.</p>
<p><strong>Note:</strong> While <code>size() == rows() * cols()</code> is a valid assumption for dense matrices, the same cannot be said about the sparse case.</p>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="n">size_type</span><span class="w"> </span><span class="nf">rows</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires MATRIX</span>
<span class="n">size_type</span><span class="w"> </span><span class="nf">cols</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires MATRIX</span>
</code></pre></div>
</blockquote>
<p>Returns number of rows/columns in the matrix.</p>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="n">size_type</span><span class="w"> </span><span class="nf">row_stride</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires MATRIX &amp;&amp; (DENSE || STRIDED)</span>
<span class="n">size_type</span><span class="w"> </span><span class="nf">col_stride</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires MATRIX &amp;&amp; (DENSE || STRIDED)</span>
</code></pre></div>
</blockquote>
<p>Returns strides of the matrix.</p>
<p><strong>Note 1:</strong> Most linear algebra libraries use only one stride per matrix. In context of the <code>Layout::RC</code> that "conventional" stride will correspond to <code>col_stride()</code>. <code>row_stride()</code> denotes the number of elements which get "skipped" by indexing after the end of each row. Using two strides like this gives us a more general way of viewing into data, particularly in regard to blocking.</p>
<p><strong>Note 2:</strong> Dense non-strided matrices return trivial strides to accommodate API's that can work with both dense and strided inputs. There is no overhead from using actual unit-strides. What constitutes as "trivial strides" can be seen in the table below:</p>
<table>
<thead>
<tr>
<th>Matrix type</th>
<th>Layout</th>
<th>Trivial <code>row_stride()</code> / <code>col_stride()</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>DENSE</code></td>
<td><code>RC</code></td>
<td><strong>0</strong> / <strong>1</strong></td>
</tr>
<tr>
<td><code>DENSE</code></td>
<td><code>CR</code></td>
<td><strong>1</strong> / <strong>0</strong></td>
</tr>
</tbody>
</table>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="n">const_pointer</span><span class="w">  </span><span class="nf">data</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires DENSE || STRIDED</span>
<span class="n">pointer</span><span class="w">        </span><span class="nf">data</span><span class="p">();</span><span class="w">       </span><span class="c1">// requires DENSE || STRIDED</span>
</code></pre></div>
</blockquote>
<p>Returns the pointer to the underlying array.</p>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="kt">bool</span><span class="w"> </span><span class="nf">empty</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</code></pre></div>
</blockquote>
<p>Returns whether there are any elements stored in the tensor.</p>
<h3 id="advanced-getters">Advanced getters<a class="headerlink" href="#advanced-getters" title="Permanent link">&para;</a></h3>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="kt">bool</span><span class="w"> </span><span class="nf">contains</span><span class="p">(</span><span class="n">const_reference</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires value_type::operator==()</span>
</code></pre></div>
</blockquote>
<p>Returns whether matrix contains element equal to <code>value</code>.</p>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="n">size_type</span><span class="w"> </span><span class="nf">count</span><span class="p">(</span><span class="n">const_reference</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires value_type::operator==()</span>
</code></pre></div>
</blockquote>
<p>Returns number of matrix elements equal to<code>value</code>.</p>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="kt">bool</span><span class="w"> </span><span class="nf">is_sorted</span><span class="p">()</span><span class="w">                                                     </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires value_type::operator&lt;()</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">is_sorted</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">const_reference</span><span class="p">,</span><span class="w"> </span><span class="n">const_reference</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cmp</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</code></pre></div>
</blockquote>
<p>Returns whether the underlying array is sorted. Uses <code>operator&lt;</code> to perform comparison by default, callable <code>cmp</code> can be passed to use a custom comparison instead.</p>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span><span class="w"> </span><span class="n">to_std_vector</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</code></pre></div>
</blockquote>
<p>Returns a copy of the underlying array as <code>std::vector</code>.</p>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="n">self</span><span class="w"> </span><span class="nf">transposed</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires MATRIX &amp;&amp; DENSE</span>
</code></pre></div>
</blockquote>
<p>Returns <a href="https://en.wikipedia.org/wiki/Transpose">transpose</a> of the matrix.</p>
<div class="highlight"><pre><span></span><code><span class="n">self</span><span class="w"> </span><span class="nf">clone</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires CONTAINER</span>
</code></pre></div>
<p>Returns a copy of the tensor.</p>
<p>Useful when chaining mutating operations on a tensor with intent of saving the result to a new variable without modifying the original tensor. For example, <code>auto s = tensor.clone().transform(f).sum()</code> will apply function <code>f</code> to the tensor and sum the elements into <code>s</code> without modifying the original <code>tensor</code>.</p>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="n">self</span><span class="w"> </span><span class="nf">move</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires CONTAINER</span>
</code></pre></div>
</blockquote>
<p>Returns <code>std::move(*this)</code>. This is useful to avoid a copy when initializing objects with method chaining.</p>
<p>See corresponding <a href="#initializing-a-matrix-by-chaining-operations">example</a>.</p>
<h3 id="indexation">Indexation<a class="headerlink" href="#indexation" title="Permanent link">&para;</a></h3>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="n">const_reference</span><span class="w"> </span><span class="nf">front</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="n">const_reference</span><span class="w">  </span><span class="nf">back</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="n">reference</span><span class="w">       </span><span class="nf">front</span><span class="p">();</span>
<span class="n">reference</span><span class="w">        </span><span class="nf">back</span><span class="p">();</span>
</code></pre></div>
</blockquote>
<p>Returns first/last element from the underlying 1D representation of the tensor.</p>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="n">reference</span><span class="w">       </span><span class="k">operator</span><span class="p">[](</span><span class="n">size_type</span><span class="w"> </span><span class="n">idx</span><span class="p">);</span>
<span class="n">const_reference</span><span class="w"> </span><span class="k">operator</span><span class="p">[](</span><span class="n">size_type</span><span class="w"> </span><span class="n">idx</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</code></pre></div>
</blockquote>
<p>Returns element number <code>idx</code> from the underlying 1D representation of the tensor.</p>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="n">reference</span><span class="w">       </span><span class="nf">operator</span><span class="p">()(</span><span class="n">size_type</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w">                    </span><span class="c1">// requires VECTOR</span>
<span class="n">const_reference</span><span class="w"> </span><span class="nf">operator</span><span class="p">()(</span><span class="n">size_type</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w">              </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires VECTOR</span>
<span class="n">reference</span><span class="w">       </span><span class="nf">operator</span><span class="p">()(</span><span class="n">size_type</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">j</span><span class="p">);</span><span class="w">       </span><span class="c1">// requires MATRIX</span>
<span class="n">const_reference</span><span class="w"> </span><span class="nf">operator</span><span class="p">()(</span><span class="n">size_type</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires MATRIX</span>
</code></pre></div>
</blockquote>
<p>Returns element <code>i</code> (for vectors) or element <code>(i, j)</code> (for matrices) according to a logical index.</p>
<p><strong>Note:</strong> <code>operator()</code> is a <em>default way of indexing tensors</em> and should be used in vast majority of cases, the main purpose of <code>operator[]</code> is to allow efficient looping over the underlying data when uniform transforms are applied. It is a good idea to prefer <code>operator()</code> even for 1D vectors since in some cases (like sparse vectors) logical index <code>i</code> may not be the same as "in-memory index" <code>idx</code>.</p>
<h3 id="index-conversions">Index conversions<a class="headerlink" href="#index-conversions" title="Permanent link">&para;</a></h3>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="n">size_type</span><span class="w"> </span><span class="nf">get_idx_of_ij</span><span class="p">(</span><span class="n">size_type</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires MATRIX</span>
<span class="n">Index2D</span><span class="w">   </span><span class="nf">get_ij_of_idx</span><span class="p">(</span><span class="n">size_type</span><span class="w"> </span><span class="n">idx</span><span class="p">)</span><span class="w">            </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires MATRIX</span>
</code></pre></div>
</blockquote>
<p>Conversion between the underlying index <code>idx</code> and logical index <code>(i, j)</code> for matrices.</p>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="kt">bool</span><span class="w"> </span><span class="nf">contains_index</span><span class="p">(</span><span class="n">size_type</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires MATRIX &amp;&amp; SPARSE</span>
</code></pre></div>
</blockquote>
<p>Returns whether sparse matrix contains an element with a given index.</p>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="n">size_type</span><span class="w"> </span><span class="nf">extent_major</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires MATRIX &amp;&amp; (DENSE || STRIDED)</span>
<span class="n">size_type</span><span class="w"> </span><span class="nf">extent_minor</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires MATRIX &amp;&amp; (DENSE || STRIDED)</span>
</code></pre></div>
</blockquote>
<p>Returns dense matrix extents according to a memory layout. For example: with a row-major layout (aka <code>Layout::RC</code>) <code>extent_major()</code> will return the number of rows and <code>extent_minor()</code> will return the number of columns.</p>
<p>This is useful for creating generic logic for different layouts.</p>
<h3 id="reductions">Reductions<a class="headerlink" href="#reductions" title="Permanent link">&para;</a></h3>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="n">value_type</span><span class="w">     </span><span class="nf">sum</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires value_type::operator+()</span>
<span class="n">value_type</span><span class="w"> </span><span class="nf">product</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires value_type::operator*()</span>
<span class="n">value_type</span><span class="w">     </span><span class="nf">min</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires value_type::operator&lt;()</span>
<span class="n">value_type</span><span class="w">     </span><span class="nf">max</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires value_type::operator&lt;()</span>
</code></pre></div>
</blockquote>
<p>Reduces matrix over a binary operation <code>+</code>, <code>*</code>, <code>min</code> or <code>max</code>.</p>
<p>Particularly useful in combination with <a href="#block-subviews">subviews</a>.</p>
<h3 id="predicate-operations">Predicate operations<a class="headerlink" href="#predicate-operations" title="Permanent link">&para;</a></h3>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="kt">bool</span><span class="w"> </span><span class="nf">true_for_any</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">const_reference</span><span class="p">)</span><span class="o">&gt;</span><span class="w">                       </span><span class="n">predicate</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">true_for_any</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">const_reference</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">)</span><span class="o">&gt;</span><span class="w">            </span><span class="n">predicate</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires VECTOR</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">true_for_any</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">const_reference</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">predicate</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires MATRIX</span>
</code></pre></div>
</blockquote>
<p>Returns whether  <code>predicate</code> evaluates to <code>true</code> for any elements in the tensor.</p>
<p>Overloads <strong>(2)</strong> and <strong>(3)</strong> allow predicates to also take element index into condition.</p>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="kt">bool</span><span class="w"> </span><span class="nf">true_for_all</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">const_reference</span><span class="p">)</span><span class="o">&gt;</span><span class="w">                       </span><span class="n">predicate</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">true_for_all</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">const_reference</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">)</span><span class="o">&gt;</span><span class="w">            </span><span class="n">predicate</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires VECTOR</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">true_for_all</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">const_reference</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">predicate</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires MATRIX</span>
</code></pre></div>
</blockquote>
<p>Returns whether  <code>predicate</code> evaluates to <code>true</code> for all elements in the tensor.</p>
<p>Overloads <strong>(2)</strong> and <strong>(3)</strong> allow predicates to also take element index into condition.</p>
<h3 id="const-algorithms">Const algorithms<a class="headerlink" href="#const-algorithms" title="Permanent link">&para;</a></h3>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">for_each</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">const_reference</span><span class="p">)</span><span class="o">&gt;</span><span class="w">                       </span><span class="n">func</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">for_each</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">const_reference</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">)</span><span class="o">&gt;</span><span class="w">            </span><span class="n">func</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires VECTOR</span>
<span class="k">const</span><span class="w"> </span><span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">for_each</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">const_reference</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">func</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires MATRIX</span>
</code></pre></div>
</blockquote>
<p>Invokes non-mutating <code>func</code> for all elements in the tensor. </p>
<p>Overloads <strong>(2)</strong> and <strong>(3)</strong> allow <code>func</code> to also use element index as an argument.</p>
<h3 id="mutating-algorithms">Mutating algorithms<a class="headerlink" href="#mutating-algorithms" title="Permanent link">&para;</a></h3>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">for_each</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">reference</span><span class="p">)</span><span class="o">&gt;</span><span class="w">                       </span><span class="n">func</span><span class="p">);</span>
<span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">for_each</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">)</span><span class="o">&gt;</span><span class="w">            </span><span class="n">func</span><span class="p">);</span><span class="w"> </span><span class="c1">// requires VECTOR</span>
<span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">for_each</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">func</span><span class="p">);</span><span class="w"> </span><span class="c1">// requires MATRIX</span>
</code></pre></div>
</blockquote>
<p>Invokes mutating <code>func</code> for all elements in the tensor. </p>
<p>Overloads <strong>(2)</strong> and <strong>(3)</strong> allow <code>func</code> to also use element index as an argument.</p>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">transform</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="n">value_type</span><span class="p">(</span><span class="n">const_reference</span><span class="p">)</span><span class="o">&gt;</span><span class="w">                       </span><span class="n">func</span><span class="p">);</span>
<span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">transform</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="n">value_type</span><span class="p">(</span><span class="n">const_reference</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">)</span><span class="o">&gt;</span><span class="w">            </span><span class="n">func</span><span class="p">);</span><span class="w"> </span><span class="c1">// requires VECTOR</span>
<span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">transform</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="n">value_type</span><span class="p">(</span><span class="n">const_reference</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">func</span><span class="p">);</span><span class="w"> </span><span class="c1">// requires MATRIX</span>
</code></pre></div>
</blockquote>
<p>Set <code>element</code> to <code>func(element)</code> for all element of the tensor.</p>
<p>Overloads <strong>(2)</strong> and <strong>(3)</strong> allow <code>func</code> to also use element index as an argument.</p>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">fill</span><span class="p">(</span><span class="n">const_reference</span><span class="w"> </span><span class="n">value</span><span class="p">);</span>
</code></pre></div>
</blockquote>
<p>Sets all elements of the tensor to <code>value</code>.</p>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">fill</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="n">value_type</span><span class="p">()</span><span class="o">&gt;</span><span class="w">                       </span><span class="n">func</span><span class="p">);</span>
<span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">fill</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="n">value_type</span><span class="p">(),</span><span class="w"> </span><span class="n">size_type</span><span class="o">&gt;</span><span class="w">            </span><span class="n">func</span><span class="p">);</span><span class="w"> </span><span class="c1">// requires VECTOR</span>
<span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">fill</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="n">value_type</span><span class="p">(),</span><span class="w"> </span><span class="n">size_type</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="o">&gt;</span><span class="w"> </span><span class="n">func</span><span class="p">);</span><span class="w"> </span><span class="c1">// requires MATRIX</span>
</code></pre></div>
</blockquote>
<p>Sets all elements of the tensor to a value returned by <code>func()</code>.</p>
<p>Overloads <strong>(2)</strong> and <strong>(3)</strong> allow <code>func</code> to also use element index as an argument.</p>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="n">self</span><span class="o">&amp;</span><span class="w">        </span><span class="nf">sort</span><span class="p">();</span><span class="w"> </span><span class="c1">// requires value_type::operator&lt;()</span>
<span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">stable_sort</span><span class="p">();</span><span class="w"> </span><span class="c1">// requires value_type::operator&lt;()</span>
<span class="n">self</span><span class="o">&amp;</span><span class="w">        </span><span class="nf">sort</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">const_reference</span><span class="p">,</span><span class="w"> </span><span class="n">const_reference</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cmp</span><span class="p">);</span>
<span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">stable_sort</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">const_reference</span><span class="p">,</span><span class="w"> </span><span class="n">const_reference</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cmp</span><span class="p">);</span>
</code></pre></div>
</blockquote>
<p>Sorts elements of the underlying array according to <code>operator&lt;</code> or a custom comparison <code>cmp</code>.</p>
<p><code>stable_sort()</code> uses <a href="https://en.wikipedia.org/wiki/Category:Stable_sorts">stable sorting algorithms</a> to maintain the relative order of entries with equal values, however it may come at a cost of some performance (specifics depend on a compiler implementation).</p>
<h3 id="block-subviews">Block subviews<a class="headerlink" href="#block-subviews" title="Permanent link">&para;</a></h3>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="k">using</span><span class="w"> </span><span class="n">block_view_type</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">block_const_view_type</span><span class="p">;</span>
</code></pre></div>
</blockquote>
<p>Types returned by blocking subview methods of the tensor.</p>
<p>Dense and strided matrices will use appropriately strided views to efficiently represent blocking, while sparse matrices returns sparse views.</p>
<p>All subviews inherit <code>T</code>, <code>Dimension</code> and <code>Checking</code> configuration from the parent.</p>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="n">block_view_type</span><span class="w">       </span><span class="nf">block</span><span class="p">(</span><span class="n">size_type</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">cols</span><span class="p">);</span><span class="w">        </span><span class="c1">// requires MATRIX</span>
<span class="n">block_const_view_type</span><span class="w"> </span><span class="nf">block</span><span class="p">(</span><span class="n">size_type</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w">  </span><span class="c1">// requires MATRIX</span>
</code></pre></div>
</blockquote>
<p>Returns block subview starting at <code>(i, j)</code> with size <code>rows</code> x <code>cols</code>. </p>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="n">block_view_type</span><span class="w">       </span><span class="nf">row</span><span class="p">(</span><span class="n">size_type</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w">       </span><span class="c1">// requires MATRIX</span>
<span class="n">block_const_view_type</span><span class="w"> </span><span class="nf">row</span><span class="p">(</span><span class="n">size_type</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires MATRIX</span>
</code></pre></div>
</blockquote>
<p>Returns block subview corresponding to the <code>i</code>-th row.</p>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="n">block_view_type</span><span class="w">       </span><span class="nf">col</span><span class="p">(</span><span class="n">size_type</span><span class="w"> </span><span class="n">j</span><span class="p">);</span><span class="w">       </span><span class="c1">// requires MATRIX</span>
<span class="n">block_const_view_type</span><span class="w"> </span><span class="nf">col</span><span class="p">(</span><span class="n">size_type</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires MATRIX</span>
</code></pre></div>
</blockquote>
<p>Returns block subview corresponding to the <code>j</code>-th column.</p>
<h3 id="sparse-subviews">Sparse subviews<a class="headerlink" href="#sparse-subviews" title="Permanent link">&para;</a></h3>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="k">using</span><span class="w"> </span><span class="n">sparse_view_type</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">sparse_const_view_type</span><span class="p">;</span>
</code></pre></div>
</blockquote>
<p>Types returned by sparse subview methods of the tensor.</p>
<p>Evaluate to appropriate sparse tensor views that inherits <code>T</code>, <code>Dimension</code> and <code>Checking</code> configuration from the parent.</p>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="n">sparse_view_type</span><span class="w"> </span><span class="nf">filter</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">const_reference</span><span class="p">)</span><span class="o">&gt;</span><span class="w">                       </span><span class="n">predicate</span><span class="p">);</span>
<span class="n">sparse_view_type</span><span class="w"> </span><span class="nf">filter</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">const_reference</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">)</span><span class="o">&gt;</span><span class="w">            </span><span class="n">predicate</span><span class="p">);</span><span class="w"> </span><span class="c1">// requires VECTOR</span>
<span class="n">sparse_view_type</span><span class="w"> </span><span class="nf">filter</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">const_reference</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">predicate</span><span class="p">);</span><span class="w"> </span><span class="c1">// requires MATRIX</span>
</code></pre></div>
</blockquote>
<p>Returns a sparse view to all elements satisfying the <code>predicate</code>.</p>
<p>Overloads <strong>(2)</strong> and <strong>(3)</strong> allow predicates to also take element index into condition.</p>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="n">sparse_const_view_type</span><span class="w"> </span><span class="nf">filter</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">const_reference</span><span class="p">)</span><span class="o">&gt;</span><span class="w">                       </span><span class="n">predicate</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="n">sparse_const_view_type</span><span class="w"> </span><span class="nf">filter</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">const_reference</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">)</span><span class="o">&gt;</span><span class="w">            </span><span class="n">predicate</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires VECTOR</span>
<span class="n">sparse_const_view_type</span><span class="w"> </span><span class="nf">filter</span><span class="p">(</span><span class="n">Callable</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">const_reference</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">predicate</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires MATRIX</span>
</code></pre></div>
</blockquote>
<p><code>const</code> version of the previous method.</p>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="n">sparse_view_type</span><span class="w">       </span><span class="nf">diagonal</span><span class="p">();</span><span class="w">       </span><span class="c1">// requires MATRIX</span>
<span class="n">sparse_const_view_type</span><span class="w"> </span><span class="nf">diagonal</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires MATRIX</span>
</code></pre></div>
</blockquote>
<p>Returns sparse view to a matrix diagonal.</p>
<h3 id="sparse-operations">Sparse operations<a class="headerlink" href="#sparse-operations" title="Permanent link">&para;</a></h3>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="k">using</span><span class="w"> </span><span class="n">sparse_entry_type</span><span class="p">;</span><span class="w"> </span><span class="c1">// requires SPARSE</span>
</code></pre></div>
</blockquote>
<p><code>index</code> + <code>value</code> entry type corresponding to a sparse  tensor (aka pairs for vector and triplets for matrices). Such entries are used to initialize and fill sparse matrices with values (similarly to the vast majority of other sparse matrix implementation).</p>
<p>A table of appropriate sparse entry types can be seen below:</p>
<table>
<thead>
<tr>
<th>Tensor dimension</th>
<th>Ownership</th>
<th>Value of <code>sparse_entry_type</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>VECTOR</code></td>
<td><code>CONTAINER</code></td>
<td><code>SparseEntry1D&lt;value_type&gt;&gt;</code></td>
</tr>
<tr>
<td><code>VECTOR</code></td>
<td><code>VIEW</code></td>
<td><code>SparseEntry1D&lt;std::reference_wrapper&lt;value_type&gt;&gt;</code></td>
</tr>
<tr>
<td><code>VECTOR</code></td>
<td><code>CONST_VIEW</code></td>
<td><code>SparseEntry1D&lt;std::reference_wrapper&lt;const value_type&gt;&gt;</code></td>
</tr>
<tr>
<td><code>MATRIX</code></td>
<td><code>CONTAINER</code></td>
<td><code>SparseEntry2D&lt;value_type&gt;&gt;</code></td>
</tr>
<tr>
<td><code>MATRIX</code></td>
<td><code>VIEW</code></td>
<td><code>SparseEntry2D&lt;std::reference_wrapper&lt;value_type&gt;&gt;</code></td>
</tr>
<tr>
<td><code>MATRIX</code></td>
<td><code>CONST_VIEW</code></td>
<td><code>SparseEntry2D&lt;std::reference_wrapper&lt;const value_type&gt;&gt;</code></td>
</tr>
</tbody>
</table>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">rewrite_triplets</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">triplet_type</span><span class="o">&gt;&amp;&amp;</span><span class="w"> </span><span class="n">triplets</span><span class="p">);</span><span class="w"> </span><span class="c1">// requires MATRIX &amp;&amp; SPARSE</span>
</code></pre></div>
</blockquote>
<p>Replaces all existing entries in the sparse matrix with given <code>triplets</code>. </p>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">insert_triplets</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">triplet_type</span><span class="o">&gt;&amp;</span><span class="w">  </span><span class="n">triplets</span><span class="p">);</span><span class="w"> </span><span class="c1">// requires MATRIX &amp;&amp; SPARSE</span>
</code></pre></div>
</blockquote>
<p>Inserts given <code>triplets</code> into a sparse matrix.</p>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">erase_triplets</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Index2D</span><span class="o">&gt;</span><span class="w"> </span><span class="n">indices</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">// requires MATRIX &amp;&amp; SPARSE</span>
</code></pre></div>
</blockquote>
<p>Erases entries with given <code>indices</code> from the sparse matrix.</p>
<h3 id="linear-algebra-operators">Linear algebra operators<a class="headerlink" href="#linear-algebra-operators" title="Permanent link">&para;</a></h3>
<h4 id="unary-operators">Unary operators<a class="headerlink" href="#unary-operators" title="Permanent link">&para;</a></h4>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="c1">// Unary operators</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">L</span><span class="o">&gt;</span><span class="w"> </span><span class="n">owning_reflection</span><span class="w"> </span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">L</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">left</span><span class="p">);</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">L</span><span class="o">&gt;</span><span class="w"> </span><span class="n">owning_reflection</span><span class="w"> </span><span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="n">L</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">left</span><span class="p">);</span>
</code></pre></div>
</blockquote>
<p>Returns the result of applying unary operator <code>+</code> or <code>-</code> to all elements of the tensor <code>left</code>.</p>
<p>Operators are only compiled if <code>value_type</code> of the tensor supports a corresponding unary operator.</p>
<p><strong>Note:</strong> Here and in all other methods of this section <code>owning_reflection</code> is a shortcut name for <code>typename std::decay&lt;L&gt;::owning_reflection</code>. This type represents the fact that while we can perform algebraic operations on matrix views, the resulting matrix will be a proper "owning" one.</p>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">L</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Op</span><span class="o">&gt;</span><span class="w"> </span><span class="n">owning_reflection</span><span class="w"> </span><span class="n">apply_unary_op</span><span class="p">(</span><span class="n">L</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">Op</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">op</span><span class="p">);</span>
</code></pre></div>
</blockquote>
<p>A generic function for applying unary operator <code>op</code> to all elements of the tensor <code>left</code>.</p>
<h4 id="binary-operators">Binary operators<a class="headerlink" href="#binary-operators" title="Permanent link">&para;</a></h4>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="c1">// Binary operators</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">L</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">R</span><span class="o">&gt;</span><span class="w"> </span><span class="n">owning_reflection</span><span class="w">           </span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">L</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">right</span><span class="p">);</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">L</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">R</span><span class="o">&gt;</span><span class="w"> </span><span class="n">owning_reflection</span><span class="w">           </span><span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="n">L</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">right</span><span class="p">);</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">L</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">R</span><span class="o">&gt;</span><span class="w"> </span><span class="n">owning_reflection</span><span class="w"> </span><span class="n">elementwise_product</span><span class="p">(</span><span class="n">L</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">right</span><span class="p">);</span>
</code></pre></div>
</blockquote>
<p>Returns the result of applying binary operator <code>+</code>, <code>-</code> or <code>*</code> to all pairs of elements in <code>left</code> and <code>right</code> tensors.</p>
<p>Operators are only compiled if <code>value_type</code> of both tensors is the same and supports a corresponding binary operator.</p>
<p><strong>Note 1:</strong> Both binary and unary operators will reuse <a href="https://en.cppreference.com/w/cpp/language/value_category">r-value</a> arguments to avoid allocations if possible. This means that a long chain of operators like <code>A + B + C - (-D)</code> will usually only allocate once and then propagate that temporary throughout the chain, only computing the actual operations.</p>
<p><strong>Note 2:</strong> All operators are aware of matrix sparsity and will select appropriate implementations. Implementations have following time complexities:</p>
<table>
<thead>
<tr>
<th>Type of <code>L</code></th>
<th>Type of <code>R</code></th>
<th>Element-wise binary operator complexity</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>DENSE</code> or <code>STRIDED</code></td>
<td><code>DENSE</code> or <code>STRIDED</code></td>
<td><span class="arithmatex">\(O(N^2)\)</span></td>
</tr>
<tr>
<td><code>DENSE</code> or <code>STRIDED</code></td>
<td><code>SPARSE</code></td>
<td><span class="arithmatex">\(O(N)\)</span></td>
</tr>
<tr>
<td><code>SPARSE</code></td>
<td><code>DENSE</code> or <code>STRIDED</code></td>
<td><span class="arithmatex">\(O(N)\)</span></td>
</tr>
<tr>
<td><code>SPARSE</code></td>
<td><code>SPARSE</code></td>
<td><span class="arithmatex">\(O(N)\)</span></td>
</tr>
</tbody>
</table>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">L</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">R</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Op</span><span class="o">&gt;</span><span class="w"> </span><span class="n">owning_reflection</span><span class="w"> </span><span class="n">apply_binary_op</span><span class="p">(</span><span class="n">L</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="n">Op</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">op</span><span class="p">);</span>
</code></pre></div>
</blockquote>
<p>A generic function for applying binary operator <code>op</code> to all elements of the tensor <code>left</code>.</p>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">L</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">R</span><span class="o">&gt;</span><span class="w"> </span><span class="n">owning_reflection</span><span class="w"> </span><span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">L</span><span class="o">&amp;</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">R</span><span class="o">&amp;</span><span class="w"> </span><span class="n">right</span><span class="p">);</span>
</code></pre></div>
</blockquote>
<p>Returns the matrix product <span class="arithmatex">\(c_{ij} = \sum_{k = 1}^{N} a_{ik} b_{kj}\)</span>.</p>
<p>Operator is only compiled if <code>value_type</code> of both tensors is the same and supports operators <code>+=</code> and <code>*</code>.</p>
<p><strong>Note 1:</strong> Matrix product is aware of matrix memory layout and will select the appropriate iteration order. <a href="https://en.wikipedia.org/wiki/Loop_nest_optimization">Loop tiling</a> is used to improve cache efficiency at large sizes. It should be noted however that <code>mvl</code> is not a linear algebra library at its core and will be significantly outperformed by dedicated <a href="https://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms">BLAS</a> routines in the task of number crunching.</p>
<p><strong>Note 2:</strong> Matrix product is aware of matrix sparsity and will select appropriate implementations. Implementations have following time complexities:</p>
<table>
<thead>
<tr>
<th>Type of <code>L</code></th>
<th>Type of <code>R</code></th>
<th>Matrix product complexity</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>DENSE</code> or <code>STRIDED</code></td>
<td><code>DENSE</code> or <code>STRIDED</code></td>
<td><span class="arithmatex">\(O(N^3)\)</span></td>
</tr>
<tr>
<td><code>DENSE</code> or <code>STRIDED</code></td>
<td><code>SPARSE</code></td>
<td><span class="arithmatex">\(O(N^2)\)</span></td>
</tr>
<tr>
<td><code>SPARSE</code></td>
<td><code>DENSE</code> or <code>STRIDED</code></td>
<td><span class="arithmatex">\(O(N^2)\)</span></td>
</tr>
<tr>
<td><code>SPARSE</code></td>
<td><code>SPARSE</code></td>
<td><span class="arithmatex">\(O(N)\)</span></td>
</tr>
</tbody>
</table>
<h4 id="augmented-assignment-operators">Augmented assignment operators<a class="headerlink" href="#augmented-assignment-operators" title="Permanent link">&para;</a></h4>
<blockquote>
<p>```cpp
// Augmented assignment operators
template <class L, class R> L&amp; operator+=(L&amp;&amp; left, R&amp;&amp; right);
template <class L, class R> L&amp; operator-=(L&amp;&amp; left, R&amp;&amp; right);</p>
</blockquote>
<p><strong>TODO:</strong> This behavior is not yet finalized, there are still some considerations to make.</p>
<h3 id="tensor-io-formats">Tensor IO formats<a class="headerlink" href="#tensor-io-formats" title="Permanent link">&para;</a></h3>
<blockquote>
<div class="highlight"><pre><span></span><code><span class="c1">// Human-readable formats</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">mvl::format::as_vector</span><span class="p">(</span><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">GenericTensor</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tensor</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">mvl::format::as_matrix</span><span class="p">(</span><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">GenericTensor</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tensor</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">mvl::format::as_dictionary</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">GenericTensor</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tensor</span><span class="p">);</span>
<span class="c1">// Export formats</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">mvl::format::as_raw_text</span><span class="p">(</span><span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">GenericTensor</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tensor</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">mvl::format::as_json_array</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">GenericTensor</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tensor</span><span class="p">);</span>
</code></pre></div>
</blockquote>
<p>Converts tensor to string, formatted according to a chosen schema. All formats accept arbitrary tensors and properly handle sparse matrices.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>as_vector</code></td>
<td>Human-readable format. Formats tensor as a flat array of values.</td>
</tr>
<tr>
<td><code>as_matrix</code></td>
<td>Human-readable format. Formats tensor as a 1- or 2-D matrix. Missing sparse matrix entries are marked with <code>-</code>.</td>
</tr>
<tr>
<td><code>as_dictionary</code></td>
<td>Human-readable format. Formats tensor as a list of <code>key</code>-<code>value</code> pairs. Useful for sparse matrices.</td>
</tr>
<tr>
<td><code>as_raw_text</code></td>
<td>Export format. Formats tensor as a raw data separated by spaces and newlines (in case of matrices).</td>
</tr>
<tr>
<td><code>as_json_array</code></td>
<td>Export format. Formats tensor as a 1- or 2-D <a href="https://en.wikipedia.org/wiki/JSON">JSON</a> array.</td>
</tr>
</tbody>
</table>
<p>See corresponding <a href="#io-formats">example</a> to get a better idea of what each output looks like.</p>
<p><strong>Note 1:</strong> Stringification works for any type with an existing <code>operator&lt;&lt;(std::ostream&amp;, const T&amp;)</code> overload.</p>
<p><strong>Note 2:</strong> <code>as_json_array</code> assumes that <code>operator&lt;&lt;(std::ostream&amp;, const T&amp;)</code> produces a string, corresponding to a valid <a href="https://ecma-international.org/publications-and-standards/standards/ecma-404/">JSON object</a>. By default, <code>mvl</code> knows how to properly handle all built-in numeric, logical and string types, user-defined types have to handle their formatting themselves.</p>
<p><strong>Note 3:</strong> Human-readable formats automatically collapse matrices above a certain "readable" size (70+ rows or 40+ columns for <code>as_matrix</code>, 500+ elements for <code>as_vector</code> and <code>as_dictionary</code>).</p>
<h3 id="constructors">Constructors<a class="headerlink" href="#constructors" title="Permanent link">&para;</a></h3>
<h4 id="generic-constructors">Generic constructors<a class="headerlink" href="#generic-constructors" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><span class="n">GenericTensor</span><span class="p">();</span><span class="w"> </span><span class="c1">// requires CONTAINER</span>
</code></pre></div>
<p>Default-initializes an empty tensor. Only provided for containers, since views cannot exist without a target to view into.</p>
<div class="highlight"><pre><span></span><code><span class="n">GenericTensor</span><span class="p">(</span><span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">self</span><span class="o">&amp;</span><span class="w">  </span><span class="n">other</span><span class="p">);</span>
<span class="n">GenericTensor</span><span class="p">(</span><span class="w">        </span><span class="n">self</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>
<span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">self</span><span class="o">&amp;</span><span class="w">  </span><span class="n">other</span><span class="p">);</span>
<span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="w">      </span><span class="n">self</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>
</code></pre></div>
<p>Copy/move constructors and assignment operators for tensors of the same type.</p>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">Type</span><span class="w"> </span><span class="n">other_type</span><span class="p">,</span><span class="w"> </span><span class="n">Ownership</span><span class="w"> </span><span class="n">other_ownership</span><span class="p">,</span><span class="w"> </span><span class="n">Checking</span><span class="w"> </span><span class="n">other_checking</span><span class="p">,</span><span class="w"> </span><span class="n">Layout</span><span class="w"> </span><span class="n">other_layout</span><span class="o">&gt;</span>
<span class="n">GenericTensor</span><span class="p">(</span><span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">GenericTensor</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;&amp;</span><span class="w">  </span><span class="n">other</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">Type</span><span class="w"> </span><span class="n">other_type</span><span class="p">,</span><span class="w"> </span><span class="n">Ownership</span><span class="w"> </span><span class="n">other_ownership</span><span class="p">,</span><span class="w"> </span><span class="n">Checking</span><span class="w"> </span><span class="n">other_checking</span><span class="p">,</span><span class="w"> </span><span class="n">Layout</span><span class="w"> </span><span class="n">other_layout</span><span class="o">&gt;</span>
<span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">GenericTensor</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;&amp;</span><span class="w">  </span><span class="n">other</span><span class="p">);</span>
</code></pre></div>
<p>Converting copy constructor/assignment operator for tensors that have different types.</p>
<p>Copy-conversion freely converts over the boundaries of <code>type</code>, <code>ownership</code>, <code>checking</code> and <code>layout</code>. It may use non-trivial logic to perform a "logical copy" for matrices with different APIs, such as, for example, convert sparse matrix to dense by cloning all the sparse contents and setting the other elements to default value, or, for example, construct sparse matrix from dense by filtering out all default-initialized elements and using the remainder as sparse contents (see an <a href="#working-with-sparse-matrices">example</a> of working with sparse matrices).</p>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">Checking</span><span class="w"> </span><span class="n">other_checking</span><span class="o">&gt;</span>
<span class="n">GenericTensor</span><span class="p">(</span><span class="w">  </span><span class="n">GenericTensor</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;&amp;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">Checking</span><span class="w"> </span><span class="n">other_checking</span><span class="o">&gt;</span>
<span class="n">self</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">GenericTensor</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;&amp;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>
</code></pre></div>
<p>Converting move constructor/assignment operator for tensors that have different types, yet can logically be converted to each other.</p>
<p>Note that move-conversion is more restricting than copy-conversion due to move-semantics requiring both matrices to have a compatible memory layout of .</p>
<h4 id="matrix-constructors"><code>Matrix</code> constructors<a class="headerlink" href="#matrix-constructors" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><span class="k">explicit</span><span class="w"> </span><span class="n">GenericTensor</span><span class="p">(</span><span class="n">size_type</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"> </span><span class="n">const_reference</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value_type</span><span class="p">());</span>
</code></pre></div>
<p>Constructs a <code>rows</code> by <code>cols</code> matrix with elements initialized to <code>value</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">explicit</span><span class="w"> </span><span class="n">GenericTensor</span><span class="p">(</span><span class="n">size_type</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"> </span><span class="n">Callable</span><span class="o">&lt;</span><span class="n">value_type</span><span class="p">(</span><span class="n">size_type</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">init_func</span><span class="p">);</span>
</code></pre></div>
<p>Constructs a <code>rows</code> by <code>cols</code> matrix with elements initialized to <code>init_func(i, j)</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">explicit</span><span class="w"> </span><span class="n">GenericTensor</span><span class="p">(</span><span class="n">size_type</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="n">data_ptr</span><span class="p">);</span>
</code></pre></div>
<p>Takes ownership of <code>C</code> array <code>data_ptr</code> and constructs a <code>rows</code> by <code>cols</code> matrix over it.</p>
<div class="highlight"><pre><span></span><code><span class="n">GenericTensor</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">init_list</span><span class="p">);</span>
</code></pre></div>
<p>Constructs matrix from a braced list: <code>{ { ... }, ... , { ... } }</code>.</p>
<h4 id="matrixview-constructors"><code>MatrixView</code> constructors<a class="headerlink" href="#matrixview-constructors" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><span class="k">explicit</span><span class="w"> </span><span class="n">GenericTensor</span><span class="p">(</span><span class="n">size_type</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="n">data_ptr</span><span class="p">);</span>
</code></pre></div>
<p>Constructs a <code>rows</code> by <code>cols</code> matrix view into the data stored at <code>data_ptr</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="n">Ownership</span><span class="w"> </span><span class="n">other_ownership</span><span class="p">,</span><span class="w"> </span><span class="n">Checking</span><span class="w"> </span><span class="n">other_checking</span><span class="p">,</span><span class="w"> </span><span class="n">Layout</span><span class="w"> </span><span class="n">other_layout</span><span class="o">&gt;</span>
<span class="n">GenericTensor</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">GenericTensor</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>
</code></pre></div>
<p>Constructs a matrix view into another dense <code>mvl</code> matrix.</p>
<h4 id="constmatrixview-constructors"><code>ConstMatrixView</code> constructors<a class="headerlink" href="#constmatrixview-constructors" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><span class="k">explicit</span><span class="w"> </span><span class="n">GenericTensor</span><span class="p">(</span><span class="n">size_type</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"> </span><span class="n">const_pointer</span><span class="w"> </span><span class="n">data_ptr</span><span class="p">);</span>
</code></pre></div>
<p>Constructs a <code>rows</code> by <code>cols</code> const  matrix view into the data stored at <code>data_ptr</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="n">Ownership</span><span class="w"> </span><span class="n">other_ownership</span><span class="p">,</span><span class="w"> </span><span class="n">Checking</span><span class="w"> </span><span class="n">other_checking</span><span class="p">,</span><span class="w"> </span><span class="n">Layout</span><span class="w"> </span><span class="n">other_layout</span><span class="o">&gt;</span>
<span class="n">GenericTensor</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">GenericTensor</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>
</code></pre></div>
<p>Constructs a const matrix view into another dense <code>mvl</code> matrix.</p>
<h4 id="stridedmatrix-constructors"><code>StridedMatrix</code> constructors<a class="headerlink" href="#stridedmatrix-constructors" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><span class="k">explicit</span><span class="w"> </span><span class="n">GenericTensor</span><span class="p">(</span><span class="n">size_type</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">row_stride</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">col_stride</span><span class="p">,</span><span class="w"> </span><span class="n">const_reference</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value_type</span><span class="p">());</span>
</code></pre></div>
<p>Constructs a <code>rows</code> by <code>cols</code> matrix with given strides and all elements initialized to <code>value</code>. </p>
<p><strong>Note 1:</strong> See <a href="#basic-getters">"Basic getters" section</a> to learn how row- and col- strides work in <code>mvl</code>.</p>
<p><strong>Note 2:</strong> Strides are usually used in the context of views. In case of an owning matrix strides function as an additional padding between elements, while rarely directly useful, in some cases it can be used to reduce cache misses caused by a particularly "unlucky" alignment of rows relative to a cache size.</p>
<div class="highlight"><pre><span></span><code><span class="k">explicit</span><span class="w"> </span><span class="n">GenericTensor</span><span class="p">(</span><span class="n">size_type</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">row_stride</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">col_stride</span><span class="p">,</span><span class="w"> </span><span class="n">Callable</span><span class="o">&lt;</span><span class="n">value_type</span><span class="p">(</span><span class="n">size_type</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">init_func</span><span class="p">);</span>
</code></pre></div>
<p>Constructs a <code>rows</code> by <code>cols</code> matrix with given strides and all elements initialized to <code>init_func(i, j)</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">explicit</span><span class="w"> </span><span class="n">GenericTensor</span><span class="p">(</span><span class="n">size_type</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">row_stride</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">col_stride</span><span class="p">,</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="n">data_ptr</span><span class="p">);</span>
</code></pre></div>
<h4 id="stridedmatrixview-constructors"><code>StridedMatrixView</code> constructors<a class="headerlink" href="#stridedmatrixview-constructors" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><span class="k">explicit</span><span class="w"> </span><span class="n">GenericTensor</span><span class="p">(</span><span class="n">size_type</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">row_stride</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">col_stride</span><span class="p">,</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="n">data_ptr</span><span class="p">);</span>
</code></pre></div>
<p>Constructs a <code>rows</code> by <code>cols</code> strided matrix view into the data stored at <code>data_ptr</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="n">Ownership</span><span class="w"> </span><span class="n">other_ownership</span><span class="p">,</span><span class="w"> </span><span class="n">Checking</span><span class="w"> </span><span class="n">other_checking</span><span class="p">,</span><span class="w"> </span><span class="n">Layout</span><span class="w"> </span><span class="n">other_layout</span><span class="o">&gt;</span>
<span class="n">GenericTensor</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">GenericTensor</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>
</code></pre></div>
<p>Constructs a strided matrix view into another strided <code>mvl</code> matrix.</p>
<h4 id="conststridedmatrixview-constructors"><code>ConstStridedMatrixView</code> constructors<a class="headerlink" href="#conststridedmatrixview-constructors" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><span class="k">explicit</span><span class="w"> </span><span class="n">GenericTensor</span><span class="p">(</span><span class="n">size_type</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">row_stride</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">col_stride</span><span class="p">,</span><span class="w"> </span><span class="n">const_pointer</span><span class="w"> </span><span class="n">data_ptr</span><span class="p">);</span>
</code></pre></div>
<p>Constructs a <code>rows</code> by <code>cols</code> const strided matrix view into the data stored at <code>data_ptr</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="n">Ownership</span><span class="w"> </span><span class="n">other_ownership</span><span class="p">,</span><span class="w"> </span><span class="n">Checking</span><span class="w"> </span><span class="n">other_checking</span><span class="p">,</span><span class="w"> </span><span class="n">Layout</span><span class="w"> </span><span class="n">other_layout</span><span class="o">&gt;</span>
<span class="n">GenericTensor</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">GenericTensor</span><span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>
</code></pre></div>
<p>Constructs a const strided matrix view into another strided <code>mvl</code> matrix.</p>
<h4 id="sparsematrix-constructors">SparseMatrix constructors<a class="headerlink" href="#sparsematrix-constructors" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><span class="c1">// pass triplets by copy</span>
<span class="k">explicit</span><span class="w"> </span><span class="n">GenericTensor</span><span class="p">(</span><span class="n">size_type</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">sparse_entry_type</span><span class="o">&gt;&amp;</span><span class="w">  </span><span class="n">data</span><span class="p">);</span>
<span class="c1">// pass triplets with move-semantics</span>
<span class="k">explicit</span><span class="w"> </span><span class="n">GenericTensor</span><span class="p">(</span><span class="n">size_type</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">size_type</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w">       </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">sparse_entry_type</span><span class="o">&gt;&amp;&amp;</span><span class="w"> </span><span class="n">data</span><span class="p">);</span>
</code></pre></div>
<p>Constructs a <code>rows</code> by <code>cols</code> sparse matrix from a list of <code>{ i, j, value }</code> triplets.</p>
<p>If triplets aren't intended to be reused, they can be passed with <code>std::move()</code> for a faster construction.</p>
<p>These constructors are valid for both owning sparse matrices and views, with the only difference being the expected <code>sparse_entry_type</code> (note that this is a member type of the tensor class, it can always be used directly as provided). Below is the table detailing possible triplet types for each ownership:</p>
<table>
<thead>
<tr>
<th>Ownership</th>
<th>Value of <code>sparse_entry_type</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>CONTAINER</code></td>
<td><code>SparseEntry2D&lt;value_type&gt;</code></td>
</tr>
<tr>
<td><code>VIEW</code></td>
<td><code>SparseEntry2D&lt;std::reference_wrapper&lt;value_type&gt;&gt;</code></td>
</tr>
<tr>
<td><code>CONST_VIEW</code></td>
<td><code>SparseEntry2D&lt;std::reference_wrapper&lt;const value_type&gt;&gt;</code></td>
</tr>
</tbody>
</table>
<p>Here <code>mvl::SparseEntry2D&lt;T&gt;</code> is a simple POD struct:</p>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">SparseEntry2D</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">    </span><span class="n">T</span><span class="w">      </span><span class="n">value</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<h2 id="examples">Examples<a class="headerlink" href="#examples" title="Permanent link">&para;</a></h2>
<h3 id="declaring-and-indexing-a-matrix">Declaring and indexing a matrix<a class="headerlink" href="#declaring-and-indexing-a-matrix" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">utl</span><span class="p">;</span>

<span class="c1">// Declare regular dense matrix</span>
<span class="n">mvl</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 2D indexation</span>
<span class="n">assert</span><span class="p">(</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">);</span>

<span class="c1">// 1D indexation</span>
<span class="n">assert</span><span class="p">(</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">);</span>

<span class="c1">// Range-based loops</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">element</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">A</span><span class="p">)</span><span class="w"> </span><span class="n">assert</span><span class="p">(</span><span class="w"> </span><span class="n">element</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">);</span>

<span class="c1">// std::vector-like API &amp; iterators</span>
<span class="n">assert</span><span class="p">(</span><span class="w">  </span><span class="n">A</span><span class="p">.</span><span class="n">front</span><span class="p">()</span><span class="w">       </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="w">  </span><span class="n">A</span><span class="p">.</span><span class="n">back</span><span class="p">()</span><span class="w">        </span><span class="o">==</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="w"> </span><span class="o">*</span><span class="n">A</span><span class="p">.</span><span class="n">cbegin</span><span class="p">()</span><span class="w">      </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">cend</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">  </span><span class="o">==</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="p">);</span>

<span class="c1">// Basic getters</span>
<span class="n">assert</span><span class="p">(</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">rows</span><span class="p">()</span><span class="w">  </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w">     </span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">cols</span><span class="p">()</span><span class="w">  </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="w">     </span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w">  </span><span class="o">==</span><span class="w"> </span><span class="mi">6</span><span class="w">     </span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="p">);</span>

<span class="c1">// Declare matrix with enabled bound-checking</span>
<span class="n">mvl</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">mvl</span><span class="o">::</span><span class="n">Checking</span><span class="o">::</span><span class="n">BOUNDS</span><span class="o">&gt;</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">;</span>

<span class="c1">// B(3, 2) = 1; // will throw with a message &quot;i (which is 3) &gt;= this-&gt;rows() (which is 2)&quot;</span>
</code></pre></div>
<h3 id="io-formats">IO formats<a class="headerlink" href="#io-formats" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">utl</span><span class="p">;</span>

<span class="c1">// Create sparse matrix from triplets</span>
<span class="n">mvl</span><span class="o">::</span><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">mat</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span>
<span class="p">{</span>
<span class="w">    </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mf">3.14</span><span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mf">4.24</span><span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mf">7.15</span><span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mf">2.38</span><span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mf">734.835</span><span class="w"> </span><span class="p">}</span>
<span class="p">});</span>

<span class="c1">// Showcase different IO formats</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span>
<span class="w">    </span><span class="c1">// Human-readable formats</span>
<span class="w">    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">## as_vector() ##</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="w">     </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">mvl</span><span class="o">::</span><span class="n">format</span><span class="o">::</span><span class="n">as_vector</span><span class="p">(</span><span class="w">    </span><span class="n">mat</span><span class="p">)</span>
<span class="w">    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">## as_matrix() ##</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="w">     </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">mvl</span><span class="o">::</span><span class="n">format</span><span class="o">::</span><span class="n">as_matrix</span><span class="p">(</span><span class="w">    </span><span class="n">mat</span><span class="p">)</span>
<span class="w">    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">## as_dictionary() ##</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">mvl</span><span class="o">::</span><span class="n">format</span><span class="o">::</span><span class="n">as_dictionary</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
<span class="w">    </span><span class="c1">// Export formats</span>
<span class="w">    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">## as_raw_text() ##</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="w">   </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">mvl</span><span class="o">::</span><span class="n">format</span><span class="o">::</span><span class="n">as_raw_text</span><span class="p">(</span><span class="w">  </span><span class="n">mat</span><span class="p">)</span>
<span class="w">    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">## as_json_array() ##</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">mvl</span><span class="o">::</span><span class="n">format</span><span class="o">::</span><span class="n">as_json_array</span><span class="p">(</span><span class="n">mat</span><span class="p">);</span>

<span class="c1">// Human-readable formats will automatically collapse matrices above certain size to following format:</span>
<span class="c1">// &gt; Tensor [size = 250000] (500 x 500):</span>
<span class="c1">// &gt;   &lt;hidden due to large size&gt;</span>
</code></pre></div>
<p>Output:
<div class="highlight"><pre><span></span><code>## as_vector() ##

Tensor [size = 5] (3 x 4):
  { 3.14, 4.24, 7.15, 2.38, 734.835 }

## as_matrix() ##

Tensor [size = 5] (3 x 4):
  [ 3.14 4.24    -       - ]
  [    - 7.15    -       - ]
  [    -    - 2.38 734.835 ]

## as_dictionary() ##

Tensor [size = 5] (3 x 4):
  (0, 0) = 3.14
  (0, 1) = 4.24
  (1, 1) = 7.15
  (2, 2) = 2.38
  (2, 3) = 734.835

## as_raw_text() ##

3.14 4.24 0 0 
0 7.15 0 0 
0 0 2.38 734.835

## as_json_array() ##

[
  [ 3.14, 4.24,    0,       0 ], 
  [    0, 7.15,    0,       0 ], 
  [    0,    0, 2.38, 734.835 ] 
]
</code></pre></div></p>
<h3 id="initializing-a-matrix-by-chaining-operations">Initializing a matrix by chaining operations<a class="headerlink" href="#initializing-a-matrix-by-chaining-operations" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">utl</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">random_device</span><span class="w">         </span><span class="n">rd</span><span class="p">;</span><span class="w">    </span>
<span class="n">std</span><span class="o">::</span><span class="n">default_random_engine</span><span class="w"> </span><span class="nf">gen</span><span class="p">(</span><span class="n">rd</span><span class="p">());</span>
<span class="n">std</span><span class="o">::</span><span class="n">normal_distribution</span><span class="w">   </span><span class="nf">dist</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="w"> </span><span class="mf">1.</span><span class="p">);</span>

<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">rand_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span><span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">dist</span><span class="p">(</span><span class="n">gen</span><span class="p">);</span><span class="w">   </span><span class="p">};</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">abs</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">){</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="p">};</span>

<span class="c1">// Build 5x5 matrix where {a_ij} = |N(0, 1)|</span>
<span class="c1">// &#39;.move()&#39; avoids a copy when assigning &#39;A&#39;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mvl</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">).</span><span class="n">fill</span><span class="p">(</span><span class="n">rand_value</span><span class="p">).</span><span class="n">transform</span><span class="p">(</span><span class="n">abs</span><span class="p">).</span><span class="n">move</span><span class="p">();</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">mvl</span><span class="o">::</span><span class="n">format</span><span class="o">::</span><span class="n">as_matrix</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
</code></pre></div>
<p>Output:
<div class="highlight"><pre><span></span><code>Tensor [size = 25] (5 x 5):
  [ 0.592525 0.378606  1.94445 0.724242 0.0230773 ]
  [ 0.854804 0.578115  2.33575  1.10363   1.24067 ]
  [ 0.731419 0.870693 0.681755 0.446197  0.136237 ]
  [ 0.889649  1.84099  1.17115  0.45199  0.506486 ]
  [ 0.915286 0.287618 0.638074 0.489174    1.1951 ]
</code></pre></div></p>
<h3 id="wrapping-external-data-into-views">Wrapping external data into views<a class="headerlink" href="#wrapping-external-data-into-views" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">utl</span><span class="p">;</span>

<span class="c1">// Some raw data</span>
<span class="c1">// (for example, received from an external &#39;C&#39; library)</span>
<span class="c1">// (let&#39;s also assume it&#39;s immutable and uses col-major layout for added challenge)</span>
<span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w">  </span><span class="n">data</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">1.f</span><span class="p">,</span><span class="w"> </span><span class="mf">2.f</span><span class="p">,</span><span class="w"> </span><span class="mf">3.f</span><span class="p">,</span><span class="w"> </span><span class="mf">4.f</span><span class="p">,</span><span class="w"> </span><span class="mf">5.f</span><span class="p">,</span><span class="w"> </span><span class="mf">6.f</span><span class="w"> </span><span class="p">};</span>
<span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">rows</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">cols</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>

<span class="c1">// Wrap data into MVL view and use it as a regular matrix</span>
<span class="n">mvl</span><span class="o">::</span><span class="n">ConstMatrixView</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="n">mvl</span><span class="o">::</span><span class="n">Checking</span><span class="o">::</span><span class="n">NONE</span><span class="p">,</span><span class="w"> </span><span class="n">mvl</span><span class="o">::</span><span class="n">Layout</span><span class="o">::</span><span class="n">CR</span><span class="o">&gt;</span><span class="w"> </span><span class="n">A</span><span class="p">(</span>
<span class="w">    </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="n">cols</span><span class="p">,</span><span class="w"> </span><span class="n">data</span>
<span class="p">);</span>

<span class="c1">// This makes MVL easily compatible with almost every 3rd party</span>
<span class="c1">// matrix library, views merely wrap around external data and expose</span>
<span class="c1">// MVL matrix functionality with no copying/conversion overhead</span>
</code></pre></div>
<h3 id="usage-with-utlmath">Usage with <code>utl::math</code><a class="headerlink" href="#usage-with-utlmath" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">utl</span><span class="p">;</span>

<span class="c1">// Create 7x7 identity matrix</span>
<span class="k">auto</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mvl</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="n">math</span><span class="o">::</span><span class="n">kronecker_delta</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">);</span>

<span class="c1">// Compute ||A||_inf norm</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">clone</span><span class="p">().</span><span class="n">transform</span><span class="p">(</span><span class="n">math</span><span class="o">::</span><span class="n">abs</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">).</span><span class="n">sum</span><span class="p">();</span>

<span class="c1">// Compute tr(A)</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">tr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">diagonal</span><span class="p">().</span><span class="n">sum</span><span class="p">();</span>

<span class="c1">// Split matrix into block views</span>
<span class="k">auto</span><span class="w"> </span><span class="n">upper_half</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">block</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">            </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">);</span>
<span class="k">auto</span><span class="w"> </span><span class="n">lower_half</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">block</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w">     </span><span class="p">);</span>

<span class="c1">// Set diagonal to { 1, 2, 3, ... , N }</span>
<span class="n">A</span><span class="p">.</span><span class="n">diagonal</span><span class="p">().</span><span class="n">for_each</span><span class="p">([](</span><span class="kt">double</span><span class="w"> </span><span class="o">&amp;</span><span class="n">elem</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="p">){</span><span class="w"> </span><span class="n">elem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>

<span class="c1">// Evenly mesh [0, PI] x [0, 2 PI] with 100 intervals on each side</span>
<span class="c1">// and save the 2D grid as a matrix</span>
<span class="k">using</span><span class="w"> </span><span class="n">vertex_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">auto</span><span class="w">  </span><span class="n">x</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">math</span><span class="o">::</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="w"> </span><span class="n">math</span><span class="o">::</span><span class="n">PI</span><span class="p">,</span><span class="w">     </span><span class="n">math</span><span class="o">::</span><span class="n">Intervals</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span>
<span class="k">auto</span><span class="w">  </span><span class="n">y</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">math</span><span class="o">::</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="w"> </span><span class="n">math</span><span class="o">::</span><span class="n">PI_TWO</span><span class="p">,</span><span class="w"> </span><span class="n">math</span><span class="o">::</span><span class="n">Intervals</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span>
<span class="k">auto</span><span class="w">  </span><span class="n">grid</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">mvl</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">vertex_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="n">y</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">j</span><span class="p">){</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">vertex_t</span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="p">});</span>
</code></pre></div>
<h3 id="working-with-images">Working with images<a class="headerlink" href="#working-with-images" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">utl</span><span class="p">;</span>

<span class="c1">// Raw image RGB data</span>
<span class="c1">// (outputted by most image decoders)</span>
<span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* ... */</span><span class="w"> </span><span class="p">};</span>
<span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w">   </span><span class="n">channels</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w">   </span><span class="n">w</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="mi">300</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w">   </span><span class="n">h</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="mi">200</span><span class="p">;</span>

<span class="c1">// View into R-G-B channels of an image as individual matrices</span>
<span class="n">mvl</span><span class="o">::</span><span class="n">ConstStridedMatrixView</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">R</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">channels</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="n">mvl</span><span class="o">::</span><span class="n">ConstStridedMatrixView</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">G</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">channels</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="n">mvl</span><span class="o">::</span><span class="n">ConstStridedMatrixView</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">B</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">channels</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>

<span class="c1">// Convert image to grayscale using linear formula</span>
<span class="n">mvl</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">grayscale</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">j</span><span class="p">){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mf">0.2126</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">R</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w">  </span><span class="o">+</span><span class="w"> </span><span class="mf">0.7152</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">G</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">0.0722</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">B</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div>
<h3 id="working-with-sparse-matrices">Working with sparse matrices<a class="headerlink" href="#working-with-sparse-matrices" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">utl</span><span class="p">;</span>

<span class="c1">// Create sparse matrix from triplets</span>
<span class="n">mvl</span><span class="o">::</span><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span>
<span class="p">});</span>

<span class="c1">// Check that sparse matrix contains an element</span>
<span class="n">assert</span><span class="p">(</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">contains_index</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">true</span><span class="w">  </span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">contains_index</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="p">);</span>

<span class="c1">// Convert sparse matrix to dense</span>
<span class="n">mvl</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w">        </span><span class="n">dense_A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">;</span>
<span class="c1">// Convert dense matrix to sparse</span>
<span class="n">mvl</span><span class="o">::</span><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">sparse_A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dense_A</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span>
<span class="w">    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">## A (sparse) ##</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="w">                    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">mvl</span><span class="o">::</span><span class="n">format</span><span class="o">::</span><span class="n">as_matrix</span><span class="p">(</span><span class="w">       </span><span class="n">A</span><span class="p">)</span>
<span class="w">    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">## A (sparse converted to dense) ##</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">mvl</span><span class="o">::</span><span class="n">format</span><span class="o">::</span><span class="n">as_matrix</span><span class="p">(</span><span class="w"> </span><span class="n">dense_A</span><span class="p">)</span>
<span class="w">    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">## A (dense converted to sparse) ##</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">mvl</span><span class="o">::</span><span class="n">format</span><span class="o">::</span><span class="n">as_matrix</span><span class="p">(</span><span class="n">sparse_A</span><span class="p">);</span>
</code></pre></div>
<p>Output:
<div class="highlight"><pre><span></span><code>## A (sparse) ##

Tensor [size = 3] (3 x 3):
  [ 1 - - ]
  [ - 2 - ]
  [ - - 3 ]

## A (sparse converted to dense) ##

Tensor [size = 9] (3 x 3):
  [ 1 0 0 ]
  [ 0 2 0 ]
  [ 0 0 3 ]

## A (dense converted to sparse) ##

Tensor [size = 3] (3 x 3):
  [ 1 - - ]
  [ - 2 - ]
  [ - - 3 ]
</code></pre></div></p>
<h2 id="roadmap-for-v100-release">Roadmap for v1.0.0 release<a class="headerlink" href="#roadmap-for-v100-release" title="Permanent link">&para;</a></h2>
<ul>
<li>Allow usage of static matrix extents</li>
<li>Vector specializations</li>
<li>Sparse matrices with a different "default element"</li>
<li>Binary element-wise operators <code>+</code>, <code>-</code>, <code>*</code>, <code>+=</code>, <code>-=</code>, <code>*=</code> and etc.</li>
<li>Matrix multiplication</li>
<li>Matrix concatenation</li>
<li>Additional algorithms: <code>sample()</code>, <code>shuffle()</code>, <code>clamp()</code> and etc.</li>
<li>Benchmarks</li>
</ul>







  
  






                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy; 20232025 Dmitri Bogdanov
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
        
<div class="md-social">
  
    
    
    
    
      
      
    
    <a href="https://github.com/DmitriBogdanov" target="_blank" rel="noopener" title="github.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": ".", "features": ["toc.follow", "content.code.copy", "search.suggest", "content.tooltips"], "search": "assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="assets/javascripts/bundle.f55a23d4.min.js"></script>
      
        <script src="mkdocs/mathjax.js"></script>
      
        <script src="https://unpkg.com/mathjax@3/es5/tex-mml-chtml.js"></script>
      
        <script src="mkdocs/modification/header_title.js"></script>
      
        <script src="mkdocs/modification/relative_links.js"></script>
      
    
  </body>
</html>