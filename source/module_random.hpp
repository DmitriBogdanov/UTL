// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DmitriBogdanov/prototyping_utils ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Module:        utl::random
// Documentation: https://github.com/DmitriBogdanov/prototyping_utils/blob/master/docs/module_random.md
// Source repo:   https://github.com/DmitriBogdanov/prototyping_utils
//
// This project is licensed under the MIT License
//
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


#if !defined(UTL_PICK_MODULES) || defined(UTLMODULE_RANDOM)
#ifndef UTLHEADERGUARD_RANDOM
#define UTLHEADERGUARD_RANDOM

// _______________________ INCLUDES _______________________

#include <cstdint>          // uint64_t
#include <ctime>            // time()
#include <initializer_list> // initializer_list<>
#include <limits>           // numeric_limits<>::digits, numeric_limits<>::min(), numeric_limits<>::max()
#include <random>           // random_device, std::uniform_int_distribution<>,
                            // std::uniform_real_distribution<>, generate_canonical<>
#include <array>            // array<>

#include <iostream>

// ____________________ DEVELOPER DOCS ____________________

// Implements a proper modern PRNG engine, compatible with std <random>.
// Adds 'sensible std <random> wrappers' for people who aren't fond of writing
// 3 lines code just to get a simple rand value.
//
// # XorShift64StarGenerator #
// Random 'std::uint64_t' generator that satisfies uniform random number generator requirements
// from '<random>' (see https://en.cppreference.com/w/cpp/named_req/UniformRandomBitGenerator).
// Implementation "XorShift64* suggested by Marsaglia G. in 2003 "Journal of Statistical Software"
// (see https://www.jstatsoft.org/article/view/v008i14).
// Slightly faster than 'std::rand()', while providing higher quality random.
// Significantly faster than 'std::mt19937'.
// State consists of a single 'std::uint64_t', requires seed >= 1.
//
// # xorshift64star #
// Global instance of XorShift64StarGenerator.
//
// # ::seed(), ::seed_with_time(), ::seed_with_random_device() #
// Seeds random with value/current_time/random_device.
// Random device is a better source of entropy, however it's more expensive to initialize
// than just taking current time with <ctime>, in some cases a "worse by lightweigh" can
// be prefered.
//
// # ::rand_int(), ::rand_uint(), ::rand_float(), ::rand_double() #
// Random value in [min, max] range.
// Floats with no parameters assume range [0, 1].
//
// # ::rand_bool() #
// Randomly chooses 0 or 1.
//
// # ::rand_choise() #
// Randomly chooses a value from initializer list.
//
// # ::rand_linear_combination() #
// Produces "c A + (1-c) B" with random "0 < c < 1" assuming objects "A", "B" support arithmetic operations.
// Useful for vector and color operations.

// ____________________ IMPLEMENTATION ____________________

namespace utl::random {

// =========================
// --- Random Generators ---
// =========================

// Implementation of several "good" PRNGS.
//
// All generators meets uniform random number generator requirements
// (see https://en.cppreference.com/w/cpp/named_req/UniformRandomBitGenerator)

// --- Implementation utils ---
// ----------------------------

// A 'lightweight' PRNG used by some other engines to initialize their state
constexpr std::uint32_t _splitmix32(std::uint32_t state) noexcept {
    uint32_t result = (state += 0x9e3779b9);
    result          = (result ^ (result >> 16)) * 0x21f0aaad;
    result          = (result ^ (result >> 15)) * 0x735a2d97;
    return result ^ (result >> 15);
}

constexpr std::uint64_t _splitmix64(std::uint64_t state) noexcept {
    std::uint64_t result = (state += 0x9E3779B97f4A7C15);
    result               = (result ^ (result >> 30)) * 0xBF58476D1CE4E5B9;
    result               = (result ^ (result >> 27)) * 0x94D049BB133111EB;
    return result ^ (result >> 31);
}

template <class T>
[[nodiscard]] constexpr T _rotl(T x, int k) noexcept {
    return (x << k) | (x >> (std::numeric_limits<T>::digits - k));
}
// this implementation gets standardized in C++20 as 'std::rotl()'

template <class T>
constexpr T _default_seed = std::numeric_limits<T>::max() / 2;
// an "overall decent" default seed - doesn't gave too many zeroes,
// unlikely to accidentaly match with a user-defined seed

template <class T>
[[nodiscard]] constexpr T _ensure_nonzero(T value) noexcept {
    return (value) ? value : _default_seed<T> + 1;
}
// some generators shouldn't be zero initialized, in a perfect world the user would never
// do that, but in case they happened to do so regardless we can remap 0 to some "weird"
// value that isn't like to intersect with any other seeds generated by the user. Rejecting
// zero seeds completely wouldn't be appropriate for compatibility reasons.

// --- Generators ---
// ------------------

// Note:
// As of C++17 there is little point in declaring generator constructors and methods as 'constexpr',
// however in newer standards it would allow PRNGs to be used in constexpr context.
//
// Unfortunately, we can't do the same for "convenient random functions"
// since  they use std distributions which have no constexpr.

namespace generators {

// Implementation of 32-bit Romu Trio engine from paper by "Mark A. Overton",
// see https://www.romu-random.org/
//     https://www.romu-random.org/romupaper.pdf
//
// Performance: Excellent
// Quality:     3/5
// State:       16 bytes
//
// Not the best one for general use, but provides bleeding edge performance.
// Depending on 32/64-bit CPU instruction set can lead to huge speedup.
//
class RomuTrio32 {
public:
    using result_type = std::uint32_t;

private:
    std::array<result_type, 3> s{};

public:
    constexpr explicit RomuTrio32(result_type seed = _default_seed<result_type>) noexcept { this->seed(seed); }

    [[nodiscard]] static constexpr result_type min() noexcept { return std::numeric_limits<result_type>::min(); }
    [[nodiscard]] static constexpr result_type max() noexcept { return std::numeric_limits<result_type>::max(); }

    constexpr void seed(result_type seed) noexcept {
        std::uint64_t splitmix32_state = _ensure_nonzero(seed); // RomuDuoJr shouln't be zero-initialized
        this->s[0]                     = _splitmix32(splitmix32_state);
        this->s[1]                     = _splitmix32(splitmix32_state);
        // Like Xoshiro, Romu recommends using SplitMix32 to initialize its state
    }

    constexpr result_type operator()() noexcept {
        const result_type xp = this->s[0], yp = this->s[1], zp = this->s[2];
        this->s[0] = 3323815723u * zp;
        this->s[1] = yp - xp;
        this->s[1] = _rotl(this->s[1], 6);
        this->s[2] = zp - yp;
        this->s[2] = _rotl(this->s[2], 22);
        return xp;
    }
};

// Implementation of Romu DuoJr engine from paper by "Mark A. Overton",
// see https://www.romu-random.org/
//     https://www.romu-random.org/romupaper.pdf
//
// Performance: Excellent
// Quality:     3/5
// State:       16 bytes
//
// Not the best one for general use, but provides bleeding edge performance.
//
class RomuDuoJr {
public:
    using result_type = std::uint64_t;

private:
    std::array<result_type, 2> s{};

public:
    constexpr explicit RomuDuoJr(result_type seed = _default_seed<result_type>) noexcept { this->seed(seed); }

    [[nodiscard]] static constexpr result_type min() noexcept { return std::numeric_limits<result_type>::min(); }
    [[nodiscard]] static constexpr result_type max() noexcept { return std::numeric_limits<result_type>::max(); }

    constexpr void seed(result_type seed) noexcept {
        result_type splitmix64_state = _ensure_nonzero(seed); // RomuDuoJr shouln't be zero-initialized
        this->s[0]                   = _splitmix64(splitmix64_state);
        this->s[1]                   = _splitmix64(splitmix64_state);
        // Like Xoshiro, Romu recommends using SplitMix64 to initialize its state
    }

    constexpr result_type operator()() noexcept {
        const result_type res = this->s[0];
        this->s[0]            = 15241094284759029579u * this->s[1];
        this->s[1]            = this->s[1] - res;
        this->s[1]            = _rotl(this->s[1], 27);
        return res;
    }
};

// Implementation of 32-bit Bob Jenkins' small prng ,
// see https://burtleburtle.net/bob/rand/smallprng.html
//     https://gist.github.com/imneme/85cff47d4bad8de6bdeb671f9c76c814
//
// Performance: Excellent
// Quality:     3/5
// State:       16 bytes
//
// Not the best one for general use, but provides bleeding edge performance.
// Depending on 32/64-bit CPU instruction set can lead to huge speedup.
//
class JSF32 {
public:
    using result_type = std::uint32_t;

private:
    std::array<result_type, 4> s{};

public:
    constexpr explicit JSF32(result_type seed = _default_seed<result_type>) noexcept { this->seed(seed); }

    [[nodiscard]] static constexpr result_type min() noexcept { return std::numeric_limits<result_type>::min(); }
    [[nodiscard]] static constexpr result_type max() noexcept { return std::numeric_limits<result_type>::max(); }

    constexpr void seed(result_type seed) noexcept {
        this->s[0] = 0xf1ea5eed;
        this->s[1] = this->s[2] = this->s[3] = _ensure_nonzero(seed);
        // JSF shouln't struggle with zero-seeding but just in case
        for (int i = 0; i < 20; ++i) static_cast<void>(this->operator()());
    }

    constexpr result_type operator()() noexcept {
        const result_type e = this->s[0] - _rotl(this->s[1], 27);
        this->s[0]          = this->s[1] ^ _rotl(this->s[2], 17);
        this->s[1]          = this->s[2] + this->s[3];
        this->s[2]          = this->s[3] + e;
        this->s[3]          = e + this->s[0];
        return this->s[3];
    }
};

// Implementation of 64-bit Bob Jenkins' small prng ,
// see https://burtleburtle.net/bob/rand/smallprng.html
//     https://gist.github.com/imneme/85cff47d4bad8de6bdeb671f9c76c814
//
// Performance: Excellent
// Quality:     4/5
// State:       32 bytes
//
// Excellent choise as a general purpose PRNG.
// Lack theoretical proof for period length, but brute-force testing indicates >= 2^64.
//
class JSF64 {
public:
    using result_type = std::uint64_t;

private:
    std::array<result_type, 4> s{};

public:
    constexpr explicit JSF64(result_type seed = _default_seed<result_type>) noexcept { this->seed(seed); }

    [[nodiscard]] static constexpr result_type min() noexcept { return std::numeric_limits<result_type>::min(); }
    [[nodiscard]] static constexpr result_type max() noexcept { return std::numeric_limits<result_type>::max(); }

    constexpr void seed(result_type seed) noexcept {
        this->s[0] = 0xf1ea5eed;
        this->s[1] = this->s[2] = this->s[3] = _ensure_nonzero(seed);
        // JSF shouln't struggle with zero-seeding but just in case
        for (int i = 0; i < 20; ++i) static_cast<void>(this->operator()());
    }

    constexpr result_type operator()() noexcept {
        const result_type e = this->s[0] - _rotl(this->s[1], 7);
        this->s[0]          = this->s[1] ^ _rotl(this->s[2], 13);
        this->s[1]          = this->s[2] + _rotl(this->s[3], 37);
        this->s[2]          = this->s[3] + e;
        this->s[3]          = e + this->s[0];
        return this->s[3];
    }
};

// Implementation of Xoshiro256++ suggested by David Blackman and Sebastiano Vigna,
// see https://prng.di.unimi.it/
//     https://prng.di.unimi.it/xoshiro256plusplus.c
//
// Performance: Excellent
// Quality:     4/5
// State:       32 bytes
//
// Excellent choise as a general purpose PRNG.
// Used by several modern languages as their default.
//
class Xoshiro256PlusPlus {
public:
    using result_type = std::uint64_t;

private:
    std::array<result_type, 4> s{};

public:
    constexpr explicit Xoshiro256PlusPlus(result_type seed = _default_seed<result_type>) noexcept { this->seed(seed); }

    [[nodiscard]] static constexpr result_type min() noexcept { return std::numeric_limits<result_type>::min(); }
    [[nodiscard]] static constexpr result_type max() noexcept { return std::numeric_limits<result_type>::max(); }

    constexpr void seed(result_type seed) noexcept {
        result_type splitmix64_state = _ensure_nonzero(seed); // Xoshiro256++ shouln't be zero-initialized
        this->s[0]                   = _splitmix64(splitmix64_state);
        this->s[1]                   = _splitmix64(splitmix64_state);
        this->s[2]                   = _splitmix64(splitmix64_state);
        this->s[3]                   = _splitmix64(splitmix64_state);
    }

    constexpr result_type operator()() noexcept {
        const result_type result = _rotl(this->s[0] + this->s[3], 23) + this->s[0];
        const result_type t      = this->s[1] << 17;
        this->s[2] ^= this->s[0];
        this->s[3] ^= this->s[1];
        this->s[1] ^= this->s[2];
        this->s[0] ^= this->s[3];
        this->s[2] ^= t;
        this->s[3] = _rotl(this->s[3], 45);
        return result;
    }
};

// Implementation XorShift64* suggested by Marsaglia G. in 2003 "Journal of Statistical Software",
// see https://www.jstatsoft.org/article/view/v008i14
//     https://en.wikipedia.org/wiki/Xorshift
//
// Performance: Good
// Quality:     4/5
// State:       8 bytes
//
// Generally overshadowed by newer PRNGs in quality & performance,
// however it still quite good and seems to be among we can get at just 8 bytes of state.
//
class Xorshift64Star {
public:
    using result_type = std::uint64_t;

private:
    result_type s{};

public:
    constexpr explicit Xorshift64Star(result_type seed = _default_seed<result_type>) noexcept { this->seed(seed); }

    [[nodiscard]] static constexpr result_type min() noexcept { return std::numeric_limits<result_type>::min(); }
    [[nodiscard]] static constexpr result_type max() noexcept { return std::numeric_limits<result_type>::max(); }

    constexpr void seed(result_type seed) {
        this->s = _ensure_nonzero(seed); // XorShift64* shouln't be zero-initialized
    }

    constexpr result_type operator()() noexcept {
        this->s ^= this->s >> 12;
        this->s ^= this->s << 25;
        this->s ^= this->s >> 27;
        return this->s * 0x2545F4914F6CDD1DULL;
    }
};

} // namespace generators

// ===========================
// --- Default global PRNG ---
// ===========================

using default_generator_type = generators::Xoshiro256PlusPlus;
using default_result_type    = default_generator_type::result_type;

inline default_generator_type default_generator;

inline void seed(default_result_type random_seed) { default_generator.seed(random_seed); }

inline void seed_with_random_device() { utl::random::seed(static_cast<default_result_type>(std::random_device{}())); }

constexpr std::uint32_t cexpint() {
    generators::JSF32 gen;
    return gen();
}

// ========================
// --- Random Functions ---
// ========================

// Note 1:
// Despite the intuitive judgement, benchmarks don't seem to indicate that creating
// 'std::uniform_..._distribution<>' on each call introduces any noticeble overhead
//
// sizeof(std::uniform_int_distribution<int>) == 8
// sizeof(std::uniform_real_distribution<double>) == 16

// Note 2:
// No '[[nodiscard]]' since random functions inherently can't be pure due to advancing the generator state.
// Discarding return values while not very sensible, can still be done for the sake of advancing state.
// Ideally we would want users to advance the state directly, but I'm not sure how to communicate that in
// '[[nodiscard]]' warnings.

inline int rand_int(int min, int max) {
    std::uniform_int_distribution<int> distr{min, max};
    return distr(default_generator);
}

inline int rand_uint(unsigned int min, unsigned int max) {
    std::uniform_int_distribution<unsigned int> distr{min, max};
    return distr(default_generator);
}

inline float rand_float() {
    return std::generate_canonical<float, std::numeric_limits<float>::digits>(default_generator);
}

inline float rand_float(float min, float max) {
    std::uniform_real_distribution<float> distr{min, max};
    return distr(default_generator);
}

inline float rand_normal_float() {
    std::normal_distribution<float> distr;
    return distr(default_generator);
}

inline double rand_double() {
    return std::generate_canonical<double, std::numeric_limits<double>::digits>(default_generator);
}

inline double rand_double(double min, double max) {
    std::uniform_real_distribution<double> distr{min, max};
    return distr(default_generator);
}

inline double rand_normal_double() {
    std::normal_distribution<double> distr;
    return distr(default_generator);
}

inline bool rand_bool() { return static_cast<bool>(rand_uint(0, 1)); }

template <class T>
const T& rand_choise(std::initializer_list<T> objects) {
    const int random_index = rand_int(0, static_cast<int>(objects.size()) - 1);
    return objects.begin()[random_index];
}

template <class T>
T rand_linear_combination(const T& A, const T& B) { // random linear combination of 2 colors/vectors/etc
    const auto coef = rand_double();
    return A * coef + B * (1. - coef);
}

} // namespace utl::random

#endif
#endif // module utl::random
