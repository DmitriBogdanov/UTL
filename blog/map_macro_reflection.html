
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://dmitribogdanov.github.io/UTL/blog/map_macro_reflection.html">
      
      
        <link rel="prev" href="cpp_performance_issues.html">
      
      
        <link rel="next" href="../guide_license.html">
      
      
      <link rel="icon" href="../images/icon_site_logo.ico">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.22">
    
    
      
        <title>Map-macro: Emulating reflection - UTL</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.84d31ad4.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
        <script src="https://unpkg.com/iframe-worker/shim"></script>
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../mkdocs/callouts.css">
    
      <link rel="stylesheet" href="../mkdocs/width.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
      
        <meta  property="og:type"  content="website" >
      
        <meta  property="og:title"  content="Map-macro: Emulating reflection - UTL" >
      
        <meta  property="og:description"  content="None" >
      
        <meta  property="og:image"  content="https://dmitribogdanov.github.io/UTL/assets/images/social/blog/map_macro_reflection.png" >
      
        <meta  property="og:image:type"  content="image/png" >
      
        <meta  property="og:image:width"  content="1200" >
      
        <meta  property="og:image:height"  content="630" >
      
        <meta  property="og:url"  content="https://dmitribogdanov.github.io/UTL/blog/map_macro_reflection.html" >
      
        <meta  name="twitter:card"  content="summary_large_image" >
      
        <meta  name="twitter:title"  content="Map-macro: Emulating reflection - UTL" >
      
        <meta  name="twitter:description"  content="None" >
      
        <meta  name="twitter:image"  content="https://dmitribogdanov.github.io/UTL/assets/images/social/blog/map_macro_reflection.png" >
      
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="slate" data-md-color-primary="black" data-md-color-accent="light-blue">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#map-macro-emulating-reflection" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../index.html" title="UTL" class="md-header__button md-logo" aria-label="UTL" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m21.71 20.29-1.42 1.42a1 1 0 0 1-1.41 0L7 9.85A3.8 3.8 0 0 1 6 10a4 4 0 0 1-3.78-5.3l2.54 2.54.53-.53 1.42-1.42.53-.53L4.7 2.22A4 4 0 0 1 10 6a3.8 3.8 0 0 1-.15 1l11.86 11.88a1 1 0 0 1 0 1.41M2.29 18.88a1 1 0 0 0 0 1.41l1.42 1.42a1 1 0 0 0 1.41 0l5.47-5.46-2.83-2.83M20 2l-4 2v2l-2.17 2.17 2 2L18 8h2l2-4Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            UTL
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Map-macro: Emulating reflection
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="black" data-md-color-accent="light-blue"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5M7 15a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="deep-purple" data-md-color-accent="purple"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5m0 8a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
      <div class="md-header__source">
        <a href="https://github.com/DmitriBogdanov/UTL" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    DmitriBogdanov/UTL
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../index.html" title="UTL" class="md-nav__button md-logo" aria-label="UTL" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m21.71 20.29-1.42 1.42a1 1 0 0 1-1.41 0L7 9.85A3.8 3.8 0 0 1 6 10a4 4 0 0 1-3.78-5.3l2.54 2.54.53-.53 1.42-1.42.53-.53L4.7 2.22A4 4 0 0 1 10 6a3.8 3.8 0 0 1-.15 1l11.86 11.88a1 1 0 0 1 0 1.41M2.29 18.88a1 1 0 0 0 0 1.41l1.42 1.42a1 1 0 0 0 1.41 0l5.47-5.46-2.83-2.83M20 2l-4 2v2l-2.17 2.17 2 2L18 8h2l2-4Z"/></svg>

    </a>
    UTL
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/DmitriBogdanov/UTL" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    DmitriBogdanov/UTL
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../index.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Home
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Modules
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Modules
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../module_assertion.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utl::assertion
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../module_bit.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utl::bit
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../module_enum_reflect.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utl::enum_reflect
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../module_integral.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utl::integral
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../module_json.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utl::json
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../module_log.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utl::log
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../module_math.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utl::math
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../module_mvl.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utl::mvl
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../module_parallel.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utl::parallel
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../module_predef.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utl::predef
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../module_profiler.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utl::profiler
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../module_progressbar.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utl::progressbar
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../module_random.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utl::random
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../module_shell.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utl::shell
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../module_sleep.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utl::sleep
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../module_stre.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utl::stre
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../module_strong_type.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utl::strong_type
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../module_struct_reflect.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utl::struct_reflect
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../module_table.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utl::table
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../module_time.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utl::time
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Guides
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            Guides
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide_selecting_modules.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Selecting modules
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide_fetching_library.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Fetching the library
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide_reserved_names.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Reserved names
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide_building_project.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Building the repo
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide_building_docs.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Building documentation
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide_versioning.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Semantic versioning
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide_reproducing_figures.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Reproducing figures
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" checked>
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Blog
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            Blog
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="cpp_performance_issues.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    What separates C++ from being a "perfect" performance-oriented language
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    Map-macro: Emulating reflection
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="map_macro_reflection.html" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    Map-macro: Emulating reflection
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#enum-reflection" class="md-nav__link">
    <span class="md-ellipsis">
      enum reflection
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#struct-reflection" class="md-nav__link">
    <span class="md-ellipsis">
      struct reflection
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#some-examples" class="md-nav__link">
    <span class="md-ellipsis">
      Some examples
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Some examples">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#debug-printing" class="md-nav__link">
    <span class="md-ellipsis">
      Debug printing
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#binary-operators" class="md-nav__link">
    <span class="md-ellipsis">
      Binary operators
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#generic-functions-that-operate-on-struct-members" class="md-nav__link">
    <span class="md-ellipsis">
      Generic functions that operate on struct members
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#advanced-examples" class="md-nav__link">
    <span class="md-ellipsis">
      Advanced examples
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#why-use-this-over-boostpfr-or-boostdescribe" class="md-nav__link">
    <span class="md-ellipsis">
      Why use this over Boost.PFR or Boost.Describe
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#why-use-boostpfr-or-boostdescribe-over-this" class="md-nav__link">
    <span class="md-ellipsis">
      Why use Boost.PFR or Boost.Describe over this
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#map-macro-implementation" class="md-nav__link">
    <span class="md-ellipsis">
      Map-macro implementation
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#alternative-approaches-for-enum-reflection" class="md-nav__link">
    <span class="md-ellipsis">
      Alternative approaches for enum reflection
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#alternative-approaches-for-struct-reflection" class="md-nav__link">
    <span class="md-ellipsis">
      Alternative approaches for struct reflection
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#related-libraries" class="md-nav__link">
    <span class="md-ellipsis">
      Related libraries
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../guide_license.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    License
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#enum-reflection" class="md-nav__link">
    <span class="md-ellipsis">
      enum reflection
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#struct-reflection" class="md-nav__link">
    <span class="md-ellipsis">
      struct reflection
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#some-examples" class="md-nav__link">
    <span class="md-ellipsis">
      Some examples
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Some examples">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#debug-printing" class="md-nav__link">
    <span class="md-ellipsis">
      Debug printing
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#binary-operators" class="md-nav__link">
    <span class="md-ellipsis">
      Binary operators
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#generic-functions-that-operate-on-struct-members" class="md-nav__link">
    <span class="md-ellipsis">
      Generic functions that operate on struct members
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#advanced-examples" class="md-nav__link">
    <span class="md-ellipsis">
      Advanced examples
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#why-use-this-over-boostpfr-or-boostdescribe" class="md-nav__link">
    <span class="md-ellipsis">
      Why use this over Boost.PFR or Boost.Describe
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#why-use-boostpfr-or-boostdescribe-over-this" class="md-nav__link">
    <span class="md-ellipsis">
      Why use Boost.PFR or Boost.Describe over this
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#map-macro-implementation" class="md-nav__link">
    <span class="md-ellipsis">
      Map-macro implementation
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#alternative-approaches-for-enum-reflection" class="md-nav__link">
    <span class="md-ellipsis">
      Alternative approaches for enum reflection
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#alternative-approaches-for-struct-reflection" class="md-nav__link">
    <span class="md-ellipsis">
      Alternative approaches for struct reflection
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#related-libraries" class="md-nav__link">
    <span class="md-ellipsis">
      Related libraries
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  
  


<h1 id="map-macro-emulating-reflection">Map-macro: emulating reflection<a class="headerlink" href="#map-macro-emulating-reflection" title="Permanent link">&para;</a></h1>
<p>Recently I've come across a <a href="#map-macro-implementation">very curios macro</a>, let's call it <code>MAP</code>:
<div class="highlight"><pre><span></span><code><span class="cp">#define MAP(f, ...) </span><span class="cm">/* &lt;some preprocessor magic&gt; */</span>
</code></pre></div>
Let's also say we have a macro <code>F</code> that takes one argument:
<div class="highlight"><pre><span></span><code><span class="cp">#define F(arg) </span><span class="cm">/* &lt;some logic&gt; */</span>
</code></pre></div>
A map-macro allows us to map this function-like macro to a variadic list of arguments, for example
<div class="highlight"><pre><span></span><code><span class="n">MAP</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">)</span>
</code></pre></div>
will be evaluate to
<div class="highlight"><pre><span></span><code><span class="n">F</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">F</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="n">F</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="n">F</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
</code></pre></div>
Using a similar principle, it is also possible to make a <code>MAP_LIST</code> macro which adds commas between the results, which means <code>MAP_LIST(F, a, b, c, d)</code> will evaluate to</p>
<div class="highlight"><pre><span></span><code><span class="n">F</span><span class="p">(</span><span class="n">a</span><span class="p">),</span><span class="w"> </span><span class="n">F</span><span class="p">(</span><span class="n">b</span><span class="p">),</span><span class="w"> </span><span class="n">F</span><span class="p">(</span><span class="n">c</span><span class="p">),</span><span class="w"> </span><span class="n">F</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
</code></pre></div>
<p>The implementation of this macro is attached at the <a href="#map-macro-implementation">end</a>, a rather nice explanation of how it works can be found in <a href="https://github.com/swansontec/map-macro">this repo</a>.</p>
<p>Now, one could spend plenty of time figuring out all the preprocessor magic behind the macro, but what I believe is a more important question is: <strong>"What does this give us?"</strong>. From my perspective — an almost perfect tool to implement codegen macros for reflection.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Strictly speaking, we will be dealing with a way of providing types with non-intrusive introspection metadata, rather than a proper reflection. A battle-tested implementation of this mechanism is provided <a href="https://github.com/boostorg/describe">Boost.Describe</a>, since the end goals are the same the term "reflection" will be used for conciseness.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Ultimately, proper reflection can only be supported at the language level, everything we do before C++26 is trying to bolt-in a language feature using various workarounds.</p>
</div>
<h2 id="enum-reflection"><code>enum</code> reflection<a class="headerlink" href="#enum-reflection" title="Permanent link">&para;</a></h2>
<p>Let's first establish what do we even want from an <code>enum</code> reflection. The main things people usually wish for are:</p>
<ul>
<li>Enum &lt;-&gt; string conversion</li>
<li>Ability to access enumeration elements like an array</li>
</ul>
<p>This means that minimally we want to achieve an API like this:
<div class="highlight"><pre><span></span><code><span class="k">enum</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Side</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">LEFT</span><span class="p">,</span><span class="w"> </span><span class="n">RIGHT</span><span class="w"> </span><span class="p">};</span>

<span class="c1">// ...</span>

<span class="k">static_assert</span><span class="p">(</span><span class="w"> </span><span class="n">to_string</span><span class="p">(</span><span class="n">Side</span><span class="o">::</span><span class="n">LEFT</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;LEFT&quot;</span><span class="w"> </span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="w"> </span><span class="n">from_string</span><span class="o">&lt;</span><span class="n">Side</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;LEFT&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Side</span><span class="o">::</span><span class="n">LEFT</span><span class="w"> </span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="w"> </span><span class="n">size</span><span class="o">&lt;</span><span class="n">Side</span><span class="o">&gt;</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="w"> </span><span class="n">values</span><span class="o">&lt;</span><span class="n">Side</span><span class="o">&gt;</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Side</span><span class="o">::</span><span class="n">LEFT</span><span class="w"> </span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="w"> </span><span class="n">values</span><span class="o">&lt;</span><span class="n">Side</span><span class="o">&gt;</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Side</span><span class="o">::</span><span class="n">RIGHT</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
A map macro makes this almost trivial! All we need is to register enum with a macro:
<div class="highlight"><pre><span></span><code><span class="n">REFLECT_ENUM</span><span class="p">(</span><span class="n">Side</span><span class="p">,</span><span class="w"> </span><span class="n">LEFT</span><span class="p">,</span><span class="w"> </span><span class="n">RIGHT</span><span class="p">)</span>
</code></pre></div>
and have that macro forward our stringified <code>__VA_ARGS__</code> into arrays of names and values. While we're at it let's also create array of name-value pairs — this will make iteration more convenient.</p>
<p>Using template specialization as a mechanism for registering types we can do following:
<div class="highlight"><pre><span></span><code><span class="c1">// Declare base template that cannot be instantiated</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Enum</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">meta</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">static_assert</span><span class="p">(</span><span class="n">always_false_v</span><span class="o">&lt;</span><span class="n">Enum</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Enum has no reflection&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Define macros that we&#39;re gonna apply with MAP</span>
<span class="cp">#define MAKE_NAME( arg) std::string_view(#arg)</span>
<span class="cp">#define MAKE_VALUE(arg) type::arg</span>
<span class="cp">#define MAKE_ENTRY(arg) std::pair{ std::string_view(#arg), type::arg }</span>

<span class="c1">// Declare specialized template with enum metadata</span>
<span class="cp">#define REFLECT_ENUM(enum_name, ...)                                          \</span>
<span class="cp">template &lt;&gt;                                                                   \</span>
<span class="cp">struct meta&lt;enum_name&gt; {                                                      \</span>
<span class="cp">    using type             = enum_name;                                       \</span>
<span class="cp">    constexpr auto names   = std::array{ MAP_LIST(MAKE_NAME,  __VA_ARGS__) }; \</span>
<span class="cp">    constexpr auto values  = std::array{ MAP_LIST(MAKE_VALUE, __VA_ARGS__) }; \</span>
<span class="cp">    constexpr auto entries = std::array{ MAP_LIST(MAKE_VALUE, __VA_ARGS__) }; \</span>
<span class="cp">}</span>
</code></pre></div>
At this point the trickiest part of the task is basically done — string conversion is just a matter of doing an array lookup for a corresponding type:
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Enum</span><span class="o">&gt;</span>
<span class="k">constexpr</span><span class="w"> </span><span class="n">to_string</span><span class="p">(</span><span class="n">Enum</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="p">[</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">meta</span><span class="o">&lt;</span><span class="n">Enum</span><span class="o">&gt;::</span><span class="n">entries</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">out_of_range</span><span class="p">(</span><span class="s">&quot;Value is not a part of enum.&quot;</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Enum</span><span class="o">&gt;</span>
<span class="k">constexpr</span><span class="w"> </span><span class="n">from_string</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="w"> </span><span class="n">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="p">[</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">meta</span><span class="o">&lt;</span><span class="n">Enum</span><span class="o">&gt;::</span><span class="n">entries</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">str</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">out_of_range</span><span class="p">(</span><span class="s">&quot;String does not correspond to a value in enum.&quot;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></p>
<p>while the rest can be just trivially wrapped in a public API:</p>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Enum</span><span class="o">&gt;</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">names</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">meta</span><span class="o">&lt;</span><span class="n">Enum</span><span class="o">&gt;::</span><span class="n">names</span><span class="p">;</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Enum</span><span class="o">&gt;</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">values</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">meta</span><span class="o">&lt;</span><span class="n">Enum</span><span class="o">&gt;::</span><span class="n">values</span><span class="p">;</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Enum</span><span class="o">&gt;</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">entries</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">meta</span><span class="o">&lt;</span><span class="n">Enum</span><span class="o">&gt;::</span><span class="n">entries</span><span class="p">;</span>
</code></pre></div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A more performant option for large enums would be to build a static map in addition to arrays and use it to perform <code>O(1)</code> lookup during string conversion, however that falls under "implementation details". Using a map also makes it more difficult to provide functions as <code>constexpr</code>.</p>
</div>
<p>A "clean" implementation including all of this and some other convenient functions is provided by <strong>utl::enum_reflect</strong> header which can be found <a href="../module_enum_reflect.html">here</a>.</p>
<h2 id="struct-reflection"><code>struct</code> reflection<a class="headerlink" href="#struct-reflection" title="Permanent link">&para;</a></h2>
<p>Same as before, let's first identify the basic goals we want to achieve, usually people wish to:</p>
<ul>
<li>Treat structures like tuples</li>
<li>"Iterate" over struct members</li>
<li>Use the above to implement generic ways to serialize / parse / compare structs.</li>
</ul>
<p>In short, we want to achieve something like this:</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">Config</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">date</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w">      </span><span class="n">coef</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">REFLECT_STRUCT</span><span class="p">(</span><span class="n">Config</span><span class="p">,</span><span class="w"> </span><span class="n">date</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">coef</span><span class="p">);</span>

<span class="c1">// Name reflection</span>
<span class="k">static_assert</span><span class="p">(</span><span class="w"> </span><span class="n">size</span><span class="o">&lt;</span><span class="n">Config</span><span class="o">&gt;</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">);</span>

<span class="k">static_assert</span><span class="p">(</span><span class="w"> </span><span class="n">names</span><span class="o">&lt;</span><span class="n">Config</span><span class="o">&gt;</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;date&quot;</span><span class="w"> </span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="w"> </span><span class="n">names</span><span class="o">&lt;</span><span class="n">Config</span><span class="o">&gt;</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;size&quot;</span><span class="w"> </span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="w"> </span><span class="n">names</span><span class="o">&lt;</span><span class="n">Config</span><span class="o">&gt;</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;coef&quot;</span><span class="w"> </span><span class="p">);</span>

<span class="c1">// Iterate members with a visitor function</span>
<span class="n">Config</span><span class="w"> </span><span class="n">cfg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;2025.03.21&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">127</span><span class="p">,</span><span class="w"> </span><span class="mf">0.5</span><span class="w"> </span><span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;struct contents = </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="n">for_each</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span><span class="w"> </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">field</span><span class="p">){</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">field</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>

<span class="c1">// Access struct like a tuple</span>
<span class="n">assert</span><span class="p">(</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cfg</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;2025.03.21&quot;</span><span class="w"> </span><span class="p">);</span>

<span class="c1">// Treat whole struct as a tuple</span>
<span class="k">auto</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">field_view</span><span class="p">(</span><span class="n">cfg</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tuple</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;2025.03.21&quot;</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The are obliviously some other convenient things we would want such as <code>entry_view()</code> for name-value pairs, ability to use <code>for_each()</code> to define binary operators, predicates and etc. All of this will be provided in the implementation linked at the end.</p>
</div>
<p>Same as with <code>enum</code>, we can forward stringified <code>__VA_ARGS__</code> from register macro and use them to build up a partial specialization with some metadata:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Declare base template that cannot be instantiated</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Struct</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">meta</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">static_assert</span><span class="p">(</span><span class="n">_always_false_v</span><span class="o">&lt;</span><span class="n">Struct</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Struct has no reflection.&quot;</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">// Define macros that we&#39;re gonna apply with MAP</span>
<span class="cp">#define MAKE_NAME( arg) std::string_view(arg)</span>
<span class="cp">#define MAKE_VALUE(arg) std::forward&lt;Struct&gt;(value).arg</span>
<span class="cp">#define CALL_FUNC( arg) func(std::forward&lt;Struct&gt;(value).arg);</span>

<span class="c1">// Declare specialized template with struct metadata</span>
<span class="cp">#define REFLECT_STRUCT(struct_name, ...)                                   \</span>
<span class="cp">template &lt;&gt;                                                                \</span>
<span class="cp">struct meta&lt;struct_name&gt; {                                                 \</span>
<span class="cp">    constexpr auto names = std::array{ MAP_LIST(MAKE_NAME, __VA_ARGS__) }; \</span>
<span class="cp">                                                                           \</span>
<span class="cp">    template &lt;class Struct&gt;                                                \</span>
<span class="cp">    constexpr static auto field_view(Struct&amp;&amp; value) noexcept {            \</span>
<span class="cp">        return std::forward_as_tuple(MAP_LIST(MAKE_VALUE, __VA_ARGS__));   \</span>
<span class="cp">    }                                                                      \</span>
<span class="cp">                                                                           \</span>
<span class="cp">    template &lt;class Struct, class Func&gt;                                    \</span>
<span class="cp">    constexpr static void for_each(Struct&amp;&amp; value, Func&amp;&amp; func) {          \</span>
<span class="cp">        MAP(CALL_FUNC, __VA_ARGS__)                                        \</span>
<span class="cp">    }                                                                      \</span>
<span class="cp">}</span>
</code></pre></div>
<p>After this a public API can trivially wrap the calls to metadata:</p>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Struct</span><span class="o">&gt;</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">names</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">meta</span><span class="o">&lt;</span><span class="n">Struct</span><span class="o">&gt;::</span><span class="n">names</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Struct</span><span class="o">&gt;</span>
<span class="k">constexpr</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">field_view</span><span class="p">(</span><span class="n">Struct</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">struct_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="n">Struct</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">meta</span><span class="o">&lt;</span><span class="n">struct_type</span><span class="o">&gt;::</span><span class="n">field_view</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Struct</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Struct</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Func</span><span class="o">&gt;</span>
<span class="k">constexpr</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">for_each</span><span class="p">(</span><span class="n">Struct</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">Func</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">func</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">struct_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="n">Struct</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">    </span><span class="n">meta</span><span class="o">&lt;</span><span class="n">struct_type</span><span class="o">&gt;::</span><span class="n">for_each</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Struct</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Func</span><span class="o">&gt;</span><span class="p">(</span><span class="n">func</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">I</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Struct</span><span class="o">&gt;</span>
<span class="k">constexpr</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">get</span><span class="p">(</span><span class="n">Struct</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">(</span><span class="n">field_view</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Struct</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">)));</span>
<span class="p">}</span>
</code></pre></div>
<p>An there it is, we have all the basic building blocks of a proper reflection!</p>
<p>A "clean" implementation including all of this and some other convenient functions is provided by <strong>utl::struct_reflect</strong> header which can be found <a href="../module_struct_reflect.html">here</a>.</p>
<h2 id="some-examples">Some examples<a class="headerlink" href="#some-examples" title="Permanent link">&para;</a></h2>
<p>Below are a few small examples showcasing how such reflection can be used.</p>
<h3 id="debug-printing">Debug printing<a class="headerlink" href="#debug-printing" title="Permanent link">&para;</a></h3>
<p>Assuming we have a logger than knows how to print tuples, the task of serializing structs for debug purposes becomes almost trivial:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Define struct &amp; reflection</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Quaternion</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// could be any struct with a lot of fields</span>

<span class="n">UTL_STRUCT_REFLECT</span><span class="p">(</span><span class="n">Quaternion</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">);</span>

<span class="c1">// ...</span>

<span class="c1">// Print struct</span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">utl</span><span class="p">;</span>

<span class="k">constexpr</span><span class="w"> </span><span class="n">Quaternion</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="mf">1.5</span><span class="p">,</span><span class="w"> </span><span class="mf">2.5</span><span class="p">,</span><span class="w"> </span><span class="mf">3.5</span><span class="w"> </span><span class="p">};</span>

<span class="n">log</span><span class="o">::</span><span class="n">println</span><span class="p">(</span><span class="s">&quot;q = &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">struct_reflect</span><span class="o">::</span><span class="n">entry_view</span><span class="p">(</span><span class="n">q</span><span class="p">));</span>
</code></pre></div>
<p>will output:</p>
<div class="highlight"><pre><span></span><code>q = &lt; &lt; r, 0.5 &gt;, &lt; i, 1.5 &gt;, &lt; j, 2.5 &gt;, &lt; k, 3.5 &gt; &gt;
</code></pre></div>
<h3 id="binary-operators">Binary operators<a class="headerlink" href="#binary-operators" title="Permanent link">&para;</a></h3>
<p>A binary version of <code>for_each()</code> can be used to implement generic logic for functions &amp; operators:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Define struct &amp; reflection</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Quaternion</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// could be any struct with a lot of fields</span>

<span class="n">UTL_STRUCT_REFLECT</span><span class="p">(</span><span class="n">Quaternion</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">);</span>

<span class="c1">// Define binary operation (member-wise addition)</span>
<span class="k">constexpr</span><span class="w"> </span><span class="n">Quaternion</span><span class="w"> </span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Quaternion</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Quaternion</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Quaternion</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lhs</span><span class="p">;</span>
<span class="w">    </span><span class="n">utl</span><span class="o">::</span><span class="n">struct_reflect</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">res</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">r</span><span class="p">){</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">r</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Define binary operation with predicates (member-wise equality)</span>
<span class="k">constexpr</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Quaternion</span><span class="o">&amp;</span><span class="w"> </span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Quaternion</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">utl</span><span class="o">::</span><span class="n">struct_reflect</span><span class="o">::</span><span class="n">true_for_all</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="n">rhs</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">r</span><span class="p">){</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">r</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
<span class="p">}</span>

<span class="c1">// Test operations</span>
<span class="k">static_assert</span><span class="p">(</span><span class="w"> </span><span class="n">Quaternion</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">}</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Quaternion</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">}</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Quaternion</span><span class="p">{</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">}</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<h3 id="generic-functions-that-operate-on-struct-members">Generic functions that operate on struct members<a class="headerlink" href="#generic-functions-that-operate-on-struct-members" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="c1">// Define structs &amp; reflection</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Vec2</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Vec3</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Vec4</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>

<span class="n">UTL_STRUCT_REFLECT</span><span class="p">(</span><span class="n">Vec2</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="n">UTL_STRUCT_REFLECT</span><span class="p">(</span><span class="n">Vec3</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">);</span>
<span class="n">UTL_STRUCT_REFLECT</span><span class="p">(</span><span class="n">Vec4</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="p">);</span>

<span class="c1">// Generic function</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">constexpr</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">squared_vector_norm</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vec</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">utl</span><span class="o">::</span><span class="n">struct_reflect</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">coord</span><span class="p">){</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">coord</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">coord</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Test the function</span>
<span class="k">static_assert</span><span class="p">(</span><span class="w"> </span><span class="n">squared_vector_norm</span><span class="p">(</span><span class="n">Vec2</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">})</span><span class="w">       </span><span class="o">==</span><span class="w">  </span><span class="mi">5</span><span class="w"> </span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="w"> </span><span class="n">squared_vector_norm</span><span class="p">(</span><span class="n">Vec3</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">})</span><span class="w">    </span><span class="o">==</span><span class="w"> </span><span class="mi">14</span><span class="w"> </span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="w"> </span><span class="n">squared_vector_norm</span><span class="p">(</span><span class="n">Vec4</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">})</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">30</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
<h3 id="advanced-examples">Advanced examples<a class="headerlink" href="#advanced-examples" title="Permanent link">&para;</a></h3>
<p>Real-world applications, of course, extend far beyond the toy problems listed above and would be too verbose to fully present here, for example, this exact principle was used to implement reflection for a <a href="../module_json.html">utl::json</a> parser which knows both how to parse and how to serialize reflected structs with any level of nesting (which means reflected structs can include other reflected structs, nested containers with them and etc.). </p>
<h2 id="why-use-this-over-boostpfr-or-boostdescribe">Why use this over <code>Boost.PFR</code> or <code>Boost.Describe</code><a class="headerlink" href="#why-use-this-over-boostpfr-or-boostdescribe" title="Permanent link">&para;</a></h2>
<ul>
<li>Simpler API</li>
<li>Supports up to 256 enum elements, <code>Boost.Describe</code> is limited to 50</li>
<li>Everything is <code>constexpr</code>, <code>boost::pfr::for_each_field()</code> is not</li>
<li>Single headers (1 for enums, 1 for structs), no dependencies</li>
</ul>
<h2 id="why-use-boostpfr-or-boostdescribe-over-this">Why use <code>Boost.PFR</code> or <code>Boost.Describe</code> over this<a class="headerlink" href="#why-use-boostpfr-or-boostdescribe-over-this" title="Permanent link">&para;</a></h2>
<ul>
<li>More features</li>
<li>Mature libraries</li>
<li>Works with C++14, <code>utl</code> is a C++17 library</li>
<li><code>Boost.PFR</code> doesn't require registration macros</li>
</ul>
<h2 id="map-macro-implementation">Map-macro implementation<a class="headerlink" href="#map-macro-implementation" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code><span class="c1">// Implementation</span>
<span class="cp">#define EVAL0(...) __VA_ARGS__</span>
<span class="cp">#define EVAL1(...) EVAL0(EVAL0(EVAL0(__VA_ARGS__)))</span>
<span class="cp">#define EVAL2(...) EVAL1(EVAL1(EVAL1(__VA_ARGS__)))</span>
<span class="cp">#define EVAL3(...) EVAL2(EVAL2(EVAL2(__VA_ARGS__)))</span>
<span class="cp">#define EVAL4(...) EVAL3(EVAL3(EVAL3(__VA_ARGS__)))</span>
<span class="cp">#define EVAL(...)  EVAL4(EVAL4(EVAL4(__VA_ARGS__)))</span>

<span class="cp">#define MAP_END(...)</span>
<span class="cp">#define MAP_OUT</span>
<span class="cp">#define MAP_COMMA ,</span>

<span class="cp">#define MAP_GET_END2() 0, MAP_END</span>
<span class="cp">#define MAP_GET_END1(...) MAP_GET_END2</span>
<span class="cp">#define MAP_GET_END(...) MAP_GET_END1</span>
<span class="cp">#define MAP_NEXT0(test, next, ...) next MAP_OUT</span>
<span class="cp">#define MAP_NEXT1(test, next) MAP_NEXT0(test, next, 0)</span>
<span class="cp">#define MAP_NEXT(test, next)  MAP_NEXT1(MAP_GET_END test, next)</span>

<span class="cp">#define MAP0(f, x, peek, ...) f(x) MAP_NEXT(peek, MAP1)(f, peek, __VA_ARGS__)</span>
<span class="cp">#define MAP1(f, x, peek, ...) f(x) MAP_NEXT(peek, MAP0)(f, peek, __VA_ARGS__)</span>

<span class="cp">#define MAP_LIST_NEXT1(test, next) MAP_NEXT0(test, MAP_COMMA next, 0)</span>
<span class="cp">#define MAP_LIST_NEXT(test, next)  MAP_LIST_NEXT1(MAP_GET_END test, next)</span>

<span class="cp">#define MAP_LIST0(f, x, peek, ...) f(x) MAP_LIST_NEXT(peek, MAP_LIST1)(f, peek, __VA_ARGS__)</span>
<span class="cp">#define MAP_LIST1(f, x, peek, ...) f(x) MAP_LIST_NEXT(peek, MAP_LIST0)(f, peek, __VA_ARGS__)</span>

<span class="c1">// Applies function-macro &#39;F&#39; to all &#39;__VA_ARGS___&#39;</span>
<span class="cp">#define MAP(f, ...) EVAL(MAP1(f, __VA_ARGS__, ()()(), ()()(), ()()(), 0))</span>

<span class="c1">// Applies function-macro &#39;F&#39; to all &#39;__VA_ARGS___&#39; and add separator commas</span>
<span class="cp">#define MAP_LIST(f, ...) EVAL(MAP_LIST1(f, __VA_ARGS__, ()()(), ()()(), ()()(), 0))</span>
</code></pre></div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The macro supports up to <strong>364</strong> arguments, in practice this is gonna be limited by compiler evaluation depth which usually caps out at <strong>256</strong>.</p>
</div>
<h2 id="alternative-approaches-for-enum-reflection">Alternative approaches for <code>enum</code> reflection<a class="headerlink" href="#alternative-approaches-for-enum-reflection" title="Permanent link">&para;</a></h2>
<p>An alternative approach is taken by <a href="https://github.com/Neargye/magic_enum">magic_enum</a> and some other libraries, it involves compile-time parsing of strings returned by compiler intrinsics <code>__PRETTY_FUNCTION__</code>, <code>__FUNCSIG__</code> and C++20 <a href="https://en.cppreference.com/w/cpp/utility/source_location">std::source_location</a>. As a result it is possible to extract enum names without requiring a registration macro, which is quite convenient. This, however, comes at a price of relying on implementation-dependent behavior and introduces some limitations on reflected enums. Compile times also tend suffer through there are some ways to reduce that impact. This approach has its footguns, but is completely viable as showcased by a multitude of libraries implementing it properly.</p>
<h2 id="alternative-approaches-for-struct-reflection">Alternative approaches for <code>struct</code> reflection<a class="headerlink" href="#alternative-approaches-for-struct-reflection" title="Permanent link">&para;</a></h2>
<p>Some other libraries implement reflection using template metadata fields, inheritance and manual declaration of template specializations. Such approach has a benefit of relying more on the language semantics rather than a preprocessor, however it often comes with additional boilerplate and introduces intrusive semantics, making it difficult to use with types provided by 3rd party libraries and other modules.</p>
<h2 id="related-libraries">Related libraries<a class="headerlink" href="#related-libraries" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>Library</th>
<th>Description</th>
<th>Reflection method</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/Neargye/magic_enum">magic_enum</a></td>
<td>C++17 feature-rich enum reflection</td>
<td>"Pretty function" parsing</td>
</tr>
<tr>
<td><a href="https://github.com/KonanM/static_enum">static_enum</a></td>
<td>C++17 minimalistic enum reflection</td>
<td>"Pretty function" parsing</td>
</tr>
<tr>
<td><a href="../module_enum_reflect.html">utl::enum_reflect</a></td>
<td>C++17 minimalistic enum reflection</td>
<td>Map-macro</td>
</tr>
<tr>
<td><a href="https://github.com/cbeck88/visit_struct">visit_struct</a></td>
<td>C++11 minimalistic structure reflection</td>
<td>Map-macro</td>
</tr>
<tr>
<td><a href="https://github.com/jckarter/selfaware">selfaware</a></td>
<td>C++11 minimalistic structure reflection</td>
<td>Macros &amp; template meta</td>
</tr>
<tr>
<td><a href="../module_struct_reflect.html">utl::struct_reflect</a></td>
<td>C++17 minimalistic structure reflection</td>
<td>Map-macro</td>
</tr>
<tr>
<td><a href="https://github.com/stephenberry/glaze">Glaze</a></td>
<td>C++23 serialization library that also includes reflection</td>
<td>"Pretty function" parsing</td>
</tr>
<tr>
<td><a href="https://github.com/getml/reflect-cpp">reflectcpp</a></td>
<td>C++20 serialization library that also includes reflection</td>
<td>"Pretty function" parsing</td>
</tr>
<tr>
<td><a href="https://www.boost.org/doc/libs/1_61_0/libs/hana/doc/html/index.html">Boost.Hana</a></td>
<td>C++14 metaprogramming library that also includes reflection</td>
<td>Macros &amp; template meta</td>
</tr>
<tr>
<td><a href="https://github.com/boostorg/describe">Boost.Describe</a></td>
<td>C++14 reflection library providing very similar API to the one described here</td>
<td>Map-macro</td>
</tr>
<tr>
<td><a href="https://github.com/boostorg/pfr">Boost.PFR</a></td>
<td>C++14 structure reflection library that doesn't require registration macros</td>
<td>Custom</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Library</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/swansontec/map-macro">map-macro</a></td>
<td>A clean implementation of the map-macro that inspired this post in the first place</td>
</tr>
</tbody>
</table>
<p><strong>Publication date:</strong> 2025.02.23</p>
<p><strong>Last revision:</strong> 2025.09.03</p>







  
  






                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy; 2023–2025 Dmitri Bogdanov
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
        
<div class="md-social">
  
    
    
    
    
      
      
    
    <a href="https://github.com/DmitriBogdanov" target="_blank" rel="noopener" title="github.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "..", "features": ["toc.follow", "content.code.copy", "search.suggest", "content.tooltips"], "search": "../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.f55a23d4.min.js"></script>
      
        <script src="../mkdocs/mathjax.js"></script>
      
        <script src="https://unpkg.com/mathjax@3/es5/tex-mml-chtml.js"></script>
      
        <script src="../mkdocs/modification/header_title.js"></script>
      
        <script src="../mkdocs/modification/relative_links.js"></script>
      
    
  </body>
</html>